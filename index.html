<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-421ESEH10F"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-421ESEH10F');
  </script>
  
  <!-- Enhanced SEO meta tags -->
  <title>Frame Studio - Animate Images Online | Lightweight 2D Animation Tool</title>
  <meta name="description" content="Animate your images online with Frame Studio. Draw on a simple canvas, move layers, and build quick frame-by-frame motion without heavy software. A lightweight way to animate online when you just want pictures to come to life.">
  <meta name="keywords" content="animate images online, animate online, online image animation tool, simple animation editor, lightweight animation software, frame by frame animation, canvas animation, pixel art animation, sprite animation, mp4 export, onion skinning, animation layers, timeline editor">
  <meta name="author" content="Frame Studio">
  <meta name="robots" content="index, follow, max-image-preview:large, max-snippet:-1, max-video-preview:-1">
  <meta name="theme-color" content="#6366f1">
  <meta name="googlebot" content="index, follow">
  <meta name="bingbot" content="index, follow">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0">
  <meta name="format-detection" content="telephone=no">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  
  
  <!-- Open Graph / Facebook -->
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://framestudio.live/">
  <meta property="og:title" content="Frame Studio - Animate Images Online | Lightweight 2D Animation Tool">
  <meta property="og:description" content="Animate your images online with Frame Studio. Draw on the canvas, move layers, and build simple frame-by-frame motion without heavy apps. Lightweight and ready when you just want pictures to move.">
  <meta property="og:image" content="https://framestudio.live/favicon.png">
  <meta property="og:image:width" content="410">
  <meta property="og:image:height" content="410">
  <meta property="og:image:alt" content="Frame Studio Animation Tool Logo">
  <meta property="og:site_name" content="Frame Studio">
  <meta property="og:locale" content="en_US">
  
  <!-- Twitter -->
  <meta property="twitter:card" content="summary_large_image">
  <meta property="twitter:url" content="https://framestudio.live/">
  <meta property="twitter:title" content="Frame Studio - Animate Images Online | Lightweight 2D Animation Tool">
  <meta property="twitter:description" content="Animate your images online with Frame Studio. Draw on the canvas, move layers, and build simple frame-by-frame motion without heavy apps. Lightweight and ready when you just want pictures to move.">
  <meta property="twitter:image" content="https://framestudio.live/favicon.png">
  <meta property="twitter:image:alt" content="Frame Studio Animation Tool Logo">
  <meta property="twitter:creator" content="@FrameStudio">
  <meta property="twitter:site" content="@FrameStudio">
  
  <!-- Canonical URL -->
  <link rel="canonical" href="https://framestudio.live/">
  
  <!-- Performance and SEO optimizations -->
  <link rel="preconnect" href="https://cdn.tailwindcss.com">
  <link rel="preconnect" href="https://unpkg.com">
  <link rel="preconnect" href="https://cdnjs.cloudflare.com">
  <link rel="dns-prefetch" href="https://cdn.tailwindcss.com">
  <link rel="dns-prefetch" href="https://unpkg.com">
  <link rel="dns-prefetch" href="https://cdnjs.cloudflare.com">
  
  <!-- Preload critical resources -->
  <!-- removed unused preloads that caused console warnings -->
  
  <!-- Favicon -->
  <link rel="icon" type="image/png" href="./favicon.png?v=1">
  <link rel="shortcut icon" type="image/png" href="./favicon.png?v=1">
  <link rel="apple-touch-icon" href="./favicon.png?v=1">
  <link rel="icon" type="image/png" sizes="32x32" href="./favicon.png?v=1">
  <link rel="icon" type="image/png" sizes="16x16" href="./favicon.png?v=1">
<link rel="manifest" href="data:application/json,{&quot;name&quot;:&quot;Frame Studio&quot;,&quot;short_name&quot;:&quot;Frame Studio&quot;,&quot;description&quot;:&quot;Online image animation tool for simple canvas drawing and motion.&quot;,&quot;start_url&quot;:&quot;/&quot;,&quot;display&quot;:&quot;standalone&quot;,&quot;background_color&quot;:&quot;#0a0a0a&quot;,&quot;theme_color&quot;:&quot;#6366f1&quot;,&quot;icons&quot;:[{&quot;src&quot;:&quot;./favicon.png?v=1&quot;,&quot;sizes&quot;:&quot;410x410&quot;,&quot;type&quot;:&quot;image/png&quot;}]}">
  
  <!-- Schema.org structured data -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "WebApplication",
    "name": "Frame Studio - Online Image Animation Tool",
    "alternateName": "Frame Studio Animation Tool",
    "description": "Animate your images online with a lightweight canvas editor. Draw, move layers, and build quick frame-by-frame motion without heavy software. Great for pixel art, sprites, and simple loops you can export to MP4.",
    "url": "https://framestudio.live/",
    "applicationCategory": "DesignApplication",
    "operatingSystem": "Any",
    "browserRequirements": "Requires JavaScript. Requires HTML5.",
    "softwareVersion": "1.0",
    "datePublished": "2024-01-01",
    "dateModified": "2024-12-19",
    "offers": {
      "@type": "Offer",
      "price": "0",
      "priceCurrency": "USD",
      "availability": "https://schema.org/InStock"
    },
    "featureList": [
      "Frame-by-frame animation",
      "Multiple layer support",
      "Onion skinning",
      "Advanced drawing tools (brush, pencil, eraser, fill, lasso)",
      "Color palette with custom colors",
      "Animation preview with FPS control",
      "Export to MP4 video",
      "Undo/Redo functionality",
      "Keyboard shortcuts",
      "Mobile responsive design",
      "Desktop and phone viewport modes",
      "Layer management",
      "Frame duplication",
      "Zoom functionality",
      "Pixel art animation",
      "Sprite animation",
      "2D animation creation",
      "Digital art tools",
      "Timeline editor",
      "Professional animation features"
    ],
    "author": {
      "@type": "Organization",
      "name": "Frame Studio",
      "url": "https://framestudio.live/"
    },
    "publisher": {
      "@type": "Organization",
      "name": "Frame Studio",
      "url": "https://framestudio.live/"
    },
    "keywords": "animate images online, animate online, online image animation tool, simple animation editor, lightweight animation software, frame by frame animation, canvas animation, pixel art animation, sprite animation, mp4 export, onion skinning, animation layers, timeline editor",
    "inLanguage": "en-US",
    "isAccessibleForFree": true,
    "screenshot": "https://framestudio.live/favicon.png"
  }
  </script>
  
  <!-- Additional structured data for FAQ -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "FAQPage",
    "mainEntity": [
      {
        "@type": "Question",
        "name": "What is Frame Studio?",
        "acceptedAnswer": {
          "@type": "Answer",
          "text": "Frame Studio is the best free online animation software for creating professional 2D animations, pixel art animations, and sprite animations. It offers advanced features like onion skinning, multiple layers, timeline editing, and MP4 export capabilities."
        }
      },
      {
        "@type": "Question",
        "name": "Is Frame Studio really free?",
        "acceptedAnswer": {
          "@type": "Answer",
          "text": "Yes, Frame Studio is completely free to use with no hidden costs, watermarks, or limitations. You can create professional animations and export them as MP4 videos without any restrictions."
        }
      },
      {
        "@type": "Question",
        "name": "What types of animations can I create?",
        "acceptedAnswer": {
          "@type": "Answer",
          "text": "You can create pixel art animations, sprite animations, 2D character animations, game animations, digital art animations, and frame-by-frame animations. Perfect for game developers, digital artists, and animation enthusiasts."
        }
      },
      {
        "@type": "Question",
        "name": "Do I need to download anything?",
        "acceptedAnswer": {
          "@type": "Answer",
          "text": "No, Frame Studio is a web-based animation tool that works directly in your browser. No downloads or installations required. Just open the website and start creating animations."
        }
      },
      {
        "@type": "Question",
        "name": "Can I export my animations?",
        "acceptedAnswer": {
          "@type": "Answer",
          "text": "Yes, you can export your animations as MP4 videos with customizable frame rates. The export feature supports high-quality video output without watermarks."
        }
      }
    ]
  }
  </script>
  
  <!-- Breadcrumb structured data -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "BreadcrumbList",
    "itemListElement": [
      {
        "@type": "ListItem",
        "position": 1,
        "name": "Home",
        "item": "https://framestudio.live/"
      },
      {
        "@type": "ListItem",
        "position": 2,
        "name": "Animation Software",
        "item": "https://framestudio.live/#animation-software"
      },
      {
        "@type": "ListItem",
        "position": 3,
        "name": "Online Image Animation Tool",
        "item": "https://framestudio.live/#free-animation-tool"
      }
    ]
  }
  </script>
  
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/@ffmpeg/ffmpeg@0.12.6/dist/umd/ffmpeg.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script>
    // Ensure FFmpeg is available globally without throwing if the library failed to load
    try {
      if (typeof window !== 'undefined' && typeof window.FFmpeg === 'undefined' && typeof FFmpeg !== 'undefined') {
        window.FFmpeg = FFmpeg;
      }
    } catch (_e) { /* ignore missing FFmpeg to avoid halting rest of scripts */ }
  </script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      background: #0a0a0a;
      color: #e5e5e5;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      overflow-x: hidden;
    }




    /* Added mobile-responsive styles for collapsible sidebars */
    .sidebar-left, .sidebar-right {
      transition: transform 0.3s ease;
    }

    .menu-toggle {
      display: none;
      position: fixed;
      z-index: 1000;
      background: #1a1a1a;
      border: 2px solid #2a2a2a;
      border-radius: 8px;
      padding: 12px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .menu-toggle:hover {
      background: #252525;
      border-color: #6366f1;
    }

    .menu-toggle:active {
      transform: scale(0.95);
    }

    .menu-toggle-left {
      top: 70px;
      left: 10px;
    }

    .menu-toggle-right {
      top: 70px;
      right: 10px;
    }

    .overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      z-index: 998;
    }

    /* Cut Out mobile drawers & toggles (hidden by default) */
    .cutout-mobile-toggle,
    .cutout-mobile-panel {
      display: none;
    }

    .overlay.active {
      display: block;
    }

    .contact-popup {
      position: absolute;
      background: #0f1116;
      border: 1px solid #2a2a2a;
      border-radius: 10px;
      padding: 10px 12px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
      min-width: 220px;
      z-index: 1200;
    }

    /* Mobile responsive styles */
    @media (max-width: 768px) {
      .menu-toggle {
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .sidebar-left {
        position: fixed;
        top: 0;
        left: 0;
        bottom: 0;
        z-index: 999;
        transform: translateX(-100%);
        width: 280px;
        max-width: 85vw;
        overflow-y: auto;
        border-radius: 0;
      }

      .sidebar-left.open {
        transform: translateX(0);
      }

      .sidebar-right {
        position: fixed;
        top: 0;
        right: 0;
        bottom: 0;
        z-index: 999;
        transform: translateX(100%);
        width: 280px;
        max-width: 85vw;
        overflow-y: auto;
        border-radius: 0;
      }

      .sidebar-right.open {
        transform: translateX(0);
      }

      /* Adjust viewport toggle for mobile */
      .viewport-toggle {
        position: relative;
        left: 0;
        transform: none;
        margin: 0 auto;
      }

      .viewport-btn {
        padding: 6px 12px;
        font-size: 12px;
      }

      /* Make canvas grid single column on mobile */
      .canvas-grid {
        grid-template-columns: 1fr !important;
      }

      /* Adjust top toolbar for mobile */
      .panel:first-child {
        flex-direction: column;
        gap: 12px;
        align-items: stretch;
      }

      .panel:first-child > div:first-child {
        justify-content: center;
      }

      .panel:first-child > div:last-child {
        justify-content: center;
      }
      
      /* Cut Out mobile-specific toggles (shown only in cutout-mobile-mode) */
      .cutout-mobile-toggle {
        display: none;
        position: fixed;
        z-index: 1000;
        background: #1a1a1a;
        border: 2px solid #2a2a2a;
        border-radius: 8px;
        padding: 12px;
        cursor: pointer;
        transition: all 0.2s ease;
        align-items: center;
        justify-content: center;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
      }

      body.cutout-mobile-mode .cutout-mobile-toggle {
        display: flex;
      }

      .cutout-mobile-toggle:active {
        transform: scale(0.96);
      }

      .cutout-mobile-left-toggle {
        top: 136px;
        left: 10px;
      }

      .cutout-mobile-right-toggle {
        top: 136px;
        right: 10px;
      }

      /* Sliding drawers for Cut Out mode on phones */
      .cutout-mobile-panel {
        position: fixed;
        top: 0;
        bottom: 0;
        width: 280px;
        max-width: 85vw;
        background: #0f1116;
        border: 1px solid #2a2a2a;
        border-radius: 0;
        z-index: 1001;
        transition: transform 0.3s ease;
        box-shadow: 0 12px 40px rgba(0, 0, 0, 0.55);
        flex-direction: column;
      }

      body.cutout-mobile-mode .cutout-mobile-panel {
        display: flex;
      }

      .cutout-mobile-panel-left {
        left: 0;
        transform: translateX(-100%);
        border-right: 1px solid #2a2a2a;
      }

      .cutout-mobile-panel-right {
        right: 0;
        transform: translateX(100%);
        border-left: 1px solid #2a2a2a;
      }

      .cutout-mobile-panel.open {
        transform: translateX(0);
      }

      .cutout-mobile-panel-header {
        padding: 14px 16px 10px;
        font-size: 13px;
        font-weight: 600;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: #e5e7eb;
        border-bottom: 1px solid #2a2a2a;
        text-align: center;
      }

      .cutout-mobile-panel-body {
        padding: 12px;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      /* Normalize cutout panels when docked in drawers */
      #cutout-mobile-right-panel #cutout-transform-panel {
        position: static !important;
        width: 100% !important;
        right: auto !important;
        top: auto !important;
        align-items: stretch !important;
        background: transparent;
      }

      #cutout-mobile-right-panel #cutout-transform-panel > div {
        width: 100%;
      }

      #cutout-mobile-left-panel #cutout-picture-board {
        position: static !important;
        width: 100% !important;
        left: auto !important;
        top: auto !important;
      }

      /* Picture Board header actions */
      #cutout-picture-board .cutout-board-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
        width: 100%;
        position: relative;
      }

      #cutout-picture-board .cutout-board-title {
        flex: 1;
        text-align: center;
      }

      #cutout-board-upload-btn {
        display: flex;
        width: 22px;
        height: 22px;
        border-radius: 6px;
        background: #111;
        border: 1px solid #3b3b3b;
        color: #9ca3af;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.2s ease;
        flex-shrink: 0;
      }

      #cutout-board-upload-btn:hover {
        background: #1b1b24;
        border-color: #6366f1;
        color: #ffffff;
      }

      #cutout-board-upload-btn:active {
        transform: scale(0.95);
      }

      #cutout-board-upload-btn svg {
        pointer-events: none;
      }

      body.cutout-mobile-mode #cutout-board-upload-btn {
        display: flex;
      }

      /* Mobile drag ghost for Picture Board */
      #cutout-board-drag-ghost {
        position: fixed;
        width: 34px;
        height: 34px;
        border-radius: 9999px;
        background: rgba(99, 102, 241, 0.92);
        border: 1px solid #a5b4fc;
        color: white;
        display: none;
        align-items: center;
        justify-content: center;
        box-shadow: 0 10px 24px rgba(0, 0, 0, 0.35);
        pointer-events: none;
        z-index: 2000;
      }

      /* Improve Cut Out sliders on phones */
      #cutout-rot-track,
      #cutout-opa-track {
        touch-action: none;
      }

      body.cutout-mobile-mode #cutout-rotbar,
      body.cutout-mobile-mode #cutout-opabar {
        width: 60%;
        justify-content: space-between;
        gap: 8px;
      }

      body.cutout-mobile-mode #cutout-rot-track,
      body.cutout-mobile-mode #cutout-opa-track {
        width: 60%;
        min-width: 60px;
        max-width: 100px;
      }

      body.cutout-mobile-mode #cutout-rot-value,
      body.cutout-mobile-mode #cutout-opa-value {
        min-width: 72px;
      }

      /* Ensure phone dimension canvases fill height properly */
      .canvas-container {
        min-height: 400px;
      }
    }

    /* Desktop Picture Board header styles */
    #cutout-picture-board .cutout-board-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      width: 100%;
    }

    #cutout-picture-board .cutout-board-title {
      flex: 1;
      text-align: center;
    }

    #cutout-board-upload-btn {
      display: flex;
      width: 22px;
      height: 22px;
      border-radius: 6px;
      background: #111;
      border: 1px solid #3b3b3b;
      color: #9ca3af;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s ease;
      flex-shrink: 0;
    }

    #cutout-board-upload-btn:hover {
      background: #1b1b24;
      border-color: #6366f1;
      color: #ffffff;
    }

    #cutout-board-upload-btn:active {
      transform: scale(0.95);
    }

    #cutout-board-upload-btn svg {
      pointer-events: none;
    }

    /* Improved border visibility with better box model */
    .canvas-container {
      position: relative;
      background: #1a1a1a;
      border: 6px solid #2a2a2a;
      border-radius: 12px;
      cursor: crosshair;
      transition: all 0.2s ease;
      aspect-ratio: var(--canvas-aspect-ratio, 1);
      width: 100%;
      max-width: 100%;
      box-sizing: border-box;
      padding: 0;
      overflow: hidden;
      /* Ensure border is always visible */
      outline: 1px solid transparent;
      display: flex;
      align-items: stretch;
      justify-content: stretch;
    }

    .canvas-container canvas {
      /* Make canvas fill container while maintaining aspect ratio */
      width: 100%;
      height: 100%;
      display: block;
      object-fit: cover;
      /* Added transform origin for zoom functionality */
      transform-origin: center center;
      transition: transform 0.1s ease-out;
    }

    .canvas-container:hover {
      border-color: #3a3a3a;
    }

    .canvas-container.active {
      border-color: #6366f1;
      box-shadow: 0 0 0 1px #6366f1;
    }

    .add-frame-container {
      border: 3px dashed #6b7280 !important;
      background: linear-gradient(135deg, #1a1a1a 0%, #2a2a2a 100%) !important;
      cursor: pointer !important;
      transition: all 0.3s ease !important;
      min-height: 300px !important;
      display: flex !important;
      flex-direction: column !important;
      align-items: center !important;
      justify-content: center !important;
      border-radius: 12px !important;
      padding: 20px !important;
      position: relative !important;
      overflow: hidden !important;
    }

    .add-frame-container::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(45deg, transparent 30%, rgba(99, 102, 241, 0.1) 50%, transparent 70%);
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .add-frame-container:hover {
      border-color: #6366f1 !important;
      background: linear-gradient(135deg, #2a2a2a 0%, #3a3a3a 100%) !important;
      transform: scale(1.02);
      box-shadow: 0 8px 25px rgba(99, 102, 241, 0.2) !important;
    }

    .add-frame-container:hover::before {
      opacity: 1;
    }

    .add-frame-container .frame-number {
      color: #d1d5db !important;
      font-size: 14px !important;
      font-weight: 500 !important;
      margin-bottom: 16px !important;
      text-align: center !important;
      letter-spacing: 0.5px !important;
    }

    .add-frame-container svg {
      opacity: 0.8 !important;
      transition: all 0.3s ease !important;
      filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3)) !important;
    }

    .add-frame-container:hover svg {
      opacity: 1 !important;
      transform: scale(1.1) !important;
      filter: drop-shadow(0 4px 8px rgba(99, 102, 241, 0.3)) !important;
    }

    .scroll-to-timeline-btn {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      width: 44px;
      height: 44px;
      background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      box-shadow: 0 6px 25px rgba(99, 102, 241, 0.5);
      transition: all 0.3s ease;
      z-index: 1000;
      border: 2px solid rgba(255, 255, 255, 0.15);
      backdrop-filter: blur(10px);
      animation: subtlePulse 30s infinite;
    }

    @keyframes subtlePulse {
      0%, 95% {
        opacity: 1;
        transform: translateX(-50%) scale(1);
      }
      96%, 98% {
        opacity: 0.8;
        transform: translateX(-50%) scale(1.05);
      }
      99%, 100% {
        opacity: 1;
        transform: translateX(-50%) scale(1);
      }
    }

    .scroll-to-timeline-btn:hover {
      transform: translateX(-50%) scale(1.1);
      box-shadow: 0 10px 35px rgba(99, 102, 241, 0.7);
      background: linear-gradient(135deg, #7c3aed 0%, #a855f7 100%);
      animation: none;
    }

    .scroll-to-timeline-btn:active {
      transform: translateX(-50%) scale(0.95);
    }

    .scroll-to-timeline-btn svg {
      color: white;
      transition: transform 0.3s ease;
      filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.2));
    }

    .scroll-to-timeline-btn:hover svg {
      transform: translateY(2px);
      filter: drop-shadow(0 3px 6px rgba(0, 0, 0, 0.3));
    }

    /* Miniature realtime animation preview above the scroll button */
    .mini-preview-player {
      position: fixed;
      /* 20px (button bottom) + 44px (button size) + 12px gap = 76px */
      bottom: 76px;
      left: 50%;
      transform: translateX(-50%) translateY(6px) scale(0.98);
      width: var(--mini-width, auto);
      height: var(--mini-height, auto);
      aspect-ratio: var(--mini-aspect-ratio, 16 / 9);
      background: #0a0a0a;
      border: 1px solid #2a2a2a;
      border-radius: 8px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.35);
      z-index: 999;
      overflow: hidden;
      backdrop-filter: blur(2px);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.18s ease, transform 0.2s ease, box-shadow 0.2s ease;
    }
    .mini-preview-player canvas {
      width: 100%;
      height: 100%;
      display: block;
    }
    .mini-preview-player.show {
      opacity: 1;
      transform: translateX(-50%) translateY(0) scale(1);
      pointer-events: auto;
      box-shadow: 0 10px 28px rgba(0,0,0,0.45);
    }

    .tool-btn {
      background: #1a1a1a;
      border: 1px solid #2a2a2a;
      color: #a0a0a0;
      padding: 8px 12px;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s ease;
      font-size: 13px;
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    /* Small pill tag for texture brushes */
    .texture-tag {
      display: inline-block;
      font-size: 10px;
      line-height: 1;
      padding: 3px 6px;
      border-radius: 9999px;
      background: rgba(99,102,241,0.12);
      border: 1px solid #3b3b6b;
      color: #a5b4fc;
      margin-left: 8px;
      vertical-align: middle;
    }

    .lasso-toggle-wrapper {
      display: flex;
      align-items: center;
      margin-left: 8px;
    }

    .lasso-toggle {
      position: relative;
      display: inline-flex;
      align-items: center;
      width: 32px;
      height: 18px;
      border-radius: 999px;
      background: #1f2937;
      border: 1px solid #374151;
      padding: 2px;
      box-sizing: border-box;
      transition: background 0.2s ease, border-color 0.2s ease;
      cursor: pointer;
    }

    .lasso-toggle-knob {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: #d1d5db;
      transition: transform 0.2s ease, background 0.2s ease;
      transform: translateX(0);
    }

    .lasso-toggle.active {
      background: #2563eb;
      border-color: #2563eb;
    }

    .lasso-toggle.active .lasso-toggle-knob {
      transform: translateX(14px);
      background: #ffffff;
    }

    .tool-btn:hover {
      background: #252525;
      border-color: #3a3a3a;
      color: #e5e5e5;
    }

    .tool-btn.active {
      background: #6366f1;
      border-color: #6366f1;
      color: white;
    }

    .tool-btn.locked-feature {
      opacity: 0.62;
      cursor: pointer;
      filter: grayscale(20%);
      min-height: 28px;
      position: relative; /* allow Pro badge to overlay without shifting layout */
    }

    .tool-btn.locked-feature:hover {
      background: #252525;
      border-color: #3a3a3a;
      color: #d4d4d4;
    }

    .tool-btn.locked-feature .locked-badge {
      display: flex;
      align-items: center;
      justify-content: center;
      color: #9ca3af;
      font-size: 10px;
      font-weight: 600;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      padding: 2px 6px;
      border-radius: 4px;
      position: absolute; /* overlay on top, do not take layout space */
      right: 6px;
      top: 50%;
      transform: translateY(-50%);
      pointer-events: none;
    }

    .upgrade-text {
      display: inline-block;
      position: relative;
      /* Mesh-style gradient like Magic Effects title, favoring purple (~80%) over grey (~20%) */
      background: linear-gradient(90deg,
        #8b5cf6 0%,
        #a78bfa 28%,
        #8b5cf6 55%,
        #9ca3af 72%,
        #8b5cf6 100%);
      background-size: 200% 100%;
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
    }

    /* Removed hover animation on upgrade text */

    /* Utility fade used to hide header and keep layout space */
    .fade-hide {
      transition: opacity 180ms ease;
    }
    .fade-hidden {
      opacity: 0;
      visibility: hidden; /* preserves layout like visibility:hidden */
    }

    /* Cut Out toggle â€“ cinema style label with mesh gradient and door icon */
    .cutout-toggle {
      justify-content: space-between;
      align-items: center;
    }
    .cutout-label {
      text-transform: uppercase;
      font-weight: 800;
      letter-spacing: 0.08em;
    }
    .mesh-text {
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
    }
    .mesh-green {
      background-image:
        radial-gradient(120px 80px at 10% 30%, rgba(16,185,129,0.95), rgba(16,185,129,0.15) 60%),
        radial-gradient(140px 100px at 85% 70%, rgba(34,197,94,0.9), rgba(34,197,94,0.12) 70%),
        linear-gradient(90deg, #16a34a, #22c55e, #34d399);
    }
    .mesh-red {
      background-image:
        radial-gradient(120px 80px at 12% 25%, rgba(239,68,68,0.95), rgba(239,68,68,0.15) 60%),
        radial-gradient(140px 100px at 82% 75%, rgba(244,63,94,0.9), rgba(244,63,94,0.12) 70%),
        linear-gradient(90deg, #ef4444, #f43f5e, #fb7185);
    }
    .enter-state {
      border-color: rgba(34,197,94,0.35);
      box-shadow: inset 0 0 24px rgba(34,197,94,0.08), 0 0 0 1px rgba(34,197,94,0.18);
    }
    .exit-state {
      border-color: rgba(239,68,68,0.35);
      box-shadow: inset 0 0 24px rgba(239,68,68,0.08), 0 0 0 1px rgba(239,68,68,0.18);
    }
    .door-icon {
      width: 18px;
      height: 18px;
      flex-shrink: 0;
    }
    .enter-state .door-icon { color: #22c55e; }
    .exit-state .door-icon { color: #ef4444; }
    .door-knob {
      transition: transform 220ms cubic-bezier(.2,.8,.2,1);
      transform-origin: center;
    }
    /* Right-side knob in ENTER state (default) */
    .enter-state .door-knob { transform: translateX(0); }
    /* Slide knob left when in EXIT (active Cut Out) state */
    .exit-state .door-knob { transform: translateX(-6px); }

    /* Removed keyframes for upgrade text animation */

    .upgrade-button {
      position: relative;
    }

    .upgrade-pricing {
      position: relative;
      display: inline-block;
    }

    .upgrade-pricing::before {
      content: attr(data-text);
      position: absolute;
      inset: 0;
      color: inherit;
      letter-spacing: 0.02em;
      opacity: 0;
      clip-path: inset(0 100% 0 0);
      transition: clip-path 0s, opacity 0s;
    }

    /* Removed hover animation on pricing line */

    /* Removed keyframes for upgrade pricing animation */


    .slider {
      -webkit-appearance: none;
      appearance: none;
      width: 100%;
      height: 4px;
      border-radius: 2px;
      background: #2a2a2a;
      outline: none;
    }

    .slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #6366f1;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .slider::-webkit-slider-thumb:hover {
      background: #7c3aed;
      transform: scale(1.1);
    }

    .slider::-moz-range-thumb {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #6366f1;
      cursor: pointer;
      border: none;
    }

    /* Magic Effects submenu slider thumbs: smaller and #919191 */
    .effect-settings-panel input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      width: 100%;
      height: 3px;
      border-radius: 2px;
      background: #2a2a2a;
      outline: none;
    }
    .effect-settings-panel input[type="range"]::-webkit-slider-runnable-track {
      height: 3px;
      background: #2a2a2a;
      border-radius: 2px;
    }
    .effect-settings-panel input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #ffffff;
      cursor: pointer;
      margin-top: -2.5px; /* center on 3px track */
    }
    .effect-settings-panel input[type="range"]::-moz-range-thumb {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #ffffff;
      border: none;
      cursor: pointer;
    }
    .effect-settings-panel input[type="range"]::-moz-range-track {
      height: 3px;
      background: #2a2a2a;
      border: none;
      border-radius: 2px;
    }

    .color-swatch {
      width: 32px;
      height: 32px;
      border-radius: 6px;
      border: 2px solid #2a2a2a;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .color-swatch:hover {
      border-color: #6366f1;
      transform: scale(1.05);
    }

    .frame-number {
      position: absolute;
      top: 4px;
      left: 4px;
      background: rgba(0, 0, 0, 0.7);
      color: #a0a0a0;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 600;
      pointer-events: none;
      z-index: 10;
    }

    .onion-skin {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
      width: 100%;
      height: 100%;
    }

    input[type="color"] {
      width: 40px;
      height: 40px;
      border: 2px solid #2a2a2a;
      border-radius: 6px;
      background: #1a1a1a;
      cursor: pointer;
    }

    .panel {
      background: #141414;
      border: 1px solid #2a2a2a;
      border-radius: 8px;
      padding: 16px;
    }

    /* Cut Out Mode layout - percentage-based and fully centered */
    #cutout-mode-container {
      width: 100%;
      margin-bottom: 18px;
    }
    #cutout-mode-container .panel {
      width: clamp(360px, 99.6%, 2400px);
      margin-left: auto;
      margin-right: auto;
    }
    #cutout-canvas-container {
      width: clamp(420px, 95%, 1700px);
      margin-left: auto;
      margin-right: auto;
    }
    #cutout-canvas {
      display: block;
      width: 100%;
      height: auto;
    }

    .divider {
      width: 1px;
      height: 24px;
      background: #2a2a2a;
    }

    .kbd {
      background: #1a1a1a;
      border: 1px solid #2a2a2a;
      border-radius: 4px;
      padding: 2px 6px;
      font-size: 11px;
      font-family: monospace;
      color: #a0a0a0;
    }

    .timeline-frame {
      width: 100%;
      height: 50px;
      border: 2px solid #2a2a2a;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s ease;
      position: relative;
      flex-shrink: 0;
      min-width: 50px;
    }

    .timeline-frame:hover {
      border-color: #3a3a3a;
    }

    .timeline-frame.active {
      border-color: #6366f1;
    }


    /* Timeline frame container for positioning ribs */
    .timeline-frame-container {
      position: relative;
      display: flex;
      align-items: center;
      min-width: 50px;
      width: 50px; /* Increased base width to accommodate duration text */
      transition: width 0.3s ease;
      flex-shrink: 0;
    }
    
    /* Frame index label above each timeline frame */
    .timeline-frame-id {
      position: absolute;
      top: -14px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 11px;
      line-height: 1;
      color: #9ca3af;
      pointer-events: none;
      user-select: none;
    }
    
    /* Ensure timeline frames maintain minimum width when extended */
    .timeline-frame-container[style*="width"] {
      min-width: 50px !important;
    }

    /* Enhanced Timeline Scroll Wheel - Modern App Design */
    #timeline-container {
      position: relative;
    }

    /* Add subtle glow effect to timeline container */
    #timeline-container::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(90deg, 
        rgba(99, 102, 241, 0.1) 0%, 
        transparent 20%, 
        transparent 80%, 
        rgba(99, 102, 241, 0.1) 100%);
      pointer-events: none;
      border-radius: 8px;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    #timeline-container:hover::before {
      opacity: 1;
    }


    /* Add scroll wheel momentum and inertia */
    .timeline-scroll {
      -webkit-overflow-scrolling: touch !important;
      scroll-behavior: smooth !important;
    }

    /* Draggable ribs on the sides of frames */
    .timeline-rib {
      position: absolute;
      width: 8px;
      height: 50px;
      background: #6366f1;
      cursor: ew-resize;
      opacity: 0;
      transition: opacity 0.2s ease;
      z-index: 10;
      border-radius: 2px;
    }

    .timeline-rib-left {
      left: -4px;
    }

    .timeline-rib-right {
      right: -4px;
    }

    .timeline-frame-container:hover .timeline-rib {
      opacity: 0.7;
    }

    .timeline-rib:hover {
      opacity: 1 !important;
      background: #7c3aed;
    }

    .timeline-rib.dragging {
      opacity: 1 !important;
      background: #7c3aed;
      box-shadow: 0 0 8px rgba(124, 58, 237, 0.5);
    }
    
    /* Prevent text selection in cutout timeline area */
    #cutout-mode-timeline, 
    #cutout-timeline, 
    #cutout-ruler-area, 
    #cutout-timeline-clips {
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
    }
    
    /* Cutout transport controls */
    .cutout-transport-btn {
      opacity: 0.95;
      transition: filter 0.2s ease, opacity 0.2s ease, transform 0.2s ease;
      cursor: pointer;
      color: #9ca3af; /* base icon color */
    }
    .cutout-transport-btn:hover svg {
      filter: drop-shadow(0 0 6px rgba(99, 102, 241, 0.6));
      opacity: 1;
    }
    .cutout-transport-btn.active {
      color: #6366f1; /* app purple */
    }

    /* Frame duration indicator */
    .frame-duration-indicator {
      position: absolute;
      bottom: -20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      color: #a0a0a0;
      padding: 2px 4px;
      border-radius: 4px;
      font-size: 9px;
      font-weight: 600;
      pointer-events: none;
      z-index: 5;
      white-space: nowrap;
    }

    /* Visual feedback during drag */
    .timeline-frame-container.dragging {
      position: relative;
    }

    .timeline-frame-container.dragging::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(99, 102, 241, 0.1);
      border: 2px dashed #6366f1;
      border-radius: 4px;
      pointer-events: none;
      z-index: 1;
    }

    .status-bar {
      background: #0f0f0f;
      border-top: 1px solid #2a2a2a;
      padding: 8px 16px;
      font-size: 12px;
      color: #707070;
    }

    .layer-item {
      background: #1a1a1a;
      border: 1px solid #2a2a2a;
      border-radius: 4px;
      padding: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      gap: 8px;
      position: relative;
    }

    .layer-item:hover {
      background: #252525;
      border-color: #3a3a3a;
    }

    .layer-item.active {
      background: #2a2a3a;
      border-color: #6366f1;
    }

    .layer-visibility {
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }

    .layer-name {
      flex: 1;
      font-size: 12px;
    }

    .layer-delete {
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s;
    }

    .layer-item:hover .layer-delete {
      opacity: 1;
    }

    /* Improved grid layout for better responsiveness */
    .canvas-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
      max-width: 1400px;
      margin: 0 auto;
      align-items: stretch;
    }

    @media (min-width: 768px) {
      .canvas-grid {
        grid-template-columns: repeat(2, 1fr);
      }
    }

    @media (min-width: 1024px) {
      .canvas-grid {
        grid-template-columns: repeat(3, 1fr);
      }
    }

    /* Added styles for viewport toggle button */
    .viewport-toggle {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 0.5rem;
      background: #141414;
      border: 1px solid #2a2a2a;
      border-radius: 8px;
      padding: 4px;
    }

    .viewport-btn {
      background: #1a1a1a;
      border: 1px solid #2a2a2a;
      color: #a0a0a0;
      padding: 8px 16px;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s ease;
      font-size: 13px;
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .viewport-btn:hover {
      background: #252525;
      border-color: #3a3a3a;
      color: #e5e5e5;
    }

    .viewport-btn.active {
      background: #6366f1;
      border-color: #6366f1;
      color: white;
    }

  </style>
</head>
<body>

  <!-- Added hamburger menu toggles for mobile -->
  <button class="menu-toggle menu-toggle-left" onclick="toggleLeftSidebar()" aria-label="Toggle tools menu">
    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <circle cx="13.5" cy="6.5" r=".5" fill="currentColor"/>
      <circle cx="17.5" cy="10.5" r=".5" fill="currentColor"/>
      <circle cx="8.5" cy="7.5" r=".5" fill="currentColor"/>
      <circle cx="6.5" cy="12.5" r=".5" fill="currentColor"/>
      <path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10c.926 0 1.648-.746 1.648-1.688 0-.437-.18-.835-.437-1.125-.29-.289-.438-.652-.438-1.125a1.64 1.64 0 0 1 1.668-1.668h1.996c3.051 0 5.555-2.503 5.555-5.554C21.965 6.012 17.461 2 12 2z"/>
    </svg>
  </button>

  <button class="menu-toggle menu-toggle-right" onclick="toggleRightSidebar()" aria-label="Toggle layers menu">
    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path d="M12 2L2 7l10 5 10-5-10-5z"/>
      <path d="M2 17l10 5 10-5"/>
      <path d="M2 12l10 5 10-5"/>
    </svg>
  </button>

  <!-- Cut Out mobile toggles (phone only) -->
  <button class="menu-toggle cutout-mobile-toggle cutout-mobile-left-toggle" onclick="toggleCutoutMobilePanel('left')" aria-label="Toggle Cut Out picture board & layers">
    <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <rect x="3" y="5" width="18" height="14" rx="2" ry="2"></rect>
      <rect x="6.5" y="8" width="6" height="6" rx="1" ry="1"></rect>
      <path d="M14 8h4M14 12h2"></path>
    </svg>
  </button>

  <button class="menu-toggle cutout-mobile-toggle cutout-mobile-right-toggle" onclick="toggleCutoutMobilePanel('right')" aria-label="Toggle Cut Out transform tools & objects">
    <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <circle cx="12" cy="12" r="2.6"></circle>
      <path d="M12 2v5M12 17v5M2 12h5M17 12h5M5.5 5.5l3.1 3.1M15.4 15.4l3.1 3.1M18.5 5.5l-3.1 3.1M5.5 18.5l3.1-3.1"></path>
    </svg>
  </button>

  <!-- Added overlay for mobile sidebar -->
  <div class="overlay" id="sidebar-overlay" onclick="closeSidebars()"></div>

  <!-- Cut Out mobile drawers -->
  <div class="cutout-mobile-panel cutout-mobile-panel-left" id="cutout-mobile-left-panel" aria-label="Cut Out Picture Board and Layers">
    <div class="cutout-mobile-panel-header">Picture Board &amp; Layers</div>
    <div class="cutout-mobile-panel-body" id="cutout-mobile-left-body"></div>
  </div>

  <div class="cutout-mobile-panel cutout-mobile-panel-right" id="cutout-mobile-right-panel" aria-label="Cut Out Transform Tools and Objects">
    <div class="cutout-mobile-panel-header">Transform &amp; Objects</div>
    <div class="cutout-mobile-panel-body" id="cutout-mobile-right-body"></div>
  </div>

  <div class="flex flex-col h-screen">
    <!-- Top Toolbar -->
    <div class="panel border-b border-[#2a2a2a] rounded-none flex items-center justify-between px-6 py-3 relative">
      <div class="flex items-center gap-4">
        <div class="flex items-center gap-3">
          <img id="brand-logo" src="favicon.png" alt="Frame Studio Logo" class="w-8 h-8 rounded-lg" style="width: 32px; height: 32px;">
          <img id="user-avatar" src="" alt="User avatar" referrerpolicy="no-referrer" class="w-8 h-8 rounded-lg border border-[#2a2a2a] hidden" style="width: 32px; height: 32px;">
          <h1 class="text-xl font-bold text-white">Frame Studio</h1>
        </div>
        <div class="divider"></div>
        <span class="text-sm text-gray-500">Online Image Animation Tool</span>
        <div id="login-wrapper" class="ml-4 relative flex items-center">
          <button id="login-toggle" type="button" class="inline-flex items-center text-gray-300 hover:text-white text-xs font-medium border-b border-transparent hover:border-gray-400 transition-all duration-200">
            Login
          </button>
          <div id="google-signin-holder" style="position: absolute; left: -9999px; top: -9999px;"></div>
        </div>
        <a href="features.html" class="ml-4 text-gray-300 hover:text-white text-xs font-medium border-b border-transparent hover:border-gray-400 transition-all duration-200">
          Features
        </a>
        <a href="tutorials.html" class="ml-4 text-gray-300 hover:text-white text-xs font-medium border-b border-transparent hover:border-gray-400 transition-all duration-200">
          Tutorials
        </a>
        <button id="contact-link" class="ml-4 text-gray-300 hover:text-white text-xs font-medium border-b border-transparent hover:border-gray-400 transition-all duration-200" type="button" onclick="toggleContactPopup(event)">
          Contact
        </button>
      </div>
      
      <div class="viewport-toggle">
        <button class="viewport-btn" id="desktop-btn" onclick="setViewport('desktop')">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <rect x="2" y="3" width="20" height="14" rx="2" ry="2"/>
            <line x1="8" y1="21" x2="16" y2="21"/>
            <line x1="12" y1="17" x2="12" y2="21"/>
          </svg>
          Desktop
        </button>
        <button class="viewport-btn active" id="phone-btn" onclick="setViewport('phone')">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <rect x="5" y="2" width="14" height="20" rx="2" ry="2"/>
            <line x1="12" y1="18" x2="12.01" y2="18"/>
          </svg>
          Phone
        </button>
      </div>
      
      <div id="contact-popup" class="contact-popup hidden" role="dialog" aria-label="Contact email">
        <div class="text-xs text-gray-300">Email</div>
        <div class="text-sm font-semibold text-white">yardencode2142@gmail.com</div>
      </div>
      
      <div class="flex items-center gap-2">
        <a href="#" id="upgrade-cta" class="upgrade-button bg-[#16161b] hover:bg-[#1f1f24] border border-[#27272f] text-white font-semibold rounded-lg shadow-lg hover:shadow-xl transform hover:scale-105 transition-all duration-200 flex flex-col items-center justify-center gap-1 px-4" style="height: 44px; padding-top: 6px; padding-bottom: 6px; box-sizing: border-box;">
          <span class="text-sm font-semibold upgrade-text">
            UPGRADE
          </span>
          <span class="text-[11px] text-gray-500 tracking-wide upgrade-pricing" data-text="30$ one-time purchase">
            30$ one-time purchase
          </span>
        </a>
        <button class="bg-gradient-to-r from-green-600 to-emerald-600 hover:from-green-500 hover:to-emerald-500 text-white font-semibold px-4 py-2 rounded-lg shadow-lg hover:shadow-xl transform hover:scale-105 transition-all duration-200 flex items-center gap-2" onclick="exportAnimation()">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M7 10l5 5 5-5M12 15V3"/>
          </svg>
          Export MP4
        </button>
      </div>
    </div>
    <script>
      const CHECKOUT_URL = 'https://framestudiolive.lemonsqueezy.com/buy/61846d41-3d3e-4b0f-8c6c-2f76aa7df8e0';
      const USER_STORAGE_KEY = 'frameStudioUserSession';
      const BACKEND_URLS = [
        'https://backend-navy-psi-26.vercel.app',
        'https://backend-gemexqvsd-jordanlevykislev7-9559s-projects.vercel.app'
      ];
      const PRO_STATUS_CACHE_TTL = 5 * 60 * 1000; // 5 minutes
      let cachedUserSession = null;
      let postLoginRedirect = null;

      // Cookie helpers (fallback when localStorage is unavailable)
      const USER_COOKIE_KEY = 'frameStudioUserCookie';
      const PRO_COOKIE_KEY = 'frameStudioPro';
      // Dev-only diagnostics to understand reload behavior locally
      function devLogAuthState(stage, extra) {
        try {
          const isLocalHost = (location.hostname === '127.0.0.1' || location.hostname === 'localhost');
          if (!isLocalHost) return;
          const proCookie = (function(){ try { return getCookie(PRO_COOKIE_KEY); } catch(_e) { return null; } })();
          const userCookie = (function(){ try { return getCookie(USER_COOKIE_KEY); } catch(_e) { return null; } })();
          const ls = (function(){ try { return localStorage.getItem(USER_STORAGE_KEY); } catch(_e) { return null; } })();
          const parsedLs = (function(){ try { return ls ? JSON.parse(ls) : null; } catch(_e) { return null; } })();
          console.log('[Auth][DEV]', stage, {
            origin: location.origin,
            proCookie,
            hasUserCookie: !!userCookie,
            lsIsPro: !!(parsedLs && parsedLs.isPro),
            lsEmail: parsedLs && parsedLs.email || '',
            extra: extra || null
          });
        } catch (_e) {}
      }
      function setCookie(name, value, days) {
        try {
          const maxAge = Math.max(1, Math.floor(days * 86400));
          document.cookie = name + '=' + encodeURIComponent(value) + '; Max-Age=' + maxAge + '; Path=/; SameSite=Lax';
        } catch (_e) {}
      }
      function getCookie(name) {
        try {
          const parts = ('; ' + document.cookie).split('; ' + name + '=');
          if (parts.length === 2) return decodeURIComponent(parts.pop().split(';').shift());
        } catch (_e) {}
        return null;
      }
      function deleteCookie(name) {
        try { document.cookie = name + '=; Max-Age=0; Path=/; SameSite=Lax'; } catch (_e) {}
      }
      // Establish a fast pro flag as early as possible so later UI refresh can unlock deterministically
      (function bootstrapProFlagFromStorage() {
        try {
          const proCookie = (function(){ try { return getCookie(PRO_COOKIE_KEY) === '1'; } catch(_e) { return false; } })();
          const proFlagLS = (function(){ try { return localStorage.getItem(PRO_UNLOCK_FLAG_KEY) === '1'; } catch(_e) { return false; } })();
          // We do not read full session here to avoid JSON parsing before helpers initialize;
          // this is a quick boolean that will be re-validated later in restoreUserSession.
          if (proCookie || proFlagLS) {
            window.userHasProAccess = true;
            devLogAuthState('bootstrapProFlagFromStorage', { proCookie, proFlagLS });
          }
        } catch (_e) {}
      })();

      function getStoredUserSession() {
        if (cachedUserSession) return cachedUserSession;
        let fromLS = null, fromCookie = null;
        try {
          const raw = localStorage.getItem(USER_STORAGE_KEY);
          if (raw) fromLS = JSON.parse(raw);
        } catch (_e) {}
        try {
          const c = getCookie(USER_COOKIE_KEY);
          if (c) fromCookie = JSON.parse(c);
        } catch (_e2) {}
        if (!fromLS && !fromCookie) return null;
        // Merge, prioritizing any isPro=true and fresher timestamps
        const merged = Object.assign({}, fromCookie || {}, fromLS || {});
        // If either source or dedicated cookie indicates pro, keep it
        const proCookie = getCookie(PRO_COOKIE_KEY) === '1';
        const isProFinal = !!(proCookie || (fromLS && fromLS.isPro) || (fromCookie && fromCookie.isPro));
        merged.isPro = isProFinal;
        // Prefer max proCheckedAt if present
        const pca = Math.max(
          Number.isFinite(fromLS && fromLS.proCheckedAt) ? fromLS.proCheckedAt : 0,
          Number.isFinite(fromCookie && fromCookie.proCheckedAt) ? fromCookie.proCheckedAt : 0
        );
        if (pca > 0) merged.proCheckedAt = pca;
        // Keep most recent picture/email by timestamp
        const tsLS = Number.isFinite(fromLS && fromLS.timestamp) ? fromLS.timestamp : 0;
        const tsCk = Number.isFinite(fromCookie && fromCookie.timestamp) ? fromCookie.timestamp : 0;
        if (tsCk > tsLS && fromCookie) {
          if (fromCookie.picture) merged.picture = fromCookie.picture;
          if (fromCookie.email) merged.email = fromCookie.email;
          merged.timestamp = fromCookie.timestamp;
        } else if (fromLS) {
          if (fromLS.picture) merged.picture = fromLS.picture;
          if (fromLS.email) merged.email = fromLS.email;
          merged.timestamp = fromLS.timestamp || Date.now();
        }
        cachedUserSession = merged;
        return cachedUserSession;
      }

      function storeUserSession(session) {
        // Merge with existing to avoid clobbering a confirmed pro flag
        let prior = null;
        try {
          prior = cachedUserSession || JSON.parse(localStorage.getItem(USER_STORAGE_KEY) || 'null');
        } catch (_e) {
          try {
            const c = getCookie(USER_COOKIE_KEY);
            if (c) prior = JSON.parse(c);
          } catch (_e2) {}
        }
        let merged = {};
        try {
          merged = Object.assign({}, prior || {}, session || {});
          // Preserve isPro=true once set unless explicitly overridden true
          if (prior && prior.isPro === true && (session == null || session.isPro == null || session.isPro === false)) {
            merged.isPro = true;
            if (typeof prior.proCheckedAt === 'number') merged.proCheckedAt = prior.proCheckedAt;
          }
        } catch (_e3) {
          merged = session || {};
        }
        cachedUserSession = merged;
        try {
          localStorage.setItem(USER_STORAGE_KEY, JSON.stringify(merged));
        } catch (e) {
          // Ignore storage failures (e.g., Safari private mode)
        }
        // Also persist minimal session into a cookie to preserve pro on reloads where storage is blocked
        try {
          const minimal = {
            email: merged && merged.email || '',
            picture: merged && merged.picture || '',
            isPro: !!(merged && merged.isPro),
            proCheckedAt: merged && merged.proCheckedAt || 0,
            timestamp: Date.now()
          };
          setCookie(USER_COOKIE_KEY, JSON.stringify(minimal), 365);
          // Dedicated PRO cookie for fast, unsafe unlock - set when pro, DELETE when not pro
          if (minimal.isPro) {
            setCookie(PRO_COOKIE_KEY, '1', 365);
          } else {
            // IMPORTANT: Delete stale pro cookie to avoid interference with new registered users
            deleteCookie(PRO_COOKIE_KEY);
          }
        } catch (_e3) {}
        devLogAuthState('after storeUserSession', { isPro: !!(merged && merged.isPro) });
      }

      function applyUserSession(session) {
        if (!session) return;
        const avatar = document.getElementById('user-avatar');
        const brandLogo = document.getElementById('brand-logo');
        const loginWrapper = document.getElementById('login-wrapper');
        if (avatar && session.picture) {
          avatar.src = session.picture;
          avatar.classList.remove('hidden');
        }
        if (brandLogo) {
          brandLogo.classList.add('hidden');
        }
        if (loginWrapper) {
          loginWrapper.classList.add('hidden');
        }
        if (session.isPro) {
          unlockProFeatures();
        }
      }

      async function restoreUserSession() {
        devLogAuthState('before restoreUserSession');
        const session = getStoredUserSession();
        const proFlag = (getCookie(PRO_COOKIE_KEY) === '1') || (session && session.isPro);
        if (!session && !proFlag) return;
        // Apply immediately so UI shows avatar and unlocks if proFlag is set
        if (session) applyUserSession(session);
        if (proFlag) {
          try { unlockProFeatures(); } catch (_e) {}
          // Ensure storage reflects pro for future loads
          storeUserSession(Object.assign({}, session || {}, { isPro: true, proCheckedAt: Date.now() }));
          devLogAuthState('after restoreUserSession (proFlag true)');
          return;
        }
        // Non-pro session: optionally check membership once (won't run if proFlag cookie exists)
        await updateSessionMembership(session, { forceCheck: !session.isPro });
        storeUserSession(session);
        devLogAuthState('after restoreUserSession (post membership check)', { isPro: !!(session && session.isPro) });
      }

      async function ensureCheckoutFlow() {
        const existingSession = getStoredUserSession();
        if (existingSession && existingSession.email) {
          await updateSessionMembership(existingSession, { forceCheck: !existingSession.isPro });
          storeUserSession(existingSession);
          if (existingSession.isPro) {
            return;
          }
          if (existingSession.credential) {
            window.location.href = CHECKOUT_URL;
            return;
          }
        }
        postLoginRedirect = 'checkout';
        if (window.googleSignIn && typeof window.googleSignIn.trigger === 'function') {
          window.googleSignIn.trigger();
        }
      }

      function decodeJwtPayload(idToken) {
        try {
          var payload = idToken.split('.')[1];
          var base64 = payload.replace(/-/g, '+').replace(/_/g, '/');
          var padded = base64.padEnd(base64.length + (4 - base64.length % 4) % 4, '=');
          var json = atob(padded);
          return JSON.parse(json);
        } catch (e) { return {}; }
      }

      async function handleCredentialResponse(response) {
        if (!response || !response.credential) return;
        var claims = decodeJwtPayload(response.credential);
        var picture = claims.picture || '';
        if (!picture && response.picture) {
          picture = response.picture;
        }
        var session = {
          credential: response.credential,
          name: claims.name || claims.given_name || '',
          picture: picture,
          email: claims.email || '',
          timestamp: Date.now(),
          isPro: false,
          proCheckedAt: 0
        };
        await updateSessionMembership(session, { forceCheck: true });
        storeUserSession(session);
        applyUserSession(session);
        if (session.isPro) {
          postLoginRedirect = null;
          return;
        }
        if (postLoginRedirect === 'checkout') {
          postLoginRedirect = null;
          window.location.href = CHECKOUT_URL;
        }
      }

      async function updateSessionMembership(session, options) {
        if (!session || !session.email) return session;
        const now = Date.now();
        const forceCheck = options && options.forceCheck;
        const lastCheck = session.proCheckedAt || 0;
        // When forceCheck is true, ALWAYS verify with backend - don't trust stale cookie
        if (!forceCheck) {
          // Only trust dedicated pro cookie when NOT force-checking
          try {
            if (getCookie(PRO_COOKIE_KEY) === '1') {
              session.isPro = true;
              session.proCheckedAt = now;
              unlockProFeatures();
              return session;
            }
          } catch (_e) {}
          if (session.isPro) {
            unlockProFeatures();
            return session;
          }
          if (now - lastCheck < PRO_STATUS_CACHE_TTL) {
            if (session.isPro) unlockProFeatures();
            return session;
          }
        }
        // Perform backend check
        const isPro = await checkProMembership(session.email);
        session.proCheckedAt = now;
        if (isPro) {
          session.isPro = true;
          unlockProFeatures();
        } else {
          // Explicitly set to false after backend verification (ensures stale state is cleared)
          session.isPro = false;
        }
        return session;
      }

      async function checkProMembership(email) {
        const normalized = normalizeEmail(email);
        if (!normalized) return false;
        try {
          return await isProByEmail(normalized);
        } catch (error) {
          console.warn('[Pro Check] Failed to verify membership', error);
          return false;
        }
      }

      function normalizeEmail(email) {
        if (!email || typeof email !== 'string') return '';
        return email.trim().toLowerCase();
      }

      async function tryFetchEmailLog(baseUrl) {
        const url = baseUrl.replace(/\/+$/, '') + '/api/email-log';
        const controller = new AbortController();
        const timeoutId = setTimeout(function() { controller.abort(); }, 6000);
        try {
          const resp = await fetch(url, {
            method: 'GET',
            mode: 'cors',
            cache: 'no-store',
            credentials: 'omit',
            headers: { 'Accept': 'application/json' },
            signal: controller.signal
          });
          clearTimeout(timeoutId);
          if (!resp.ok) throw new Error('HTTP ' + resp.status);
          return await resp.json();
        } catch (e) {
          clearTimeout(timeoutId);
          throw e;
        }
      }

      async function isProByEmail(email) {
        const target = normalizeEmail(email);
        if (!target) return false;
        for (let i = 0; i < BACKEND_URLS.length; i++) {
          try {
            const records = await tryFetchEmailLog(BACKEND_URLS[i]);
            if (Array.isArray(records)) {
              for (let j = 0; j < records.length; j++) {
                const entry = records[j] || {};
                const storedEmail = normalizeEmail(entry.email || entry.customerEmail || '');
                if (storedEmail && storedEmail === target) {
                  return true;
                }
              }
            }
          } catch (e) {
            // try next backend URL
          }
        }
        return false;
      }

      const PRO_UNLOCK_FLAG_KEY = 'frameStudioProUnlocked';
      function unlockProFeatures() {
        devLogAuthState('unlockProFeatures called (entry)', { alreadyUnlocked: !!window.userHasProAccess, uiApplied: !!window.proUiApplied });
        // Always ensure entitlement flag is set; do not return early so late-added nodes also unlock
        window.userHasProAccess = true;
        if (!window.proUiApplied) window.proUiApplied = true;
        const upgradeBtn = document.getElementById('upgrade-cta');
        if (upgradeBtn && upgradeBtn.parentElement) {
          upgradeBtn.parentElement.removeChild(upgradeBtn);
        }

        document.querySelectorAll('[data-locked="true"]').forEach((el) => {
          el.removeAttribute('data-locked');
          el.classList.remove('locked-feature');
          el.removeAttribute('aria-disabled');
          if ('disabled' in el) {
            try { el.disabled = false; } catch (e) { /* ignore */ }
          }
          if (el.title === 'Locked feature') {
            el.removeAttribute('title');
          }
          const badge = el.querySelector('.locked-badge');
          if (badge && badge.parentElement) {
            badge.parentElement.removeChild(badge);
          }
        });

        const heatHazeItem = document.querySelector('#effects-list [data-effect-id="heatHaze"]');
        if (heatHazeItem) {
          heatHazeItem.classList.remove('locked-feature');
          heatHazeItem.removeAttribute('aria-disabled');
          const handle = heatHazeItem.querySelector('.effect-drag-handle') || heatHazeItem;
          if (handle) {
            handle.setAttribute('draggable', 'true');
          }
        }

        const bonesBtn = document.getElementById('bones-btn');
        if (bonesBtn) {
          bonesBtn.classList.remove('locked-feature');
          bonesBtn.disabled = false;
          bonesBtn.removeAttribute('aria-disabled');
          bonesBtn.removeAttribute('title');
          if (!bonesBtn.dataset.proBound) {
            bonesBtn.addEventListener('click', () => setTool('bones'));
            bonesBtn.dataset.proBound = 'true';
          }
        }

        if (typeof initMagicEffectsDrag === 'function') {
          initMagicEffectsDrag();
        }
        // Persist a lightweight flag so UI stays unlocked even if third-party libs fail on reload
        try { localStorage.setItem(PRO_UNLOCK_FLAG_KEY, '1'); } catch (_e) {}
        // Also ensure pro cookie is set for fast unlock on page reload (same as heat haze and animation bones)
        try { setCookie(PRO_COOKIE_KEY, '1', 365); } catch (_e) {}
      }

      (function createGoogleSignInHelper() {
        var holder = document.getElementById('google-signin-holder');
        if (!holder) return;
        var googleSignIn = {
          initialized: false,
          pendingTrigger: false,
          init: function() {
            if (this.initialized) return;
            if (!(window.google && window.google.accounts && window.google.accounts.id)) return;
            holder.innerHTML = '';
            window.google.accounts.id.initialize({
              client_id: '961116957473-4de06h1a1tluugp2p1pkc1pm4ipdhjn3.apps.googleusercontent.com',
              callback: handleCredentialResponse,
              auto_select: false,
              cancel_on_tap_outside: false
            });
            window.google.accounts.id.renderButton(holder, {
              type: 'standard',
              size: 'large',
              theme: 'outline',
              text: 'signin_with',
              shape: 'rectangular',
              logo_alignment: 'left'
            });
            this.initialized = true;
            if (this.pendingTrigger) {
              this.pendingTrigger = false;
              this.trigger();
            }
          },
          trigger: function() {
            if (!this.initialized) {
              this.pendingTrigger = true;
              this.init();
              return;
            }
            var googleButton = holder.querySelector('div[role="button"], button');
            if (googleButton) {
              googleButton.click();
            }
          }
        };
        window.googleSignIn = googleSignIn;
      })();

      (function setupLoginButton() {
        var loginButton = document.getElementById('login-toggle');
        if (!loginButton) return;
        loginButton.addEventListener('click', function(event) {
          event.preventDefault();
          ensureCheckoutFlow();
        });
      })();

      // Listen for login iframe messages (avatar + pro status) and persist to session/cookie
      window.addEventListener('message', function(e) {
        try {
          var data = e && e.data;
          if (!data || typeof data !== 'object') return;
          // Update avatar/email immediately
          if (data.type === 'google_credential') {
            var sess = getStoredUserSession() || {};
            if (data.picture) sess.picture = data.picture;
            if (data.email) sess.email = data.email;
            sess.timestamp = Date.now();
            storeUserSession(sess);
            applyUserSession(sess);
          }
          // Persist pro membership and unlock features without waiting for re-check
          if (data.type === 'pro_membership') {
            var sess2 = getStoredUserSession() || {};
            if (data.email) sess2.email = data.email;
            sess2.isPro = !!data.isPro;
            sess2.proCheckedAt = Date.now();
            sess2.timestamp = Date.now();
            storeUserSession(sess2);
            if (sess2.isPro) unlockProFeatures();
          }
        } catch (_e) {}
      }, false);

      (function setupUpgradeButton() {
        var upgradeBtn = document.getElementById('upgrade-cta');
        if (!upgradeBtn) return;
        upgradeBtn.addEventListener('click', function(event) {
          event.preventDefault();
          ensureCheckoutFlow();
        });
      })();

      // If we previously unlocked pro UI, honor it immediately (idempotent)
      try {
        if (localStorage.getItem(PRO_UNLOCK_FLAG_KEY) === '1') {
          unlockProFeatures();
        }
      } catch (_e) {}
      restoreUserSession();
      // After DOM is ready, re-apply pro UI state in case elements were not present earlier
      document.addEventListener('DOMContentLoaded', function() {
        if (window.userHasProAccess && typeof unlockProFeatures === 'function') {
          // Call a lightweight UI refresher: unlockProFeatures is idempotent due to guard
          unlockProFeatures();
        }
        // Enter Cut Out mode by default on initial load
        try {
          if (typeof isCutOutMode !== 'undefined' && !isCutOutMode && typeof toggleCutOutMode === 'function') {
            toggleCutOutMode();
          } else if (typeof setCutOutToggleButtonUi === 'function') {
            setCutOutToggleButtonUi(isCutOutMode);
            applyRightSidebarCutoutVisibility(isCutOutMode);
            if (isCutOutMode && typeof initCutOutMode === 'function') initCutOutMode();
          }
        } catch (_e) {}
      });
      // Observe DOM mutations briefly to unlock newly inserted UI if user is pro
      (function observeProUi() {
        if (!('MutationObserver' in window)) return;
        let runs = 0;
        const obs = new MutationObserver(function() {
          if (!window.userHasProAccess) return;
          runs++;
          if (typeof unlockProFeatures === 'function') unlockProFeatures();
          // Stop after a few runs to avoid overhead
          if (runs > 10) { try { obs.disconnect(); } catch (_e) {} }
        });
        try { obs.observe(document.body, { childList: true, subtree: true }); } catch (_e) {}
        // Safety stop after 5s
        setTimeout(function() { try { obs.disconnect(); } catch (_e) {} }, 5000);
      })();

      (function ensureGoogleIdentityScript() {
        if (document.querySelector('script[data-google-identity="true"]')) return;
        var script = document.createElement('script');
        script.src = 'https://accounts.google.com/gsi/client';
        script.async = true;
        script.defer = true;
        script.dataset.googleIdentity = 'true';
        script.onload = function() {
          if (window.googleSignIn) {
            window.googleSignIn.init();
          }
        };
        document.head.appendChild(script);
      })();
    </script>

    <!-- Main Content -->
    <div class="flex flex-1 overflow-hidden">
      <!-- Added sidebar-left class for mobile responsiveness -->
      <!-- Left Sidebar - Tools -->
      <div class="w-64 panel border-r border-[#2a2a2a] rounded-none flex flex-col gap-6 overflow-y-auto sidebar-left" id="left-sidebar">
        <div>
          <h3 class="text-xs font-semibold text-gray-400 uppercase tracking-wider mb-3">Drawing Tools</h3>
          <div class="flex flex-col gap-2">
            <div class="relative">
              <button class="tool-btn active w-full" id="brush-btn" onclick="toggleBrushMenu()">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="m9.06 11.9 8.07-8.06a2.85 2.85 0 1 1 4.03 4.03l-8.06 8.08"/>
                  <path d="M7.07 14.94c-1.66 0-3 1.35-3 3.02 0 1.33-2.5 1.52-2 2.02 1.08 1.1 2.49 2.02 4 2.02 2.2 0 4-1.8 4-4.04a3.01 3.01 0 0 0-3-3.02z"/>
                </svg>
                <span id="brush-type-text">Brush</span>
                <span class="kbd ml-auto">B</span>
              </button>
              
              <!-- Brush Selection Dropdown -->
              <div id="brush-menu" class="absolute top-full left-0 w-full bg-[#1a1a1a] border border-[#2a2a2a] rounded mt-1 shadow-lg z-50 hidden">
                <div class="p-2">
                  <div class="text-xs text-gray-400 mb-2">Brush Types</div>
                  <div class="max-h-40 overflow-y-auto scrollbar-thin scrollbar-thumb-[#2a2a2a] scrollbar-track-[#1a1a1a] hover:scrollbar-thumb-[#3a3a3a]">
                    <div class="space-y-1 pr-1">
                      <button class="brush-option w-full text-left px-3 py-2 text-sm hover:bg-[#2a2a2a] rounded" onclick="selectBrushType('basic')" data-brush="basic">
                        Basic Brush
                      </button>
                      <button class="brush-option w-full text-left px-3 py-2 text-sm hover:bg-[#2a2a2a] rounded" onclick="selectBrushType('brokenCrayon')" data-brush="brokenCrayon">
                        Broken Crayon
                      </button>
                      <button class="brush-option w-full text-left px-3 py-2 text-sm hover:bg-[#2a2a2a] rounded" onclick="selectBrushType('oil')" data-brush="oil">
                        Oil Paint
                      </button>
                      <div class="h-px bg-[#2a2a2a] my-1"></div>
                      <button class="brush-option w-full text-left px-3 py-2 text-sm hover:bg-[#2a2a2a] rounded" onclick="selectBrushType('voidScratch')" data-brush="voidScratch">
                        Void Scratch
                      </button>
                      <button class="brush-option w-full text-left px-3 py-2 text-sm hover:bg-[#2a2a2a] rounded" onclick="selectBrushType('thornBloom')" data-brush="thornBloom">
                        Thorn Bloom
                      </button>
                      <button class="brush-option w-full text-left px-3 py-2 text-sm hover:bg-[#2a2a2a] rounded" onclick="selectBrushType('runeGlyph')" data-brush="runeGlyph">
                        Rune Glyph
                      </button>
                      <button class="brush-option w-full text-left px-3 py-2 text-sm hover:bg-[#2a2a2a] rounded" onclick="selectBrushType('hexSigil')" data-brush="hexSigil">
                        Hex Sigil
                      </button>
                      <div class="h-px bg-[#2a2a2a] my-1"></div>
                      <button class="brush-option w-full text-left px-3 py-2 text-sm hover:bg-[#263238] rounded" onclick="selectBrushType('animationPath')" data-brush="animationPath" title="Non-exported motion path guide">
                        Animation Path
                      </button>
                    </div>
                  </div>
                </div>
              </div>
            </div>
            <button class="tool-btn" id="pencil-btn" onclick="setTool('pencil')">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"/>
              </svg>
              Pencil <span class="kbd ml-auto">P</span>
            </button>
            <button class="tool-btn" id="eraser-btn" onclick="setTool('eraser')">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="m7 21-4.3-4.3c-1-1-1-2.5 0-3.4l9.6-9.6c1-1 2.5-1 3.4 0l5.6 5.6c1 1 1 2.5 0 3.4L13 21"/>
                <path d="M22 21H7"/>
                <path d="m5 11 9 9"/>
              </svg>
              Eraser <span class="kbd ml-auto">E</span>
            </button>
            <button class="tool-btn" id="fill-btn" onclick="setTool('fill')">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="m4 13 3.5-3.5a2.8 2.8 0 1 1 4 4L8 17"/>
                <path d="M13 8 7 2 2 7l6 6"/>
                <path d="m18 22 4-4-4-4-4 4z"/>
              </svg>
              Fill <span class="kbd ml-auto">F</span>
            </button>
            <!-- Lasso moved to Magic Tools as Eraser Lasso -->
            <button class="tool-btn" id="color-picker-btn" onclick="setTool('color-picker')">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M20 4L4 20"/>
                <path d="M20 4L22 6L6 22"/>
                <path d="M20 4L18 2L2 18"/>
                <ellipse cx="20" cy="4" rx="2.5" ry="2" fill="currentColor"/>
                <path d="M4 20L2 22"/>
                <circle cx="2" cy="22" r="1.5" fill="currentColor"/>
              </svg>
              Color Picker <span class="kbd ml-auto">C</span>
            </button>
            <button class="tool-btn" id="select-btn" onclick="setTool('select')">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M3 3l7 3 3 7-7-3-3-7z"/>
                <path d="M13 13l6 6"/>
              </svg>
              <span>Select/Move</span>
              <span class="kbd ml-auto">V</span>
            </button>
            <button class="tool-btn" id="inner-fill-btn" onclick="setTool('inner-fill')">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M3 3h18v18H3z"/>
                <path d="M9 9h6v6H9z"/>
                <path d="M12 6v12M6 12h12"/>
              </svg>
              Inner Fill <span class="kbd ml-auto">O</span>
            </button>
          </div>
        </div>

        <div class="h-px bg-[#2a2a2a]"></div>

        <div>
          <h3 class="text-xs font-semibold text-gray-400 uppercase tracking-wider mb-3">Color</h3>
          <div class="flex items-center gap-3 mb-4">
            <input type="color" id="color-picker" value="#ffffff" onchange="updateColor(this.value)">
            <div class="flex-1">
              <div class="text-xs text-gray-400 mb-1">Current</div>
              <div id="current-color" class="text-sm font-mono">#FFFFFF</div>
            </div>
          </div>
          <div class="grid grid-cols-5 gap-2">
            <div class="color-swatch" style="background: #ffffff" onclick="selectColor('#ffffff')"></div>
            <div class="color-swatch" style="background: #000000" onclick="selectColor('#000000')"></div>
            <div class="color-swatch" style="background: #ff0000" onclick="selectColor('#ff0000')"></div>
            <div class="color-swatch" style="background: #00ff00" onclick="selectColor('#00ff00')"></div>
            <div class="color-swatch" style="background: #0000ff" onclick="selectColor('#0000ff')"></div>
            <div class="color-swatch" style="background: #ffff00" onclick="selectColor('#ffff00')"></div>
            <div class="color-swatch" style="background: #ff00ff" onclick="selectColor('#ff00ff')"></div>
            <div class="color-swatch" style="background: #00ffff" onclick="selectColor('#00ffff')"></div>
            <div class="color-swatch" style="background: #ff8800" onclick="selectColor('#ff8800')"></div>
            <div class="color-swatch" style="background: #8800ff" onclick="selectColor('#8800ff')"></div>
          </div>
        </div>

        <div class="h-px bg-[#2a2a2a]"></div>

        <div>
          <h3 class="text-xs font-semibold text-gray-400 uppercase tracking-wider mb-3">Brush Settings</h3>
          <div class="space-y-4">
            <div>
              <div class="flex justify-between text-xs text-gray-400 mb-2">
                <span>Size</span>
                <span id="size-value">7</span>
              </div>
              <input type="range" class="slider" id="brush-size" min="1" max="50" value="7" oninput="updateBrushSize(this.value)">
            </div>
            <div>
              <div class="flex justify-between text-xs text-gray-400 mb-2">
                <span>Opacity</span>
                <span id="opacity-value">100%</span>
              </div>
              <input type="range" class="slider" id="brush-opacity" min="0" max="100" value="100" oninput="updateOpacity(this.value)">
            </div>
          </div>
        </div>

        <div class="h-px bg-[#2a2a2a]"></div>

        <!-- Removed auto-advance behavior from onion skinning -->
        <div>
          <h3 class="text-xs font-semibold text-gray-400 uppercase tracking-wider mb-3">Onion Skinning</h3>
          <label class="flex items-center gap-2 cursor-pointer mb-3">
            <input type="checkbox" id="onion-skin-prev" onchange="toggleOnionSkin()" class="w-4 h-4" checked>
            <span class="text-sm">Show Previous Frame</span>
          </label>
          <div id="onion-controls" style="display: block;">
            <div class="flex justify-between text-xs text-gray-400 mb-2">
              <span>Onion Opacity</span>
              <span id="onion-opacity-value">30%</span>
            </div>
            <input type="range" class="slider" id="onion-opacity" min="5" max="80" value="30" oninput="updateOnionOpacity(this.value)">
          </div>
        </div>

        <div class="h-px bg-[#2a2a2a]"></div>

        <div>
          <h3 class="text-xs font-semibold text-gray-400 uppercase tracking-wider mb-3">Frame Actions</h3>
          <div class="flex flex-col gap-2">
            <button class="tool-btn" onclick="clearCurrentFrame()">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M3 6h18M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/>
              </svg>
              Clear Frame
            </button>
            <button class="tool-btn" onclick="deleteCurrentFrame()">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M3 6h18"/>
                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6"/>
                <path d="M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                <line x1="10" y1="11" x2="10" y2="17"/>
                <line x1="14" y1="11" x2="14" y2="17"/>
              </svg>
              Delete Frame
            </button>
            <input id="image-file-input" type="file" accept="image/*" style="display:none" onchange="handleImageFileInput(this.files)" />
            <button class="tool-btn" onclick="document.getElementById('image-file-input').click()">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M12 5v14M5 12h14"/>
                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
              </svg>
              Import Image
            </button>
            <button class="tool-btn" onclick="duplicateFrame()">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect width="14" height="14" x="8" y="8" rx="2" ry="2"/>
                <path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"/>
              </svg>
              Duplicate Frame
            </button>
            <button class="tool-btn" onclick="clearAllFrames()">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M3 6h18M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2M10 11v6M14 11v6"/>
              </svg>
              Clear All Frames
            </button>
          </div>
        </div>
      </div>

      <!-- Center - Canvas Area -->
      <div class="flex-1 flex flex-col overflow-hidden">
        <!-- Canvas Grid -->
        <div class="flex-1 overflow-auto p-6">
          <!-- Improved responsive grid layout -->
          <div id="frame-mode-canvas-grid" class="canvas-grid">
            <div class="canvas-container active" id="frame-container-0">
              <div class="frame-number" id="frame-label-0">Frame 1 - Layer 1</div>
              <canvas id="canvas-0" width="300" height="300"></canvas>
              <canvas class="onion-skin" id="onion-0" width="300" height="300"></canvas>
            </div>
            <div class="canvas-container" id="frame-container-1">
              <div class="frame-number" id="frame-label-1">Frame 2 - Layer 1</div>
              <canvas id="canvas-1" width="300" height="300"></canvas>
              <canvas class="onion-skin" id="onion-1" width="300" height="300"></canvas>
            </div>
            <div class="canvas-container" id="frame-container-2">
              <div class="frame-number" id="frame-label-2">Frame 3 - Layer 1</div>
              <canvas id="canvas-2" width="300" height="300"></canvas>
              <canvas class="onion-skin" id="onion-2" width="300" height="300"></canvas>
            </div>
            <div class="canvas-container" id="frame-container-3">
              <div class="frame-number" id="frame-label-3">Frame 4 - Layer 1</div>
              <canvas id="canvas-3" width="300" height="300"></canvas>
              <canvas class="onion-skin" id="onion-3" width="300" height="300"></canvas>
            </div>
            <div class="canvas-container" id="frame-container-4">
              <div class="frame-number" id="frame-label-4">Frame 5 - Layer 1</div>
              <canvas id="canvas-4" width="300" height="300"></canvas>
              <canvas class="onion-skin" id="onion-4" width="300" height="300"></canvas>
            </div>
            <div class="canvas-container" id="frame-container-5">
              <div class="frame-number" id="frame-label-5">Frame 6 - Layer 1</div>
              <canvas id="canvas-5" width="300" height="300"></canvas>
              <canvas class="onion-skin" id="onion-5" width="300" height="300"></canvas>
            </div>
            
            <!-- Add Frame Button -->
            <div class="canvas-container add-frame-container" onclick="console.log('Add frame clicked'); addNewFrame();">
              <div class="frame-number">Add Frame</div>
              <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="#d1d5db" stroke-width="2.5">
                <line x1="12" y1="5" x2="12" y2="19"/>
                <line x1="5" y1="12" x2="19" y2="12"/>
              </svg>
            </div>
          </div>

          <!-- Animation Preview -->
          <div id="frame-mode-preview" class="mt-8 max-w-6xl mx-auto">
            <div class="panel">
              <div class="flex items-center justify-between mb-4">
                <div class="flex items-center gap-2">
                  <h3 class="text-sm font-semibold text-white">Animation Preview</h3>
                </div>
                <div class="flex items-center gap-3">
                  <div class="flex items-center gap-2">
                    <span class="text-xs text-gray-400">FPS:</span>
                    <input type="number" id="fps-input" value="10" min="1" max="60" class="w-16 bg-[#1a1a1a] border border-[#2a2a2a] rounded px-2 py-1 text-sm" onchange="updateFPS(this.value)">
                  </div>
                  <div class="flex items-center gap-2">
                    <span class="text-xs text-gray-400">Loops:</span>
                    <input type="number" id="loop-input" value="1" min="1" max="100" class="w-16 bg-[#1a1a1a] border border-[#2a2a2a] rounded px-2 py-1 text-sm" onchange="updateLoopCount(this.value)">
                  </div>
                  <button class="tool-btn" id="play-btn" onclick="toggleAnimation()">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                      <polygon points="5 3 19 12 5 21 5 3"/>
                    </svg>
                    Play
                  </button>
                </div>
              </div>
          <div class="flex justify-center mb-2">
            <div class="text-xs text-gray-400">
              Duration: <span id="total-duration" class="text-white font-mono">0.6s</span>
            </div>
          </div>
          <div class="flex justify-center">
            <div class="canvas-container" id="preview-container" style="max-width: 300px;">
              <canvas id="preview-canvas"></canvas>
            </div>
          </div>
            </div>
          </div>

          <!-- Timeline - Edge to Edge Background -->
          <div id="frame-mode-timeline" class="bg-[#0a0a0a] border-t border-[#2a2a2a] mt-8 -mx-6 px-6 py-4">
            <div class="flex items-center justify-between mb-3">
              <h3 class="text-xs font-semibold text-gray-400 uppercase tracking-wider">Timeline</h3>
              <div class="flex items-center gap-2">
                <button class="tool-btn text-xs py-1" onclick="previousFrame()">
                  <svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor">
                    <polygon points="15 18 9 12 15 6"/>
                  </svg>
                </button>
                <button class="tool-btn text-xs py-1" onclick="nextFrame()">
                  <svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor">
                    <polygon points="9 18 15 12 9 6"/>
                  </svg>
                </button>
              </div>
            </div>
            
            <!-- Interactive Timeline Ruler -->
            <div class="mb-4">
              <div class="text-xs text-gray-400 mb-2">Timeline Ruler</div>
              <div class="relative bg-[#1a1a1a] border border-[#2a2a2a] rounded p-2" style="height: 60px; overflow: hidden;">
                <div id="timeline-ruler" class="relative h-full cursor-pointer" style="min-width: 100%;" onmousedown="startTimelineScrub(event)" onmousemove="updateTimelineHover(event)" onmouseleave="hideTimelineHover()">
                  <!-- Interactive ruler will be generated by JavaScript -->
                </div>
                <!-- Scrubber line -->
                <div id="timeline-scrubber" class="absolute top-0 bottom-0 w-0.5 bg-[#6366f1] pointer-events-none" style="left: 0px; z-index: 20; box-shadow: 0 0 4px rgba(99, 102, 241, 0.5);">
                  <!-- Scrubber handle -->
                  <div class="absolute -top-1 -left-1 w-3 h-3 bg-[#6366f1] border border-white rounded-full" style="box-shadow: 0 0 4px rgba(0, 0, 0, 0.3);"></div>
                </div>
                <!-- Time display -->
                <div id="timeline-time-display" class="absolute top-1 right-1 bg-[#1a1a1a] border border-[#6366f1] rounded px-2 py-1 text-xs text-white font-mono pointer-events-none" style="z-index: 30; display: none;">
                  0.0s
                </div>
              </div>
            </div>
            
            <div id="timeline-container" class="flex gap-2 pt-4 pb-6 timeline-scroll" style="width: 100%; overflow-x: auto; overflow-y: hidden; min-width: 0; scroll-behavior: smooth; scrollbar-gutter: stable;">
              <div class="timeline-frame-container">
                <div class="timeline-frame-id">1</div>
                <div class="timeline-frame active" id="timeline-0" onclick="selectFrame(0, event)">
                  <canvas width="60" height="60" id="thumb-0" style="width: 100%; height: 100%; object-fit: cover; pointer-events: none;"></canvas>
                  <div class="frame-duration-indicator" id="duration-0">1x</div>
                </div>
                <div class="timeline-rib timeline-rib-left" id="rib-left-0" onmousedown="startRibDrag(event, 0, 'left')"></div>
                <div class="timeline-rib timeline-rib-right" id="rib-right-0" onmousedown="startRibDrag(event, 0, 'right')"></div>
              </div>
              <div class="timeline-frame-container">
                <div class="timeline-frame-id">2</div>
                <div class="timeline-frame" id="timeline-1" onclick="selectFrame(1, event)">
                  <canvas width="60" height="60" id="thumb-1" style="width: 100%; height: 100%; object-fit: cover; pointer-events: none;"></canvas>
                  <div class="frame-duration-indicator" id="duration-1">1x</div>
                </div>
                <div class="timeline-rib timeline-rib-left" id="rib-left-1" onmousedown="startRibDrag(event, 1, 'left')"></div>
                <div class="timeline-rib timeline-rib-right" id="rib-right-1" onmousedown="startRibDrag(event, 1, 'right')"></div>
              </div>
              <div class="timeline-frame-container">
                <div class="timeline-frame-id">3</div>
                <div class="timeline-frame" id="timeline-2" onclick="selectFrame(2, event)">
                  <canvas width="60" height="60" id="thumb-2" style="width: 100%; height: 100%; object-fit: cover; pointer-events: none;"></canvas>
                  <div class="frame-duration-indicator" id="duration-2">1x</div>
                </div>
                <div class="timeline-rib timeline-rib-left" id="rib-left-2" onmousedown="startRibDrag(event, 2, 'left')"></div>
                <div class="timeline-rib timeline-rib-right" id="rib-right-2" onmousedown="startRibDrag(event, 2, 'right')"></div>
              </div>
              <div class="timeline-frame-container">
                <div class="timeline-frame-id">4</div>
                <div class="timeline-frame" id="timeline-3" onclick="selectFrame(3, event)">
                  <canvas width="60" height="60" id="thumb-3" style="width: 100%; height: 100%; object-fit: cover; pointer-events: none;"></canvas>
                  <div class="frame-duration-indicator" id="duration-3">1x</div>
                </div>
                <div class="timeline-rib timeline-rib-left" id="rib-left-3" onmousedown="startRibDrag(event, 3, 'left')"></div>
                <div class="timeline-rib timeline-rib-right" id="rib-right-3" onmousedown="startRibDrag(event, 3, 'right')"></div>
              </div>
              <div class="timeline-frame-container">
                <div class="timeline-frame-id">5</div>
                <div class="timeline-frame" id="timeline-4" onclick="selectFrame(4, event)">
                  <canvas width="60" height="60" id="thumb-4" style="width: 100%; height: 100%; object-fit: cover; pointer-events: none;"></canvas>
                  <div class="frame-duration-indicator" id="duration-4">1x</div>
                </div>
                <div class="timeline-rib timeline-rib-left" id="rib-left-4" onmousedown="startRibDrag(event, 4, 'left')"></div>
                <div class="timeline-rib timeline-rib-right" id="rib-right-4" onmousedown="startRibDrag(event, 4, 'right')"></div>
              </div>
              <div class="timeline-frame-container">
                <div class="timeline-frame-id">6</div>
                <div class="timeline-frame" id="timeline-5" onclick="selectFrame(5, event)">
                  <canvas width="60" height="60" id="thumb-5" style="width: 100%; height: 100%; object-fit: cover; pointer-events: none;"></canvas>
                  <div class="frame-duration-indicator" id="duration-5">1x</div>
                </div>
                <div class="timeline-rib timeline-rib-left" id="rib-left-5" onmousedown="startRibDrag(event, 5, 'left')"></div>
                <div class="timeline-rib timeline-rib-right" id="rib-right-5" onmousedown="startRibDrag(event, 5, 'right')"></div>
              </div>
            </div>
          </div>

          <!-- Cut Out Mode (separate mode) -->
          <div id="cutout-mode-container" style="display: none;">
            <div class="mt-8 mx-auto" style="max-width: none; width: 100%;">
              <div class="panel" style="position: relative;">
                <div style="position:absolute; left:16px; top:12px;">
                  <h3 class="text-sm font-semibold text-white">Cut Out Mode</h3>
                </div>
                <div class="flex justify-center">
                  <div class="canvas-container" id="cutout-canvas-container">
                    <canvas id="cutout-canvas"></canvas>
                  </div>
                </div>
                <!-- Picture Board (left side) -->
                <div id="cutout-picture-board" style="position:absolute; left:12px; top:56px; width:300px; display:flex; flex-direction:column; gap:12px; z-index:5;">
                  <div class="cutout-board-header">
                    <div style="width:22px; height:22px; border-radius:6px; border:1px solid transparent; background:transparent; pointer-events:none; flex-shrink:0;"></div>
                    <div class="cutout-board-title" style="color:#9ca3af; font-size:11px; font-weight:600; letter-spacing:0.08em; text-transform:uppercase; text-align:center; flex:1;">Picture Board</div>
                    <button id="cutout-board-upload-btn" type="button" aria-label="Upload images to Picture Board">
                      <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="9"></circle>
                        <path d="M12 8v8M8 12h8"></path>
                      </svg>
                    </button>
                    <input id="cutout-board-file-input" type="file" accept="image/*" multiple style="display:none;" />
                  </div>
                  <div style="width:100%; height:1px; background:#2a2a2a;"></div>
                  <div id="cutout-board-body" style="height:188px; border:1px solid #2a2a2a; border-radius:10px; background:#0b0b0b; position:relative; overflow:auto;">
                    <div id="cutout-board-placeholder" style="position:absolute; inset:0; display:flex; align-items:center; justify-content:center; color:#9ca3af; font-size:12px; pointer-events:none;">
                      Drag images here
                    </div>
                    <div id="cutout-board-grid" style="display:grid; grid-template-columns: repeat(4, 1fr); gap:8px; padding:8px;"></div>
                  </div>
                </div>
                <!-- Recorder control centered above canvas -->
                <div id="cutout-recorder" style="position:absolute; left:50%; transform:translateX(-50%); top:-12px; display:flex; align-items:center; gap:10px; background:transparent; z-index:5;">
                  <button id="cutout-rec-btn" title="Record / Pause" style="width:18px; height:18px; border-radius:50%; background:#6b7280; border:2px solid #3b3b3b; box-shadow:0 0 6px rgba(0,0,0,0.35); cursor:pointer;"></button>
                  <div id="cutout-rec-time" title="Drag to scrub time" style="min-width:90px; padding:2px 6px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Courier New', monospace; font-size:13px; color:#e5e7eb; background:#111; border:1px solid #2a2a2a; border-radius:4px; text-align:center; cursor:ew-resize;">00:00:00</div>
                </div>
                <!-- Transform Tool panel (right side) -->
                <div id="cutout-transform-panel" style="position:absolute; right:12px; top:56px; display:flex; flex-direction:column; gap:12px; align-items:flex-end; background:transparent; z-index:5;">
                  <div style="color:#9ca3af; font-size:11px; font-weight:600; letter-spacing:0.08em; text-transform:uppercase; width:100%; text-align:center;">Transform Tools</div>
                  <div style="width:100%; height:1px; background:#2a2a2a;"></div>
                  <!-- Position row -->
                  <div style="width:100%; text-align:center; color:#d1d5db; font-size:12px; font-weight:600;">Position</div>
                  <div id="cutout-posbar" style="display:flex; align-items:center; gap:8px; width:100%; justify-content:flex-end;">
                    <div style="color:#d1d5db; font-size:12px;">X</div>
                    <div id="cutout-pos-x" style="min-width:86px; padding:4px 8px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace; font-size:14px; color:#e5e7eb; background:#000000; border:1px solid #111; border-radius:4px; text-align:right; cursor:ew-resize;">00.000</div>
                    <div style="color:#d1d5db; font-size:12px; margin-left:8px;">Y</div>
                    <div id="cutout-pos-y" style="min-width:86px; margin-left:auto; padding:4px 8px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace; font-size:14px; color:#e5e7eb; background:#000000; border:1px solid #111; border-radius:4px; text-align:right; cursor:ew-resize;">00.000</div>
                    <div id="cutout-pos-key" title="Key Position" style="width:12px; height:12px; margin-left:8px; background:#6b7280; transform:rotate(45deg); cursor:pointer; border:1px solid #3b3b3b; flex-shrink:0;" onclick="togglePropertyKey('position')"></div>
                  </div>
                  <!-- Zoom row -->
                  <div style="width:100%; text-align:center; color:#d1d5db; font-size:12px; font-weight:600; margin-top:6px;">Zoom</div>
                  <div id="cutout-zoombar" style="display:flex; align-items:center; gap:8px; width:100%; justify-content:flex-end;">
                    <div style="color:#d1d5db; font-size:12px;">X</div>
                    <div id="cutout-zoom-x" style="min-width:86px; padding:4px 8px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace; font-size:14px; color:#e5e7eb; background:#000000; border:1px solid #111; border-radius:4px; text-align:right; cursor:ew-resize;">1.000</div>
                    <div style="color:#d1d5db; font-size:12px; margin-left:8px;">Y</div>
                    <div id="cutout-zoom-y" style="min-width:86px; margin-left:auto; padding:4px 8px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace; font-size:14px; color:#e5e7eb; background:#000000; border:1px solid #111; border-radius:4px; text-align:right; cursor:ew-resize;">1.000</div>
                    <div id="cutout-zoom-key" title="Key Zoom" style="width:12px; height:12px; margin-left:8px; background:#6b7280; transform:rotate(45deg); cursor:pointer; border:1px solid #3b3b3b; flex-shrink:0;" onclick="togglePropertyKey('zoom')"></div>
                  </div>
                  <!-- Rotation row -->
                  <div id="cutout-rotbar" style="display:flex; align-items:center; gap:12px; width:100%; justify-content:flex-end;">
                    <div style="color:#d1d5db; font-size:12px; white-space:nowrap;">Rotation</div>
                    <div id="cutout-rot-track" style="position:relative; width:121px; height:6px; background:#1f2937; border:1px solid #111; border-radius:9999px; cursor:ew-resize;">
                      <div id="cutout-rot-knob" style="position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); width:14px; height:14px; background:#9ca3af; border:2px solid #3b3b3b; border-radius:50%; pointer-events:none;"></div>
                    </div>
                    <div id="cutout-rot-value" style="min-width:86px; margin-left:auto; padding:4px 8px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace; font-size:14px; color:#e5e7eb; background:#000000; border:1px solid #111; border-radius:4px; text-align:right;">0.000</div>
                    <div id="cutout-rot-key" title="Key Rotation" style="width:12px; height:12px; margin-left:8px; background:#6b7280; transform:rotate(45deg); cursor:pointer; border:1px solid #3b3b3b; flex-shrink:0;" onclick="togglePropertyKey('rotation')"></div>
                  </div>
                  <!-- Opacity row -->
                  <div id="cutout-opabar" style="display:flex; align-items:center; gap:12px; width:100%; justify-content:flex-end;">
                    <div style="color:#d1d5db; font-size:12px; white-space:nowrap;">Opacity</div>
                    <div id="cutout-opa-track" style="position:relative; width:121px; height:6px; background:#1f2937; border:1px solid #111; border-radius:9999px; cursor:ew-resize;">
                      <div id="cutout-opa-knob" style="position:absolute; top:50%; left:100%; transform:translate(-50%, -50%); width:14px; height:14px; background:#9ca3af; border:2px solid #3b3b3b; border-radius:50%; pointer-events:none;"></div>
                    </div>
                    <div id="cutout-opa-value" style="min-width:86px; margin-left:auto; padding:4px 8px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace; font-size:14px; color:#e5e7eb; background:#000000; border:1px solid #111; border-radius:4px; text-align:right;">1.000</div>
                    <div id="cutout-opa-key" title="Key Opacity" style="width:12px; height:12px; margin-left:8px; background:#6b7280; transform:rotate(45deg); cursor:pointer; border:1px solid #3b3b3b; flex-shrink:0;" onclick="togglePropertyKey('opacity')"></div>
                  </div>
                </div>
              </div>
            </div>
          </div>
          <div id="cutout-mode-timeline" class="bg-[#0a0a0a] border-t border-[#2a2a2a] mt-8 -mx-6 px-6 py-4" style="display: none;">
            <div class="grid grid-cols-3 items-center mb-3">
              <div class="justify-self-start">
                <h3 class="text-xs font-semibold text-gray-400 uppercase tracking-wider">Timeline</h3>
              </div>
              <div class="justify-self-center">
                <div class="flex items-center gap-3">
                  <button id="cutout-btn-reverse" class="cutout-transport-btn p-1" aria-label="Reverse" onclick="cutoutPlayReverse()">
                    <svg width="31" height="31" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                      <polygon points="18,6 8,12 18,18" />
                    </svg>
                  </button>
                  <button id="cutout-btn-pause" class="cutout-transport-btn p-1" aria-label="Pause" onclick="cutoutPause()">
                    <svg width="20" height="20" viewBox="0 0 20 20" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                      <rect x="2" y="2" width="16" height="16" />
                    </svg>
                  </button>
                  <button id="cutout-btn-play" class="cutout-transport-btn p-1" aria-label="Play" onclick="cutoutPlayForward()">
                    <svg width="31" height="31" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                      <polygon points="6,6 16,12 6,18" />
                    </svg>
                  </button>
                </div>
              </div>
              <div class="justify-self-end">
                <div class="flex items-center gap-2">
                  <button class="tool-btn text-xs py-1" onclick="cutoutAddKey()">Add Key</button>
                  <button class="tool-btn text-xs py-1" onclick="cutoutClearKeys()">Clear Keys</button>
                </div>
              </div>
            </div>
            <div class="mb-4">
              <div class="text-xs text-gray-400 mb-2">Timeline Ruler</div>
              <div id="cutout-timeline" class="relative bg-[#1a1a1a] border border-[#2a2a2a] rounded p-2" style="height: 60px; overflow: visible;">
                <!-- Timecode (left) -->
                <div id="cutout-timecode" class="absolute top-0 bottom-0 flex items-center justify-center text-gray-300 select-none" style="left: 0; width: 128px; font-size: 22px; line-height: 1; letter-spacing: 0.5px; font-weight: 700; font-family: 'Courier New', Courier, Menlo, Monaco, monospace; font-variant-numeric: tabular-nums;">
                  00:00:00
                </div>
                <!-- Thin separator -->
                <div id="cutout-timecode-sep" class="absolute" style="top: 8px; bottom: 8px; left: 128px; width: 1px; background: #3a3a3a;"></div>
                <!-- Ruler Area (right) -->
                <div id="cutout-ruler-area" class="absolute top-0 bottom-0 right-0" style="left: 136px;">
                  <div id="cutout-timeline-track" class="relative h-full cursor-pointer"></div>
                  <div id="cutout-timeline-keys" class="absolute top-2 bottom-2 left-0 right-0 pointer-events-none"></div>
                  <div id="cutout-timeline-scrubber" class="absolute top-0 bottom-0 w-0.5 bg-[#6366f1] pointer-events-none" style="left: 0px;"></div>
                </div>
              </div>
            </div>
          </div>

        </div>
      </div>

      <!-- Removed duplicate old Cut Out Mode block -->

      <!-- Miniature Realtime Animation Preview -->
      <div id="mini-preview" class="mini-preview-player" title="Mini Preview">
        <canvas id="mini-preview-canvas"></canvas>
      </div>

      <!-- Quick Scroll to Timeline Button -->
      <div class="scroll-to-timeline-btn" onclick="scrollToTimeline()" title="Scroll to Timeline">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
          <path d="M12 5v14m0 0l-7-7m7 7l7-7" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
      </div>

      <!-- Added sidebar-right class for mobile responsiveness -->
      <!-- Right Sidebar - History & Info -->
      <div class="w-64 panel border-l border-[#2a2a2a] rounded-none flex flex-col gap-6 overflow-y-auto sidebar-right" id="right-sidebar">
        <div>
          <div id="layers-header" class="flex items-center justify-between mb-3">
            <h3 class="text-xs font-semibold text-gray-400 uppercase tracking-wider">Layers</h3>
            <button class="tool-btn text-xs py-1 px-2" onclick="addLayer()">
              <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="12" y1="5" x2="12" y2="19"/>
                <line x1="5" y1="12" x2="19" y2="12"/>
              </svg>
            </button>
          </div>
          <div class="mb-2">
            <button class="tool-btn text-xs py-1 px-2 w-full cutout-toggle enter-state" id="cutout-toggle-btn" onclick="toggleCutOutMode()">
              <span class="cutout-label mesh-text mesh-green">ENTER CUT OUT MODE</span>
              <svg class="door-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                <rect x="6" y="3" width="12" height="18" rx="1.5"></rect>
                <circle class="door-knob" cx="14.5" cy="12" r="1.2"></circle>
              </svg>
            </button>
          </div>
          
          <div id="layers-list" class="space-y-2 mb-3">
            <!-- Layers will be dynamically added here -->
          </div>
          <!-- Clips Section removed -->
        </div>

        <div class="mt-4">
          <h3 class="text-xs font-semibold uppercase tracking-wider mb-3" style="
            background: linear-gradient(90deg, #cfe6ff 0%, #93c5fd 20%, #60a5fa 45%, #2563eb 70%, #1e40af 100%);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 0 10px rgba(37, 99, 235, 0.22);
          ">Magic Effects</h3>
          <div id="effects-list" class="space-y-1">
            <div class="tool-btn w-full text-xs flex items-center justify-between locked-feature" style="padding:6px 8px" data-effect-id="heatHaze" data-locked="true" data-allow-preview="true" aria-disabled="true" title="Locked feature">
              <div class="flex items-center gap-2 effect-drag-handle" draggable="false">
                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><path d="M3 7c2-2 3-2 5 0s3 2 5 0 3-2 5 0"/><path d="M3 12c2-2 3-2 5 0s3 2 5 0 3-2 5 0"/><path d="M3 17c2-2 3-2 5 0s3 2 5 0 3-2 5 0"/></svg>
                <span>Heat Haze</span>
              </div>
              <span class="locked-badge" aria-hidden="true">Pro</span>
            </div>
            <div class="mt-1 hidden effect-settings-panel">
              <div class="grid grid-cols-2 gap-2 text-[10px] text-gray-300">
                <label class="col-span-2">Strength <input type="range" min="0" max="30" step="1" value="12" oninput="updateEffectSetting('heatHaze','scale',parseFloat(this.value))" class="w-full"></label>
                <label class="col-span-2">Speed <input type="range" min="0.2" max="3" step="0.1" value="1" oninput="updateEffectSetting('heatHaze','speed',parseFloat(this.value))" class="w-full"></label>
              </div>
            </div>

            <div class="tool-btn w-full text-xs flex items-center justify-between" style="padding:6px 8px" data-effect-id="smearFrames" title="Insert smear in-betweens along motion">
              <div class="flex items-center gap-2 effect-drag-handle" draggable="true">
                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 12c4-4 6-4 10 0s6 4 10 0"/></svg>
                <span>Smear Frames</span>
              </div>
            </div>
            <div class="tool-btn w-full text-xs flex items-center justify-between locked-feature" style="padding:6px 8px" data-effect-id="betweenFrames" data-locked="true" aria-disabled="true" title="Locked feature">
              <div class="flex items-center gap-2 effect-drag-handle" draggable="true">
                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 12h6"/><path d="M15 12h6"/><circle cx="12" cy="12" r="2"/></svg>
                <span>Between Frames</span>
              </div>
              <span class="locked-badge" aria-hidden="true">Pro</span>
            </div>

            <div class="tool-btn w-full text-xs flex items-center justify-between" style="padding:6px 8px" data-effect-id="echoTrail" title="Add faded trails from previous frames">
              <div class="flex items-center gap-2 effect-drag-handle" draggable="true">
                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 12h8"/><path d="M2 12h2" opacity="0.5"/><path d="M12 12h2" opacity="0.5"/></svg>
                <span>Echo Trail</span>
              </div>
            </div>

            <div class="tool-btn w-full text-xs flex items-center justify-between locked-feature" style="padding:6px 8px" data-effect-id="bounceEase" data-locked="true" aria-disabled="true" title="Locked feature">
              <div class="flex items-center gap-2 effect-drag-handle" draggable="true">
                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 17c3-8 6-8 9 0 3-8 6-8 9 0"/></svg>
                <span>Bounce Ease</span>
              </div>
              <span class="locked-badge" aria-hidden="true">Pro</span>
            </div>

            <div class="tool-btn w-full text-xs flex items-center justify-between" style="padding:6px 8px" data-effect-id="squashStretch" title="Add squash & stretch on motion">
              <div class="flex items-center gap-2 effect-drag-handle" draggable="true">
                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="5" y="8" width="6" height="8" rx="2"/><rect x="11" y="6" width="8" height="12" rx="3"/></svg>
                <span>Squash &amp; Stretch</span>
              </div>
            </div>

            <div class="tool-btn w-full text-xs flex items-center justify-between" style="padding:6px 8px" data-effect-id="frameBlend" title="Insert blended in-between frames">
              <div class="flex items-center gap-2 effect-drag-handle" draggable="true">
                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="9" cy="12" r="4"/><circle cx="13" cy="12" r="4" opacity="0.6"/></svg>
                <span>Frame Blend</span>
              </div>
            </div>
          </div>
          <div class="text-xs text-gray-500 mt-2">Drag onto the Animation Preview.</div>
        </div>

      <!-- Magic Tools (experimental) -->
      <div class="mt-4">
        <h3 class="text-xs font-semibold uppercase tracking-wider mb-3" style="
          background: linear-gradient(90deg, #d1fae5 0%, #6ee7b7 25%, #34d399 50%, #10b981 75%, #059669 100%);
          -webkit-background-clip: text;
          background-clip: text;
          color: transparent;
          text-shadow: 0 0 10px rgba(16, 185, 129, 0.22);
        ">Magic Tools</h3>

        <div id="magic-tools-list" class="space-y-1">
          <button id="bones-btn" class="tool-btn w-full text-xs flex items-center justify-between locked-feature" style="padding:6px 8px; min-height:28px" type="button" disabled aria-disabled="true" data-locked="true" title="Locked feature">
            <div class="flex items-center gap-2">
              <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="7" cy="12" r="3"/>
                <circle cx="17" cy="12" r="3"/>
                <path d="M9.5 12h5"/>
              </svg>
              <span>Animation Bones</span>
            </div>
            <span class="locked-badge" aria-hidden="true">Pro</span>
          </button>
          <div class="relative">
            <div id="detail-btn" class="tool-btn w-full text-xs flex items-center justify-between" style="padding:6px 8px; min-height:28px" title="Use a lasso to apply a detail style">
              <div class="flex items-center gap-2" onclick="setTool('detail')">
                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M4 12h16"/>
                  <path d="M8 6l8 12"/>
                  <path d="M8 18l8-12"/>
                </svg>
                <span>Add Detail</span>
              </div>
              <button class="tool-btn effect-settings-btn p-1" aria-label="Detail options" onclick="toggleDetailMenu(event)">
                <svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor">
                  <path d="M6 9l6 6 6-6"/>
                </svg>
              </button>
            </div>
            <div id="detail-menu" class="absolute top-full right-0 bg-[#1a1a1a] border border-[#2a2a2a] rounded mt-1 shadow-lg z-50 hidden">
              <div class="p-2">
                <div class="text-xs text-gray-400 mb-2">Detail Style</div>
                <div class="space-y-1">
                  <button class="detail-option w-full text-left px-3 py-2 text-sm hover:bg-[#2a2a2a] rounded flex items-center gap-2" data-style="slender" onclick="selectDetailStyle('slender')">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <path d="M12 3v18"/>
                      <circle cx="12" cy="7" r="2"/>
                    </svg>
                    Slender
                  </button>
                  <button class="detail-option w-full text-left px-3 py-2 text-sm hover:bg-[#2a2a2a] rounded flex items-center gap-2" data-style="comic" onclick="selectDetailStyle('comic')">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <path d="M4 5h16v10H9l-5 4V5z"/>
                    </svg>
                    Comic
                  </button>
                  <button class="detail-option w-full text-left px-3 py-2 text-sm hover:bg-[#2a2a2a] rounded flex items-center gap-2" data-style="sketch" onclick="selectDetailStyle('sketch')">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <path d="M3 21l6-2 11-11a2 2 0 1 0-3-3L6 16l-3 5z"/>
                    </svg>
                    Sketch
                  </button>
                  <button class="detail-option w-full text-left px-3 py-2 text-sm hover:bg-[#2a2a2a] rounded flex items-center gap-2" data-style="oil" onclick="selectDetailStyle('oil')">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <path d="M6 6h12v12H6z"/>
                      <path d="M8 10c3 2 5 2 8 0"/>
                    </svg>
                    Oil Paint
                  </button>
                </div>
              </div>
            </div>
          </div>
          <button id="select-lasso-btn" class="tool-btn w-full text-xs flex items-center justify-between" style="padding:6px 8px; min-height:28px" onclick="setTool('select-lasso')" title="Select a region with a lasso for moving/scaling">
            <div class="flex items-center gap-2">
              <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="3"/>
                <path d="M12 2v4M12 18v4M4.93 4.93l2.83 2.83M16.24 16.24l2.83 2.83M2 12h4M18 12h4M4.93 19.07l2.83-2.83M16.24 7.76l2.83-2.83"/>
              </svg>
              <span>Select Lasso</span>
            </div>
          </button>
          <button id="eraser-lasso-btn" class="tool-btn w-full text-xs flex items-center justify-between" style="padding:6px 8px; min-height:28px" onclick="setTool('lasso')" title="Erase inside a lasso selection">
            <div class="flex items-center gap-2">
              <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M3 3h18v18H3z"/>
                <path d="M8 8l8 8M16 8l-8 8"/>
              </svg>
              <span>Eraser Lasso</span>
            </div>
          </button>
          <button id="extend-lasso-btn" class="tool-btn w-full text-xs flex items-center justify-between" style="padding:6px 8px; min-height:28px" onclick="setTool('extend-lasso')" title="Extend selected image area to fill the lasso">
            <div class="flex items-center gap-2">
              <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="3" y="3" width="7" height="7"/>
                <rect x="14" y="3" width="7" height="7"/>
                <rect x="3" y="14" width="7" height="7"/>
                <rect x="14" y="14" width="7" height="7"/>
              </svg>
              <span>Extend Lasso</span>
            </div>
          </button>
        </div>
        <div class="text-[10px] text-gray-500 mt-2">Draw a lasso, release to apply.</div>
      </div>

      <!-- Between Frames moved into Magic Effects -->

        <!-- Magic Timeline (timing/easing effects) -->
        <div class="mt-4">
          <h3 class="text-xs font-semibold uppercase tracking-wider mb-3" style="
            background: radial-gradient(120% 180% at 10% 0%, #c7d2fe 0%, rgba(0,0,0,0) 40%),
                        radial-gradient(140% 160% at 90% 100%, #818cf8 0%, rgba(0,0,0,0) 45%),
                        linear-gradient(90deg, #eef2ff 0%, #a5b4fc 25%, #818cf8 50%, #6366f1 75%, #4338ca 100%);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 0 10px rgba(99, 102, 241, 0.22);
          ">Magic Timeline</h3>
          <div id="timeline-effects-list" class="space-y-1">
            <div class="tool-btn w-full text-xs flex items-center justify-between" style="padding:6px 8px" data-effect-id="timeline-auto-velocity">
              <div class="flex items-center gap-2 effect-drag-handle" draggable="true">
                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 12c4-4 10 4 18-4"/></svg>
                <span>Autoâ€‘pace by Motion</span>
              </div>
            </div>
            <div class="tool-btn w-full text-xs flex items-center justify-between" style="padding:6px 8px" data-effect-id="timeline-keypose-holds">
              <div class="flex items-center gap-2 effect-drag-handle" draggable="true">
                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 12h6M10 12l6-4v8zM4 12h0"/></svg>
                <span>Keypose Holds</span>
              </div>
            </div>
            <div class="tool-btn w-full text-xs flex items-center justify-between" style="padding:6px 8px" data-effect-id="timeline-ease-in">
              <div class="flex items-center gap-2 effect-drag-handle" draggable="true">
                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 19c4-10 8-10 18-10"/></svg>
                <span>Ease In</span>
              </div>
            </div>
            <div class="tool-btn w-full text-xs flex items-center justify-between" style="padding:6px 8px" data-effect-id="timeline-ease-out">
              <div class="flex items-center gap-2 effect-drag-handle" draggable="true">
                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 9c10 0 14 0 18 10"/></svg>
                <span>Ease Out</span>
              </div>
            </div>
            <div class="tool-btn w-full text-xs flex items-center justify-between" style="padding:6px 8px" data-effect-id="timeline-ease-inout">
              <div class="flex items-center gap-2 effect-drag-handle" draggable="true">
                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 12c4-6 8-6 18 0"/></svg>
                <span>Ease In-Out</span>
              </div>
            </div>
            <div class="tool-btn w-full text-xs flex items-center justify-between" style="padding:6px 8px" data-effect-id="timeline-linear">
              <div class="flex items-center gap-2 effect-drag-handle" draggable="true">
                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 12h18"/></svg>
                <span>Linear (Reset)</span>
              </div>
            </div>
            <div class="tool-btn w-full text-xs flex items-center justify-between" style="padding:6px 8px" data-effect-id="timeline-slow-down">
              <div class="flex items-center gap-2 effect-drag-handle" draggable="true">
                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 12h6M10 12l6-4v8z"/></svg>
                <span>Slow Down</span>
              </div>
            </div>
            <div class="tool-btn w-full text-xs flex items-center justify-between" style="padding:6px 8px" data-effect-id="timeline-acceleration">
              <div class="flex items-center gap-2 effect-drag-handle" draggable="true">
                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 16c6-8 10-8 16 0"/></svg>
                <span>Acceleration</span>
              </div>
            </div>
          </div>
          <div class="text-xs text-gray-500 mt-2">Drag onto the Animation Preview.</div>
        </div>

        <div class="h-px bg-[#2a2a2a]"></div>

        

        <div class="h-px bg-[#2a2a2a]"></div>

        <div>
          <h3 class="text-xs font-semibold text-gray-400 uppercase tracking-wider mb-3">Keyboard Shortcuts</h3>
          <div class="space-y-2 text-xs">
            <div class="flex justify-between">
              <span class="text-gray-400">Brush</span>
              <span class="kbd">B</span>
            </div>
            <div class="flex justify-between">
              <span class="text-gray-400">Pencil</span>
              <span class="kbd">P</span>
            </div>
            <div class="flex justify-between">
              <span class="text-gray-400">Eraser</span>
              <span class="kbd">E</span>
            </div>
            <div class="flex justify-between">
              <span class="text-gray-400">Fill</span>
              <span class="kbd">F</span>
            </div>
            <div class="flex justify-between">
              <span class="text-gray-400">Eraser Lasso</span>
              <span class="kbd">L</span>
            </div>
            <div class="flex justify-between">
              <span class="text-gray-400">Next Frame</span>
              <span class="kbd">â†’</span>
            </div>
            <div class="flex justify-between">
              <span class="text-gray-400">Prev Frame</span>
              <span class="kbd">â†</span>
            </div>
            <div class="flex justify-between">
              <span class="text-gray-400">Play/Pause</span>
              <span class="kbd">Space</span>
            </div>
            <div class="flex justify-between">
              <span class="text-gray-400">Copy Frame</span>
              <span class="kbd">Ctrl+C</span>
            </div>
            <div class="flex justify-between">
              <span class="text-gray-400">Paste Frame</span>
              <span class="kbd">Ctrl+V</span>
            </div>
          </div>
        </div>

        
      </div>
    </div>


    <!-- Status Bar -->
    <div class="status-bar flex items-center justify-between">
      <div class="flex items-center gap-4">
        <span id="status-text">Ready</span>
      </div>
      <div>Frame Studio v1.0</div>
    </div>
  </div>

  <script>
    const canvases = [];
    const contexts = [];
    const onionCanvases = [];
    const onionContexts = [];
    const thumbCanvases = [];
    const thumbContexts = [];
    // Per-frame non-exported guides overlay for animation paths
    const guideCanvases = [];
    const guideContexts = [];
    const history = [];
    const redoStack = [];
    
    let frameLayers = Array(6).fill(null).map(() => []);
    let currentLayer = 0;
    // Clips removed
    
    // Frame duration system - each frame has a duration in "time units"
    let frameDurations = [1, 1, 1, 1, 1, 1]; // Default: each frame shows for 1 time unit
    let currentFrame = 0;
    
    // Copy/paste functionality
    let copiedFrameData = null;
    let copiedFrameIndex = -1;
    let currentTool = 'brush';
    let currentBrushType = 'basic';
    let currentColor = '#ffffff';
    let brushSize = 7;
    let brushOpacity = 1;
    let brushStrokeAge = 0; // increases as a stroke continues (used for dynamic brushes)
    let isDrawing = false;
    let lastX = 0;
    let lastY = 0;
    let animationInterval = null;
    let animationFrame = 0;
    let fps = 10;
    let loopCount = 1;
    let onionSkinEnabled = true;
    let onionOpacity = 0.3;
    let lassoPoints = [];
    let isLassoActive = false;
    // Select-tool freeform selection (lasso-like)
    let selectLassoPoints = [];
    let isSelectLassoActive = false;
    let selectLassoEnabled = false;
    // Bones tool state
    let boneLassoPoints = [];
    let isBoneLassoActive = false;
    let bones = []; // {frameIndex, layerIndex, imageObj, startX, startY, endX, endY}
    let bonesOverlayCanvas = null;
    let bonesOverlayCtx = null;
    let isDraggingBoneHandle = false;
    let boneDrag = null; // {boneIndex, handle: 'start'|'end'}
    // Throttle bones overlay redraws to once per animation frame
    let bonesOverlayRafScheduled = false;
    // Selected bone for delete operations
    let selectedBoneIndex = -1;
    // Magic lasso tools state (inbetween, detail)
    let magicLassoPoints = [];
    let isMagicLassoActive = false;
    let magicLassoMode = null; // 'inbetween' | 'detail'
   let detailStyle = 'slender';
    let isPreviewingLayer = false;
    let previewLayerIndex = -1;

    // Cut Out Mode state (separate mode)
    let isCutOutMode = false;
    let cutoutTransformPlaceholder = null;
    let cutoutPictureBoardPlaceholder = null;
    let cutoutPhoneMediaQuery = (typeof window !== 'undefined' && window.matchMedia) ? window.matchMedia('(max-width: 768px)') : null;
    let cutoutCanvas = null;
    let cutoutCtx = null;
    let cutoutFillCanvas = null;
    let cutoutFillCtx = null;
    let cutoutTimelineEl = null;
    let cutoutScrubberEl = null;
    let cutoutKeys = []; // [{ time: number }] legacy markers
    // Property keyframes for cutout selection overlay
    let cutoutPropertyKeys = {
      position: [], // { time, x, y }
      zoom: [],     // { time, sx, sy }
      rotation: [], // { time, deg }
      opacity: []   // { time, value }
    };
    // Drag state for property key diamonds on the timeline
    let isDraggingPropKey = false;
    let dragPropKey = { group: [], startMouseX: 0, startTime: 0, trackLeft: 0, trackWidth: 0 };
    let cutoutDuration = 3.0; // seconds
    let cutoutIsPlaying = false;
    let cutoutCurrentTime = 0;
    let cutoutRAF = null;
    let cutoutPlayDirection = 1; // +1 forward, -1 reverse
    // Cut Out Bones tool state
    let cutoutBoneLassoPoints = [];
    let cutoutIsBoneLassoActive = false;
    let cutoutBones = []; // {clipIndex, objectRef, startX, startY, endX, endY, pinnedLocalX, pinnedLocalY, ...}
    // Require explicit arming to draw new bones lassos; allows moving bones without accidental new lasso
    let cutoutBonesDrawArmed = false;
    // Storage for original pivot before bone mode (per-object, keyed by object id)
    let preBonePivotStorage = {}; // { [objectId]: { pivotLocalX, pivotLocalY } }
    let cutoutBonesOverlayCanvas = null;
    let cutoutBonesOverlayCtx = null;
    let cutoutIsDraggingBoneHandle = false;
    let cutoutBoneDrag = null; // {boneIndex, handle: 'start'|'end'|'rotation'}
    // State for bone rotation via the dedicated rotation handle
    let cutoutIsRotatingBone = false;
    let cutoutBoneRotationData = null; // {boneIndex, startAngle, initialObjRotation, initialBoneAngle, initialParentRotation, initialParentBoneStartX/Y, initialParentBoneEndX/Y}
    // Throttle Cut Out bones overlay redraws to once per animation frame
    let cutoutBonesOverlayRafScheduled = false;
    // State for dragging objects in bones mode (when not on a bone node)
    let cutoutBonesModeObjDrag = null; // { boneIndex, offsetX, offsetY }
    // Selected Cut Out bone for delete operations
    let cutoutSelectedBoneIndex = -1;
    let cutoutStartTimeAtPlay = 0;
    let isCutoutDragging = false;
    let cutoutPlayStartTs = 0;
    // Cutout drawing state and timeline clips
    let isCutoutDrawing = false;
    let lastCutoutX = 0;
    let lastCutoutY = 0;
    let cutoutClips = []; // [{ start:number, end:number, dataUrl:string }]
    // Cutout clip resizing state
    let isResizingCutoutClip = false;
    let resizeCutoutClipIndex = -1;
    let resizeCutoutClipSide = ''; // 'left' | 'right'
    let resizeCutoutStartX = 0;
    let resizeCutoutOrigStart = 0;
    let resizeCutoutOrigEnd = 0;
    let selectedCutoutClipIndex = -1;
    // Drag move for whole clip
    let isDraggingCutoutClip = false;
    let dragCutoutClipIndex = -1;
    let dragCutoutStartMouseX = 0;
    let dragCutoutOrigStart = 0;
    let dragCutoutOrigEnd = 0;
    // Current drawing target clip index
    let cutoutDrawingClipIndex = -1;

    // Gentle reusable fade animations for mode transitions
    const MODE_FADE_IN_MS = 180;
    const MODE_FADE_OUT_MS = 160;
    function fadeInElement(el) {
      if (!el) return;
      el.style.willChange = 'opacity, transform';
      el.style.opacity = '0';
      el.style.transform = 'translateY(4px)';
      el.style.display = '';
      el.style.transition = `opacity ${MODE_FADE_IN_MS}ms ease, transform ${MODE_FADE_IN_MS}ms ease`;
      requestAnimationFrame(() => {
        el.style.opacity = '1';
        el.style.transform = 'translateY(0)';
      });
      // Clean up transition after animation completes
      setTimeout(() => {
        el.style.willChange = '';
        el.style.transition = '';
        el.style.transform = '';
        el.style.opacity = '';
      }, MODE_FADE_IN_MS + 30);
    }
    function fadeOutElement(el, after) {
      if (!el) { if (after) after(); return; }
      el.style.willChange = 'opacity, transform';
      el.style.opacity = '1';
      el.style.transform = 'translateY(0)';
      el.style.transition = `opacity ${MODE_FADE_OUT_MS}ms ease, transform ${MODE_FADE_OUT_MS}ms ease`;
      requestAnimationFrame(() => {
        el.style.opacity = '0';
        el.style.transform = 'translateY(4px)';
      });
      setTimeout(() => {
        el.style.display = 'none';
        el.style.willChange = '';
        el.style.transition = '';
        el.style.transform = '';
        el.style.opacity = '';
        if (after) after();
      }, MODE_FADE_OUT_MS + 30);
    }

    function syncCutoutSizing() {
      const cutoutContainer = document.getElementById('cutout-canvas-container');
      const cutoutCanvasEl = document.getElementById('cutout-canvas');
      if (!cutoutContainer || !cutoutCanvasEl) return;
      ensureZoomCenterOverlay(cutoutContainer);
      // Match aspect ratio to current viewport like regular frames/preview
      const isPhone = currentViewport === 'phone';
      const ar = isPhone ? '9 / 16' : '16 / 9';
      cutoutContainer.style.setProperty('--canvas-aspect-ratio', ar);
      // Match width to the normal preview container if available
      const previewContainer = document.getElementById('preview-container');
      const frameContainer0 = document.getElementById('frame-container-0');
      // Determine reference width from a regular drawing frame (preferred)
      let refWidthPx = 300;
      if (frameContainer0) {
        const rect = frameContainer0.getBoundingClientRect();
        if (rect && rect.width) refWidthPx = rect.width;
      } else if (previewContainer) {
        // Fallback to preview max-width numeric value if available
        const cs = window.getComputedStyle(previewContainer);
        const mw = cs.maxWidth || previewContainer.style.maxWidth;
        if (mw && mw.endsWith('px')) refWidthPx = parseFloat(mw);
      }
      // Apply requested scaling: +20% in phone, +100% (2x) in desktop (as baseline)
      const scale = isPhone ? 1.2 : 2.0;
      const scaledWidth = Math.max(100, Math.round(refWidthPx * scale));
      // In desktop, reserve space for the Transform Tools panel so it doesn't overlap the canvas
      if (!isPhone) {
        const outerPanel = document.querySelector('#cutout-mode-container .panel');
        const toolsPanel = document.getElementById('cutout-transform-panel');
        const boardPanel = document.getElementById('cutout-picture-board');
        const outerWidth = outerPanel ? outerPanel.clientWidth : 0;
        const toolsWidth = toolsPanel ? toolsPanel.clientWidth : 0;
        const reserveRight = Math.max(0, toolsWidth + 32); // right padding
        const reserveLeft = boardPanel ? (boardPanel.clientWidth + 16) : 0;
        if (outerWidth > 0) {
          const available = Math.max(480, outerWidth - reserveRight - reserveLeft - 24);
          // Expand the canvas to use the available width more on desktop
          const desired = Math.min(available, Math.max(scaledWidth, Math.round(outerWidth * 0.85)));
          cutoutContainer.style.maxWidth = desired + 'px';
        } else {
          cutoutContainer.style.maxWidth = scaledWidth + 'px';
        }
        // Ensure panel background visually includes the tools area
        if (outerPanel) {
          outerPanel.style.paddingRight = reserveRight + 'px';
          outerPanel.style.paddingLeft = reserveLeft + 'px';
        }
        // Center the canvas within the panel
        cutoutContainer.style.marginLeft = 'auto';
        cutoutContainer.style.marginRight = 'auto';
      } else {
        cutoutContainer.style.maxWidth = scaledWidth + 'px';
        cutoutContainer.style.marginLeft = '';
        cutoutContainer.style.marginRight = '';
        const outerPanel = document.querySelector('#cutout-mode-container .panel');
        if (outerPanel) { outerPanel.style.paddingRight = ''; outerPanel.style.paddingLeft = ''; }
        // Restore phone-side panel sizes
        const boardPanel = document.getElementById('cutout-picture-board');
        const toolsPanel = document.getElementById('cutout-transform-panel');
      }
      // Ensure the backing canvas pixels match viewport's target size
      const target = typeof getTargetCanvasSizeForViewport === 'function'
        ? getTargetCanvasSizeForViewport(currentViewport)
        : (isPhone ? { width: 1080, height: 1920 } : { width: 1920, height: 1080 });
      let resized = false;
      if (cutoutCanvasEl.width !== target.width || cutoutCanvasEl.height !== target.height) {
        cutoutCanvasEl.width = target.width;
        cutoutCanvasEl.height = target.height;
        resized = true;
      }
      // After any sizing change, re-render preview so the checkerboard/background is restored
      if (resized && typeof renderCutoutPreviewForTime === 'function') {
        try { renderCutoutPreviewForTime(); } catch (_e) {}
      }
      refreshCutoutSliderUi();
    }

    // Ensure all clip canvases match cutoutCanvas dimensions, rescaling content if needed
    function syncAllClipCanvasDimensions() {
      if (!Array.isArray(cutoutClips) || cutoutClips.length === 0) return;
      // Determine target dimensions
      let targetW = 1920, targetH = 1080;
      if (cutoutCanvas && cutoutCanvas.width > 0 && cutoutCanvas.height > 0) {
        targetW = cutoutCanvas.width;
        targetH = cutoutCanvas.height;
      } else if (typeof getTargetCanvasSizeForViewport === 'function' && typeof currentViewport !== 'undefined') {
        const target = getTargetCanvasSizeForViewport(currentViewport);
        targetW = target.width || 1920;
        targetH = target.height || 1080;
      } else if (canvases && canvases[0] && canvases[0].width > 0 && canvases[0].height > 0) {
        targetW = canvases[0].width;
        targetH = canvases[0].height;
      }
      for (const clip of cutoutClips) {
        if (!clip || !clip.canvas) continue;
        const oldW = clip.canvas.width;
        const oldH = clip.canvas.height;
        // Skip if already correct size
        if (oldW === targetW && oldH === targetH) continue;
        // Skip if canvas has no content and wrong size (just resize)
        if (oldW === 0 || oldH === 0) {
          clip.canvas.width = targetW;
          clip.canvas.height = targetH;
          continue;
        }
        // Rescale existing content to new dimensions
        try {
          // Save current content
          const tempCanvas = document.createElement('canvas');
          tempCanvas.width = oldW;
          tempCanvas.height = oldH;
          const tempCtx = tempCanvas.getContext('2d');
          tempCtx.drawImage(clip.canvas, 0, 0);
          // Resize clip canvas
          clip.canvas.width = targetW;
          clip.canvas.height = targetH;
          // Draw old content scaled to new size
          clip.ctx.clearRect(0, 0, targetW, targetH);
          clip.ctx.drawImage(tempCanvas, 0, 0, oldW, oldH, 0, 0, targetW, targetH);
        } catch (_e) {
          // If rescaling fails, just resize the canvas
          clip.canvas.width = targetW;
          clip.canvas.height = targetH;
        }
      }
    }

    function ensureCutoutMobilePlaceholders() {
      const transformPanel = document.getElementById('cutout-transform-panel');
      if (transformPanel && !cutoutTransformPlaceholder && transformPanel.parentElement) {
        cutoutTransformPlaceholder = document.createElement('div');
        cutoutTransformPlaceholder.id = 'cutout-transform-placeholder';
        cutoutTransformPlaceholder.style.display = 'none';
        if (!transformPanel.dataset.originalStyle) {
          transformPanel.dataset.originalStyle = transformPanel.getAttribute('style') || '';
        }
        transformPanel.parentElement.insertBefore(cutoutTransformPlaceholder, transformPanel);
      }
      const pictureBoard = document.getElementById('cutout-picture-board');
      if (pictureBoard && !cutoutPictureBoardPlaceholder && pictureBoard.parentElement) {
        cutoutPictureBoardPlaceholder = document.createElement('div');
        cutoutPictureBoardPlaceholder.id = 'cutout-picture-board-placeholder';
        cutoutPictureBoardPlaceholder.style.display = 'none';
        if (!pictureBoard.dataset.originalStyle) {
          pictureBoard.dataset.originalStyle = pictureBoard.getAttribute('style') || '';
        }
        pictureBoard.parentElement.insertBefore(cutoutPictureBoardPlaceholder, pictureBoard);
      }
    }

    function moveCutoutPanelsToMobile() {
      if (!isCutOutMode || !isPhoneViewport()) return;
      ensureCutoutMobilePlaceholders();
      const rightHost = document.getElementById('cutout-mobile-right-body');
      const leftHost = document.getElementById('cutout-mobile-left-body');
      const transformPanel = document.getElementById('cutout-transform-panel');
      if (transformPanel && rightHost && transformPanel.parentElement !== rightHost) {
        transformPanel.style.position = 'relative';
        transformPanel.style.right = '0';
        transformPanel.style.top = '0';
        transformPanel.style.alignItems = 'stretch';
        transformPanel.style.width = '100%';
        rightHost.appendChild(transformPanel);
      }
      const pictureBoard = document.getElementById('cutout-picture-board');
      if (pictureBoard && leftHost && pictureBoard.parentElement !== leftHost) {
        pictureBoard.style.position = 'relative';
        pictureBoard.style.left = '0';
        pictureBoard.style.top = '0';
        pictureBoard.style.width = '100%';
        pictureBoard.style.zIndex = '1';
        leftHost.appendChild(pictureBoard);
      }
      document.body.classList.add('cutout-mobile-mode');
    }

    function restoreCutoutPanelsFromMobile() {
      const rightHost = document.getElementById('cutout-mobile-right-body');
      const leftHost = document.getElementById('cutout-mobile-left-body');
      const transformPanel = document.getElementById('cutout-transform-panel');
      if (cutoutTransformPlaceholder && transformPanel && transformPanel.parentElement === rightHost) {
        cutoutTransformPlaceholder.parentElement.insertBefore(
          transformPanel,
          cutoutTransformPlaceholder.nextSibling || cutoutTransformPlaceholder
        );
        if (typeof transformPanel.dataset.originalStyle !== 'undefined') {
          transformPanel.setAttribute('style', transformPanel.dataset.originalStyle);
        }
        positionCutoutTransformPanel();
      }
      const pictureBoard = document.getElementById('cutout-picture-board');
      if (cutoutPictureBoardPlaceholder && pictureBoard && pictureBoard.parentElement === leftHost) {
        cutoutPictureBoardPlaceholder.parentElement.insertBefore(
          pictureBoard,
          cutoutPictureBoardPlaceholder.nextSibling || cutoutPictureBoardPlaceholder
        );
        if (typeof pictureBoard.dataset.originalStyle !== 'undefined') {
          pictureBoard.setAttribute('style', pictureBoard.dataset.originalStyle);
        }
      }
      document.body.classList.remove('cutout-mobile-mode');
      closeCutoutMobilePanels(true);
    }

    function syncCutoutMobileUi() {
      const active = isCutOutMode && isPhoneViewport();
      const toggles = document.querySelectorAll('.cutout-mobile-toggle');
      toggles.forEach((btn) => {
        btn.style.display = active ? 'flex' : 'none';
      });
      if (active) moveCutoutPanelsToMobile();
      else restoreCutoutPanelsFromMobile();
      refreshCutoutSliderUi();
    }

    // Attach double-tap editing on phone to numeric readouts to surface keyboard
    function attachCutoutNumericInput(el, label, applyValue) {
      if (!el) return;
      el.addEventListener('dblclick', () => {
        if (!isPhoneViewport()) return;
        const current = (el.textContent || '').trim();
        const next = prompt(`${label}`, current);
        if (next === null) return;
        const val = parseFloat(next);
        if (!Number.isFinite(val)) return;
        applyValue(val);
      });
      // On touch devices, double-tap should map to dblclick; no extra handler needed
    }

    function getPointerClientX(e) {
      if (!e) return null;
      if (typeof e.clientX === 'number') return e.clientX;
      if (e.touches && e.touches[0]) return e.touches[0].clientX;
      if (e.changedTouches && e.changedTouches[0]) return e.changedTouches[0].clientX;
      return null;
    }

    function toggleCutOutMode() {
      const nextIsCutOut = !isCutOutMode;
      const grid = document.getElementById('frame-mode-canvas-grid');
      const preview = document.getElementById('frame-mode-preview');
      const timeline = document.getElementById('frame-mode-timeline');
      const cutout = document.getElementById('cutout-mode-container');
      const cutoutTimelineContainer = document.getElementById('cutout-mode-timeline');
      if (nextIsCutOut) {
        // Hide regular sections instantly to avoid overlap, then fade in cutout
        if (grid) grid.style.display = 'none';
        if (preview) preview.style.display = 'none';
        if (timeline) timeline.style.display = 'none';
        if (cutout) fadeInElement(cutout);
        if (cutoutTimelineContainer) fadeInElement(cutoutTimelineContainer);
      } else {
        // Fade out cutout, then reveal regular sections with a fade in
        fadeOutElement(cutout, () => {
          if (grid) fadeInElement(grid);
          if (preview) fadeInElement(preview);
          if (timeline) fadeInElement(timeline);
        });
        if (cutoutTimelineContainer) fadeOutElement(cutoutTimelineContainer);
      }
      isCutOutMode = nextIsCutOut;
    setCutOutToggleButtonUi(isCutOutMode);
    applyRightSidebarCutoutVisibility(isCutOutMode);
      if (isCutOutMode) initCutOutMode();
      else teardownCutOutMode();
      syncCutoutMobileUi();
    }

  function setCutOutToggleButtonUi(active) {
    const btn = document.getElementById('cutout-toggle-btn');
    if (!btn) return;
    btn.classList.toggle('exit-state', !!active);
    btn.classList.toggle('enter-state', !active);
    btn.classList.add('cutout-toggle');
    const labelEl = btn.querySelector('.cutout-label');
    if (labelEl) {
      // When Cut Out is active, offer to enter frame mode; otherwise offer to exit back to Cut Out
      labelEl.textContent = active ? 'ENTER TO FRAME MODE' : 'EXIT TO CUT OUT MODE';
      labelEl.classList.remove('mesh-green','mesh-red');
      labelEl.classList.add(active ? 'mesh-red' : 'mesh-green', 'mesh-text');
    }
  }

  function applyRightSidebarCutoutVisibility(cutoutActive) {
    const header = document.getElementById('layers-header');
    const list = document.getElementById('layers-list');
    if (header) {
      header.classList.add('fade-hide');
      if (cutoutActive) {
        header.classList.add('fade-hidden');   // fades both text and plus button together
        header.style.pointerEvents = 'none';
      } else {
        header.classList.remove('fade-hidden');
        header.style.pointerEvents = '';
      }
    }
    if (list) {
      list.style.display = cutoutActive ? 'none' : '';
    }
  }

    function initCutOutMode() {
      // Default active layer to the first layer when entering Cut Out mode
      cutoutActiveLayerIndex = 0;
      // Repurpose the scroll button as a play/pause toggle in Cut Out mode
      setScrollButtonModeCutout(true);
      if (!cutoutCanvas) {
        cutoutCanvas = document.getElementById('cutout-canvas');
        if (cutoutCanvas) {
          cutoutCtx = cutoutCanvas.getContext('2d', { willReadFrequently: true });
        }
      }
      // Listen on the ruler area only
      cutoutTimelineEl = document.getElementById('cutout-ruler-area');
      cutoutScrubberEl = document.getElementById('cutout-timeline-scrubber');
      if (cutoutTimelineEl && !cutoutTimelineEl.dataset.cutoutRulerBound) {
        cutoutTimelineEl.addEventListener('mousedown', cutoutBeginDrag);
        // Accept Magic Effects drops onto ruler area to assign to clips
        cutoutTimelineEl.addEventListener('dragover', (e) => { e.preventDefault(); });
        cutoutTimelineEl.addEventListener('drop', handleCutoutEffectDrop);
        // Also handle transitions dropped between frames
        cutoutTimelineEl.addEventListener('drop', handleCutoutTransitionDrop);
        cutoutTimelineEl.dataset.cutoutRulerBound = '1';
      }
      // Also accept drops on the clips lane
      const cutoutClipsLane = document.getElementById('cutout-timeline-clips');
      if (cutoutClipsLane && !cutoutClipsLane.dataset.cutoutClipsBound) {
        cutoutClipsLane.addEventListener('dragover', (e) => { e.preventDefault(); });
        cutoutClipsLane.addEventListener('drop', handleCutoutEffectDrop);
        cutoutClipsLane.addEventListener('drop', handleCutoutTransitionDrop);
        cutoutClipsLane.dataset.cutoutClipsBound = '1';
      }
      // Delete selected clip on Delete/Backspace
      document.addEventListener('keydown', onCutoutKeyDown);
      // Transition delete hotkey
      document.addEventListener('keydown', onCutoutTransitionsKeyDown);
      // Enable drawing on cutout canvas for brush/pencil/eraser and magic tools
      if (cutoutCanvas) {
        cutoutCanvas.addEventListener('mousedown', cutoutStartDraw);
        cutoutCanvas.addEventListener('mousemove', cutoutDraw);
        window.addEventListener('mouseup', cutoutStopDraw);
        cutoutCanvas.addEventListener('mouseleave', cutoutStopDraw);
        // Wheel zoom in/out on cutout canvas
        cutoutCanvas.addEventListener('wheel', (e) => {
          e.preventDefault();
          cutoutHandleWheelZoom(e);
        }, { passive: false });
        // Accept drops from Picture Board (bind once)
        const container = document.getElementById('cutout-canvas-container');
        if (container && !container.dataset.cutoutDropBound) {
          container.addEventListener('dragover', (e) => { e.preventDefault(); e.dataTransfer.dropEffect = 'copy'; });
          container.addEventListener('drop', (e) => {
            e.preventDefault();
            const src = e.dataTransfer.getData('text/plain') || e.dataTransfer.getData('text/uri-list');
            if (src) {
              const coords = cutoutCanvasCoords(e);
              cutoutPlaceImageFromSrcAt(src, coords.x, coords.y);
            }
          });
          container.dataset.cutoutDropBound = '1';
        }
      }
      // If there are existing Cut Out bones, ensure their overlay is present
      try {
        if (Array.isArray(cutoutBones) && cutoutBones.length) {
          ensureCutoutBonesOverlay();
          drawCutoutBonesOverlay();
        }
      } catch (_e) {}
      // Position bar drag listeners
      const posXEl = document.getElementById('cutout-pos-x');
      const posYEl = document.getElementById('cutout-pos-y');
      if (posXEl) posXEl.addEventListener('mousedown', (e) => beginPosDrag(e, 'x'));
      if (posYEl) posYEl.addEventListener('mousedown', (e) => beginPosDrag(e, 'y'));
      attachCutoutNumericInput(posXEl, 'Position X', (val) => {
        if (!cutoutSelectedObject) return;
        cutoutSelectedObject.x = val;
        updateCutoutPositionDisplay(cutoutSelectedObject.x, cutoutSelectedObject.y);
        cutoutRenderSelectionOverlay();
        try { scheduleCutoutPreviewForTime(); } catch (_e) {}
        if (cutoutRecorderArmed) {
          addOrUpdatePropKeyAt('position', cutoutCurrentTime, { x: cutoutSelectedObject.x, y: cutoutSelectedObject.y });
          drawCutoutTimeline(); updateRowKeyActiveStates();
        }
      });
      attachCutoutNumericInput(posYEl, 'Position Y', (val) => {
        if (!cutoutSelectedObject) return;
        cutoutSelectedObject.y = val;
        updateCutoutPositionDisplay(cutoutSelectedObject.x, cutoutSelectedObject.y);
        cutoutRenderSelectionOverlay();
        try { scheduleCutoutPreviewForTime(); } catch (_e) {}
        if (cutoutRecorderArmed) {
          addOrUpdatePropKeyAt('position', cutoutCurrentTime, { x: cutoutSelectedObject.x, y: cutoutSelectedObject.y });
          drawCutoutTimeline(); updateRowKeyActiveStates();
        }
      });
      // Zoom bar drag listeners (X or Y adjusts both)
      const zoomXEl = document.getElementById('cutout-zoom-x');
      const zoomYEl = document.getElementById('cutout-zoom-y');
      if (zoomXEl) zoomXEl.addEventListener('mousedown', beginZoomDrag);
      if (zoomYEl) zoomYEl.addEventListener('mousedown', beginZoomDrag);
      attachCutoutNumericInput(zoomXEl, 'Zoom X', (val) => {
        if (!cutoutSelectedObject) return;
        cutoutSelectedObject.scaleX = val;
        cutoutSelectedObject.scaleY = (typeof cutoutSelectedObject.scaleY === 'number') ? cutoutSelectedObject.scaleY : val;
        updateCutoutZoomDisplay(cutoutSelectedObject.scaleX, cutoutSelectedObject.scaleY);
        cutoutRenderSelectionOverlay();
        try { scheduleCutoutPreviewForTime(); } catch (_e) {}
        if (cutoutRecorderArmed) {
          addOrUpdatePropKeyAt('zoom', cutoutCurrentTime, { sx: cutoutSelectedObject.scaleX, sy: cutoutSelectedObject.scaleY });
          drawCutoutTimeline(); updateRowKeyActiveStates();
        }
      });
      attachCutoutNumericInput(zoomYEl, 'Zoom Y', (val) => {
        if (!cutoutSelectedObject) return;
        cutoutSelectedObject.scaleY = val;
        cutoutSelectedObject.scaleX = (typeof cutoutSelectedObject.scaleX === 'number') ? cutoutSelectedObject.scaleX : val;
        updateCutoutZoomDisplay(cutoutSelectedObject.scaleX, cutoutSelectedObject.scaleY);
        cutoutRenderSelectionOverlay();
        try { scheduleCutoutPreviewForTime(); } catch (_e) {}
        if (cutoutRecorderArmed) {
          addOrUpdatePropKeyAt('zoom', cutoutCurrentTime, { sx: cutoutSelectedObject.scaleX, sy: cutoutSelectedObject.scaleY });
          drawCutoutTimeline(); updateRowKeyActiveStates();
        }
      });
      // Rotation slider listeners
      const rotTrack = document.getElementById('cutout-rot-track');
      if (rotTrack) {
        rotTrack.addEventListener('mousedown', beginRotSliderDrag);
        rotTrack.addEventListener('touchstart', beginRotSliderDrag, { passive: false });
      }
      attachCutoutNumericInput(document.getElementById('cutout-rot-value'), 'Rotation (degrees)', (val) => {
        if (!cutoutSelectedObject) return;
        cutoutSelectedObject.rotation = (val * Math.PI) / 180;
        updateCutoutRotationDisplay(val);
        cutoutRenderSelectionOverlay();
        try { scheduleCutoutPreviewForTime(); } catch (_e) {}
        if (cutoutRecorderArmed) {
          addOrUpdatePropKeyAt('rotation', cutoutCurrentTime, { deg: val });
          drawCutoutTimeline(); updateRowKeyActiveStates();
        }
      });
      // Opacity slider listeners
      const opaTrack = document.getElementById('cutout-opa-track');
      if (opaTrack) {
        opaTrack.addEventListener('mousedown', beginOpaSliderDrag);
        opaTrack.addEventListener('touchstart', beginOpaSliderDrag, { passive: false });
      }
      attachCutoutNumericInput(document.getElementById('cutout-opa-value'), 'Opacity (0-1)', (val) => {
        if (!cutoutSelectedObject) return;
        const clamped = Math.max(0, Math.min(1, val));
        cutoutSelectedObject.opacity = clamped;
        updateCutoutOpacityDisplay(clamped);
        cutoutRenderSelectionOverlay();
        try { scheduleCutoutPreviewForTime(); } catch (_e) {}
        if (cutoutRecorderArmed) {
          addOrUpdatePropKeyAt('opacity', cutoutCurrentTime, { value: clamped });
          drawCutoutTimeline(); updateRowKeyActiveStates();
        }
      });
      // Recorder listeners
      const recBtn = document.getElementById('cutout-rec-btn');
      const recTime = document.getElementById('cutout-rec-time');
      if (recBtn) recBtn.addEventListener('click', toggleCutoutRecording);
      if (recTime) recTime.addEventListener('mousedown', beginRecTimeDrag);
      // Initialize recorder button style: paused/armed (grey)
      const rb = document.getElementById('cutout-rec-btn');
      if (rb) { rb.style.background = '#6b7280'; rb.style.boxShadow = '0 0 6px rgba(0,0,0,0.35)'; }
      // Picture Board listeners
      const boardBody = document.getElementById('cutout-board-body');
      if (boardBody && !boardBody.dataset.boardDndBound) {
        boardBody.addEventListener('dragover', (e) => { e.preventDefault(); boardBody.style.borderColor = '#6366f1'; });
        boardBody.addEventListener('dragleave', () => { boardBody.style.borderColor = '#2a2a2a'; });
        boardBody.addEventListener('drop', (e) => {
          e.preventDefault();
          boardBody.style.borderColor = '#2a2a2a';
          const files = e.dataTransfer && e.dataTransfer.files ? e.dataTransfer.files : null;
          handleCutoutBoardFiles(files);
        });
        // Deselect on background click
        boardBody.addEventListener('mousedown', (e) => {
          if (e.target === boardBody) {
            if (cutoutBoardSelectedCell) {
              cutoutBoardSelectedCell.style.border = '1px solid #2a2a2a';
              cutoutBoardSelectedCell.style.boxShadow = '';
              cutoutBoardSelectedCell = null;
            }
          }
        });
        boardBody.dataset.boardDndBound = '1';
      }
      const uploadBtn = document.getElementById('cutout-board-upload-btn');
      const uploadInput = document.getElementById('cutout-board-file-input');
      if (uploadBtn && uploadInput && !uploadBtn.dataset.boundUpload) {
        const openPicker = () => uploadInput.click();
        uploadBtn.addEventListener('click', openPicker);
        uploadBtn.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            openPicker();
          }
        });
        uploadInput.addEventListener('change', () => {
          handleCutoutBoardFiles(uploadInput.files);
          uploadInput.value = '';
        });
        uploadBtn.dataset.boundUpload = '1';
      }
      // Initialize displays to defaults
      updateCutoutOpacityDisplay(1);
      // Enable picture board keyboard delete
      document.addEventListener('keydown', cutoutBoardOnKeyDown);
      // Objects Created panel under transform tools
      const toolsPanel = document.getElementById('cutout-transform-panel');
      if (toolsPanel && !document.getElementById('cutout-objects-panel')) {
        // Replace single title with a row that includes a Select Lasso quick button
        try {
          const maybeTitle = toolsPanel.firstElementChild;
          const isTitle = maybeTitle && (maybeTitle.textContent || '').trim().toLowerCase() === 'transform tools';
          if (isTitle) {
            maybeTitle.style.display = 'none';
          }
          if (!document.getElementById('cutout-transform-title-row')) {
            const titleRow = document.createElement('div');
            titleRow.id = 'cutout-transform-title-row';
            titleRow.style.display = 'flex';
            titleRow.style.alignItems = 'center';
            titleRow.style.justifyContent = 'space-between';
            titleRow.style.width = '100%';
            // Left label (same styling as original title)
            const left = document.createElement('div');
            left.textContent = 'Transform Tools';
            left.style.color = '#9ca3af';
            left.style.fontSize = '11px';
            left.style.fontWeight = '600';
            left.style.letterSpacing = '0.08em';
            left.style.textTransform = 'uppercase';
            left.style.flex = '1';
            left.style.textAlign = 'center';
            // Right quick select lasso button
            const rightBtn = document.createElement('button');
            rightBtn.id = 'cutout-quick-select-lasso';
            rightBtn.title = 'Select Lasso';
            rightBtn.style.width = '22px';
            rightBtn.style.height = '22px';
            rightBtn.style.borderRadius = '6px';
            rightBtn.style.border = '1px solid #3b3b3b';
            rightBtn.style.background = '#111';
            rightBtn.style.color = '#9ca3af';
            rightBtn.style.cursor = 'pointer';
            rightBtn.style.display = 'flex';
            rightBtn.style.alignItems = 'center';
            rightBtn.style.justifyContent = 'center';
            rightBtn.style.lineHeight = '22px';
            rightBtn.style.fontSize = '14px';
            rightBtn.innerHTML = '<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"/><path d="M12 2v4M12 18v4M4.93 4.93l2.83 2.83M16.24 16.24l2.83 2.83M2 12h4M18 12h4M4.93 19.07l2.83-2.83M16.24 7.76l2.83-2.83"/></svg>';
            rightBtn.addEventListener('click', () => {
              // Select the lasso tool
              try { setTool('select-lasso'); } catch (_e) {}
              // Flicker the Select Lasso button in Magic Tools to confirm selection
              try {
                const target = document.getElementById('select-lasso-btn');
                if (target) {
                  const origBg = target.style.background;
                  const origColor = target.style.color;
                  const origBorder = target.style.border;
                  const origShadow = target.style.boxShadow;
                  const inner = target.querySelector('div');
                  const innerBg = inner ? inner.style.background : '';
                  const innerColor = inner ? inner.style.color : '';
                  const pulse = () => {
                    target.style.background = '#6366f1'; // full purple background
                    target.style.color = '#ffffff';
                    target.style.border = '1px solid #a78bfa';
                    target.style.boxShadow = '0 0 10px rgba(99,102,241,0.9)';
                    if (inner) { inner.style.background = '#6366f1'; inner.style.color = '#ffffff'; }
                    setTimeout(() => {
                      target.style.background = origBg || '';
                      target.style.color = origColor || '';
                      target.style.border = origBorder || '';
                      target.style.boxShadow = origShadow || '';
                      if (inner) { inner.style.background = innerBg || ''; inner.style.color = innerColor || ''; }
                    }, 160);
                  };
                  pulse();
                  setTimeout(pulse, 200);
                }
              } catch (_e) {}
            });
            // Left spacer to balance the right button width so title stays centered
            const spacer = document.createElement('div');
            spacer.style.width = '22px';
            spacer.style.height = '22px';
            spacer.style.borderRadius = '6px';
            spacer.style.border = '1px solid transparent';
            spacer.style.background = 'transparent';
            spacer.style.pointerEvents = 'none';
            titleRow.appendChild(spacer);
            titleRow.appendChild(left);
            titleRow.appendChild(rightBtn);
            toolsPanel.insertBefore(titleRow, toolsPanel.firstChild);
          }
        } catch (_e) {}
        const objectsPanel = document.createElement('div');
        objectsPanel.id = 'cutout-objects-panel';
        // Ensure the panel spans full width even though parent uses align-items:flex-end
        objectsPanel.style.alignSelf = 'stretch';
        objectsPanel.style.width = '100%';
        objectsPanel.style.display = 'flex';
        objectsPanel.style.flexDirection = 'column';
        objectsPanel.style.gap = '8px';
        objectsPanel.style.alignItems = 'stretch';
        const title = document.createElement('div');
        title.textContent = 'Objects Created';
        // Match Transform Tools heading: uppercase, centered, compact tracking
        title.style.color = '#9ca3af';
        title.style.fontSize = '11px';
        title.style.fontWeight = '600';
        title.style.letterSpacing = '0.08em';
        title.style.textTransform = 'uppercase';
        title.style.width = '100%';
        title.style.textAlign = 'center';
        title.style.marginTop = '8px';
        const sep = document.createElement('div');
        sep.style.width = '100%';
        sep.style.height = '1px';
        sep.style.background = '#2a2a2a';
        const list = document.createElement('div');
        list.id = 'cutout-objects-list';
        // Show 3 items per row, then wrap
        list.style.display = 'grid';
        list.style.gridTemplateColumns = 'repeat(3, 1fr)';
        list.style.gap = '6px';
        // Start rows from the right
        list.style.direction = 'rtl';
        // Limit height to ~3 rows; enable themed scrollbar
        list.style.maxHeight = '120px';
        list.style.overflow = 'auto';
        // Append into the panel wrapper, then attach wrapper once
        objectsPanel.appendChild(title);
        objectsPanel.appendChild(sep);
        objectsPanel.appendChild(list);
        toolsPanel.appendChild(objectsPanel);
      }
      if (typeof renderCutoutObjectsList === 'function') renderCutoutObjectsList();
      // Layers Created panel under picture board
      const board = document.getElementById('cutout-picture-board');
      if (board && !document.getElementById('cutout-layers-panel')) {
        const layersPanel = document.createElement('div');
        layersPanel.id = 'cutout-layers-panel';
        layersPanel.style.marginTop = '10px';
        layersPanel.style.border = '1px solid #2a2a2a';
        layersPanel.style.borderRadius = '10px';
        // Remove black background behind the title area
        layersPanel.style.background = 'transparent';
        layersPanel.style.padding = '8px';
        // Title row
        const titleRow = document.createElement('div');
        titleRow.style.display = 'flex';
        titleRow.style.alignItems = 'center';
        titleRow.style.justifyContent = 'space-between';
        const title = document.createElement('div');
        title.textContent = 'Layers Created';
        title.style.color = '#9ca3af';
        title.style.fontSize = '11px';
        title.style.fontWeight = '600';
        title.style.letterSpacing = '0.08em';
        title.style.textTransform = 'uppercase';
        title.style.textAlign = 'center';
        title.style.flex = '1';
        const addBtn = document.createElement('button');
        addBtn.id = 'cutout-add-layer-btn';
        addBtn.title = 'Add Layer';
        addBtn.style.width = '20px';
        addBtn.style.height = '20px';
        addBtn.style.borderRadius = '4px';
        addBtn.style.border = '1px solid #3b3b3b';
        addBtn.style.background = '#111';
        addBtn.style.color = '#9ca3af';
        addBtn.style.cursor = 'pointer';
        // Center the plus icon in its square
        addBtn.style.display = 'flex';
        addBtn.style.alignItems = 'center';
        addBtn.style.justifyContent = 'center';
        addBtn.style.lineHeight = '20px';
        addBtn.style.fontSize = '14px';
        addBtn.textContent = '+';
        addBtn.addEventListener('click', () => {
          if (typeof addCutoutLayer === 'function') addCutoutLayer();
        });
        titleRow.appendChild(title);
        titleRow.appendChild(addBtn);
        const sep = document.createElement('div');
        sep.style.width = '100%';
        sep.style.height = '1px';
        sep.style.background = '#2a2a2a';
        sep.style.marginTop = '6px';
        // Layers list
        const list = document.createElement('div');
        list.id = 'cutout-layers-list';
        // Add spacing below the separator like in Objects Created
        list.style.marginTop = '8px';
        list.style.display = 'flex';
        list.style.flexDirection = 'column';
        list.style.gap = '6px';
        // Limit height to ~3 layer rows; enable themed scrollbar
        list.style.maxHeight = '240px';
        list.style.overflow = 'auto';
        layersPanel.appendChild(titleRow);
        layersPanel.appendChild(sep);
        layersPanel.appendChild(list);
        board.appendChild(layersPanel);
      }
      if (typeof renderCutoutLayersPanel === 'function') renderCutoutLayersPanel();
      // Ensure scrubber spans full height and has a "hammer head" touching the top purple line
      if (cutoutScrubberEl) {
        cutoutScrubberEl.style.top = '0';
        cutoutScrubberEl.style.bottom = '0';
        cutoutScrubberEl.style.pointerEvents = 'none';
        cutoutScrubberEl.style.zIndex = '6';
        let head = document.getElementById('cutout-timeline-scrubber-head');
        if (!head) {
          head = document.createElement('div');
          head.id = 'cutout-timeline-scrubber-head';
          head.style.position = 'absolute';
          head.style.top = '0';
          head.style.left = '50%';
          head.style.transform = 'translateX(-50%)';
          head.style.width = '14px';
          head.style.height = '9px'; // adjusted hammer head height
          head.style.background = '#6366f1'; // purple theme
          head.style.borderRadius = '0';
          head.style.boxShadow = '0 0 2px rgba(0,0,0,0.25)';
          head.style.pointerEvents = 'none';
          cutoutScrubberEl.appendChild(head);
        } else {
          head.style.height = '9px';
          head.style.borderRadius = '0';
        }
        // Add or update the upside-down triangle under the head; base matches head width
        let tri = document.getElementById('cutout-timeline-scrubber-tri');
        if (!tri) {
          tri = document.createElement('div');
          tri.id = 'cutout-timeline-scrubber-tri';
          tri.style.position = 'absolute';
          tri.style.left = '50%';
          tri.style.transform = 'translateX(-50%)';
          tri.style.width = '0';
          tri.style.height = '0';
          tri.style.pointerEvents = 'none';
          cutoutScrubberEl.appendChild(tri);
        }
        // Position triangle so its base touches the bottom of the hammer head
        tri.style.top = '9px';
        // Base width equals head width (14px => 7px left/right borders)
        tri.style.borderLeft = '7px solid transparent';
        tri.style.borderRight = '7px solid transparent';
        tri.style.borderTop = '7px solid #6366f1'; // purple triangle pointing down
      }
      // Sync size and aspect exactly like normal preview/frames
      syncCutoutSizing();
      // Ensure all clip canvases match cutout canvas dimensions
      if (typeof syncAllClipCanvasDimensions === 'function') {
        try { syncAllClipCanvasDimensions(); } catch (_e) {}
      }
      // Ensure wheel-zoom baseline is 1.0 each time we enter cutout mode
      cutoutZoomLevel = 1;
      cutoutZoomOriginPoint = null; // Reset point-accurate zoom origin
      cutoutPanX = 0;
      cutoutPanY = 0;
      applyCutoutZoomTransforms();
      // Align transform panel with canvas top
      positionCutoutTransformPanel();
      window.addEventListener('resize', positionCutoutTransformPanel);
      drawCutoutTimeline();
      updateCutoutScrubber();
      // Ensure the canvas background/preview is drawn immediately on enter
      if (typeof renderCutoutPreviewForTime === 'function') {
        try { renderCutoutPreviewForTime(); } catch (_e) {}
      }
      // Switch Magic Effects to Cut Out friendly set
      applyCutoutEffectsList();
      // Switch Magic Timeline to Magic Transitions
      applyCutoutTransitionsList();
    }

    function teardownCutOutMode() {
      if (cutoutTimelineEl) {
        cutoutTimelineEl.removeEventListener('mousedown', cutoutBeginDrag);
      }
      // Restore scroll button behavior when leaving Cut Out mode
      setScrollButtonModeCutout(false);
      document.removeEventListener('keydown', onCutoutKeyDown);
      if (cutoutCanvas) {
        cutoutCanvas.removeEventListener('mousedown', cutoutStartDraw);
        cutoutCanvas.removeEventListener('mousemove', cutoutDraw);
        window.removeEventListener('mouseup', cutoutStopDraw);
        cutoutCanvas.removeEventListener('mouseleave', cutoutStopDraw);
      }
      if (cutoutBonesOverlayCanvas) {
        cutoutBonesOverlayCanvas.remove();
        cutoutBonesOverlayCanvas = null;
        cutoutBonesOverlayCtx = null;
      }
      document.removeEventListener('keydown', cutoutBoardOnKeyDown);
      document.removeEventListener('keydown', onCutoutTransitionsKeyDown);
      cutoutIsPlaying = false;
      if (cutoutRAF) {
        cancelAnimationFrame(cutoutRAF);
        cutoutRAF = null;
      }
      // Restore Magic Effects list and remove cut out overlays
      restoreDefaultEffectsList();
      removeCutoutOverlays();
      // Restore Magic Timeline list and title
      restoreMagicTimelineList();
    }

    function cutoutPlayPause() {
      if (cutoutIsPlaying) {
        cutoutPausePlayback();
      } else {
        cutoutPlayDirection = 1;
        cutoutStartPlayback();
      }
    }

    function cutoutStartPlayback() {
      cutoutIsPlaying = true;
      // Ensure any active/pending selection is committed before playback
      try {
        if (typeof cutoutSelectedObject !== 'undefined' && cutoutSelectedObject) {
          if (typeof cutoutCommitSelection === 'function') {
            cutoutCommitSelection();
          }
        } else {
          if (typeof cutoutCancelSelectionOverlay === 'function') {
            cutoutCancelSelectionOverlay();
          }
        }
      } catch (_e) { /* ignore */ }
      cutoutStartTimeAtPlay = cutoutCurrentTime;
      cutoutPlayStartTs = performance.now();
      const step = (ts) => {
        if (!isCutoutDragging) {
          const elapsedSec = Math.max(0, ts - cutoutPlayStartTs) / 1000;
          let t = cutoutStartTimeAtPlay + cutoutPlayDirection * elapsedSec;
          // wrap into [0, duration)
          t = ((t % cutoutDuration) + cutoutDuration) % cutoutDuration;
          cutoutCurrentTime = t;
          updateCutoutScrubber();
        }
        if (cutoutIsPlaying) cutoutRAF = requestAnimationFrame(step);
      };
      cutoutRAF = requestAnimationFrame(step);
      const btn = document.getElementById('cutout-play-btn');
      if (btn) btn.textContent = 'Pause';
      // Sync scroll button icon if repurposed in Cut Out mode
      updateScrollButtonIconForCutout();
    }

    function cutoutPausePlayback() {
      cutoutIsPlaying = false;
      if (cutoutRAF) {
        cancelAnimationFrame(cutoutRAF);
        cutoutRAF = null;
      }
      const btn = document.getElementById('cutout-play-btn');
      if (btn) btn.textContent = 'Play';
      // Sync scroll button icon if repurposed in Cut Out mode
      updateScrollButtonIconForCutout();
    }

    function cutoutPlayForward() {
      cutoutPlayDirection = 1;
      cutoutStartPlayback();
      setCutoutTransportActive('forward');
    }

    function cutoutPlayReverse() {
      cutoutPlayDirection = -1;
      cutoutStartPlayback();
      setCutoutTransportActive('reverse');
    }

    function cutoutPause() {
      cutoutPausePlayback();
      setCutoutTransportActive('none');
    }

    function setCutoutTransportActive(mode) {
      const btnPlay = document.getElementById('cutout-btn-play');
      const btnRev = document.getElementById('cutout-btn-reverse');
      if (btnPlay) btnPlay.classList.toggle('active', mode === 'forward');
      if (btnRev) btnRev.classList.toggle('active', mode === 'reverse');
    }

    function cutoutAddKey() {
      saveState();
      const t = cutoutCurrentTime || 0;
      cutoutKeys.push({ time: Math.max(0, Math.min(cutoutDuration, t)) });
      cutoutKeys.sort((a, b) => a.time - b.time);
      drawCutoutTimeline();
      saveState();
    }

    // Keep cutout sizing in sync on window resize
    window.addEventListener('resize', () => {
      if (isCutOutMode) {
        syncCutoutSizing();
        drawCutoutTimeline();
        updateCutoutScrubber();
        // Redraw the checkerboard/preview after size changes
        if (typeof renderCutoutPreviewForTime === 'function') {
          try { renderCutoutPreviewForTime(); } catch (_e) {}
        }
      }
    });

    function cutoutClearKeys() {
      saveState();
      cutoutKeys = [];
      drawCutoutTimeline();
      saveState();
    }

    function cutoutSetTimeFromEvent(e) {
      const track = document.getElementById('cutout-ruler-area');
      if (!track) return;
      const rect = track.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const pct = Math.max(0, Math.min(1, x / rect.width));
      cutoutCurrentTime = pct * cutoutDuration;
      updateCutoutScrubber();
    }

    function cutoutBeginDrag(e) {
      isCutoutDragging = true;
      document.body.style.userSelect = 'none';
      window.addEventListener('mousemove', cutoutDragMove);
      window.addEventListener('mouseup', cutoutEndDrag, { once: true });
    }

    function cutoutDragMove(e) {
      if (!isCutoutDragging) return;
      cutoutSetTimeFromEvent(e);
    }

    function cutoutEndDrag() {
      if (!isCutoutDragging) return;
      isCutoutDragging = false;
      document.body.style.userSelect = '';
      window.removeEventListener('mousemove', cutoutDragMove);
      if (cutoutIsPlaying) {
        cutoutStartTimeAtPlay = cutoutCurrentTime;
        cutoutPlayStartTs = performance.now();
      }
    }

    function updateCutoutScrubber() {
      const track = document.getElementById('cutout-ruler-area');
      if (!track || !cutoutScrubberEl) return;
      const rect = track.getBoundingClientRect();
      const pct = (cutoutCurrentTime / cutoutDuration);
      const left = Math.max(0, Math.min(rect.width, pct * rect.width));
      cutoutScrubberEl.style.left = left + 'px';
      // Update timecode display
      const tc = document.getElementById('cutout-timecode');
      if (tc) tc.textContent = formatCutoutTime(cutoutCurrentTime);
      updateRecorderTimeDisplay();
      // Coalesce expensive preview/transforms work to one frame
      if (!cutoutPreviewRAF) {
        cutoutPreviewRAF = requestAnimationFrame(() => {
          renderCutoutPreviewForTime();
          updateRowKeyActiveStates();
          applyCutoutKeyframedTransformsAtTime();
          cutoutPreviewRAF = null;
        });
      }
    }

    function drawCutoutTimeline() {
      const keysContainer = document.getElementById('cutout-timeline-keys');
      const track = document.getElementById('cutout-ruler-area');
      if (!keysContainer || !track) return;
      // Ensure clicks on key bars are received even if container had pointer-events none from CSS
      try { keysContainer.style.pointerEvents = 'auto'; } catch (_e) {}
      // Ensure a top-only ticks container and top red line exist (no labels)
      let ticksContainer = document.getElementById('cutout-timeline-ticks');
      if (!ticksContainer) {
        ticksContainer = document.createElement('div');
        ticksContainer.id = 'cutout-timeline-ticks';
        ticksContainer.style.position = 'absolute';
        ticksContainer.style.top = '0';
        ticksContainer.style.left = '0';
        ticksContainer.style.right = '0';
        ticksContainer.style.height = '14px';
        ticksContainer.style.pointerEvents = 'none';
        ticksContainer.style.zIndex = '4';
        track.appendChild(ticksContainer);
      }
      // Create layered gradient stripes for minor and major ticks
      let minorLayer = document.getElementById('cutout-timeline-ticks-minor');
      if (!minorLayer) {
        minorLayer = document.createElement('div');
        minorLayer.id = 'cutout-timeline-ticks-minor';
        minorLayer.style.position = 'absolute';
        minorLayer.style.top = '0';
        minorLayer.style.left = '0';
        minorLayer.style.right = '0';
        minorLayer.style.height = '10px'; // minor tick height (slightly longer)
        minorLayer.style.pointerEvents = 'none';
        ticksContainer.appendChild(minorLayer);
      }
      let majorLayer = document.getElementById('cutout-timeline-ticks-major');
      if (!majorLayer) {
        majorLayer = document.createElement('div');
        majorLayer.id = 'cutout-timeline-ticks-major';
        majorLayer.style.position = 'absolute';
        majorLayer.style.top = '0';
        majorLayer.style.left = '0';
        majorLayer.style.right = '0';
        majorLayer.style.height = '14px'; // major tick height (slightly longer)
        majorLayer.style.pointerEvents = 'none';
        ticksContainer.appendChild(majorLayer);
      }
      // Style the layers: thin evenly-spaced ticks
      // Minor every 10px (5 minors between majors), Major every 60px, gray color
      minorLayer.style.backgroundImage =
        'repeating-linear-gradient(90deg, #6b7280 0 1px, transparent 1px, transparent 10px)';
      majorLayer.style.backgroundImage =
        'repeating-linear-gradient(90deg, #6b7280 0 1px, transparent 1px, transparent 60px)';
      // Ensure a thin red line across the very top edge
      let topLine = document.getElementById('cutout-timeline-topline');
      if (!topLine) {
        topLine = document.createElement('div');
        topLine.id = 'cutout-timeline-topline';
        topLine.style.position = 'absolute';
        topLine.style.top = '0';
        topLine.style.left = '0';
        topLine.style.right = '0';
        topLine.style.height = '2px';
        topLine.style.background = '#6366f1'; // app purple theme
        topLine.style.pointerEvents = 'none';
        topLine.style.zIndex = '7';
        track.appendChild(topLine);
      }
      // Re-render key markers
      keysContainer.innerHTML = '';
      const rect = track.getBoundingClientRect();
      // Synchronize duration so each major tick (60px) represents exactly 1 second
      const pixelsPerSecond = 60;
      cutoutDuration = Math.max(0.1, rect.width / pixelsPerSecond);
      // Ensure timecode reflects current time
      const tc = document.getElementById('cutout-timecode');
      if (tc) tc.textContent = formatCutoutTime(cutoutCurrentTime);
      // Ensure clips container exists
      let clipsContainer = document.getElementById('cutout-timeline-clips');
      if (!clipsContainer) {
        clipsContainer = document.createElement('div');
        clipsContainer.id = 'cutout-timeline-clips';
        clipsContainer.style.position = 'absolute';
        clipsContainer.style.top = '16px';
        clipsContainer.style.bottom = '8px';
        clipsContainer.style.left = '0';
        clipsContainer.style.right = '0';
        clipsContainer.style.pointerEvents = 'none';
        clipsContainer.style.zIndex = '3';
        track.appendChild(clipsContainer);
      }
      // Render existing clips positioned by current rect
      renderCutoutClips();
      // Draw key markers spanning the track height
      for (const k of cutoutKeys) {
        const pct = (k.time / cutoutDuration);
        const left = Math.max(0, Math.min(rect.width, pct * rect.width));
        const m = document.createElement('div');
        m.style.position = 'absolute';
        m.style.left = (left - 2) + 'px';
        m.style.top = '0';
        m.style.bottom = '0';
        m.style.width = '4px';
        m.style.background = '#ef4444';
        m.style.boxShadow = '0 0 6px rgba(239,68,68,0.5)';
        m.style.pointerEvents = 'auto';
        m.style.cursor = 'pointer';
        const tStr = String(Math.max(0, Math.min(cutoutDuration, k.time)).toFixed(4));
        m.setAttribute('data-key-time', tStr);
        // Allow dragging the timeline even when pressing on a bar
        m.addEventListener('mousedown', (e) => {
          cutoutBeginDrag(e);
        });
        m.addEventListener('click', (e) => {
          e.stopPropagation();
          const t = k.time;
          jumpToCutoutTime(t);
        });
        keysContainer.appendChild(m);
      }
      // Draw property key icons (diamonds) just above top line
      let propKeysContainer = document.getElementById('cutout-prop-keys');
      if (!propKeysContainer) {
        propKeysContainer = document.createElement('div');
        propKeysContainer.id = 'cutout-prop-keys';
        propKeysContainer.style.position = 'absolute';
        propKeysContainer.style.left = '0';
        propKeysContainer.style.right = '0';
        // Place the diamonds along the same line as the top timeline ruler line
        // (just outside the ruler area, visually centered on the top edge)
        propKeysContainer.style.top = '-6px';
        propKeysContainer.style.height = '12px';
        propKeysContainer.style.pointerEvents = 'none'; // allow children to enable their own
        propKeysContainer.style.zIndex = '8';
        track.appendChild(propKeysContainer);
      } else {
        propKeysContainer.innerHTML = '';
      }
      // When switching active object, ensure cutoutPropertyKeys points to it
      const activeIdx2 = getActiveCutoutClipIndexAt(cutoutCurrentTime);
      if (activeIdx2 >= 0) {
        const c = cutoutClips[activeIdx2];
        const obj = cutoutActiveObject || (Array.isArray(c.objects) ? c.objects[0] : null);
        if (obj && obj.keys) {
          cutoutPropertyKeys = obj.keys;
        }
      }
      // Draw a single combined key marker per time across all properties (no stacking)
      const drawCombinedMarker = (time, prop, keyObj, color) => {
        const pct = (time / cutoutDuration);
        const left = Math.max(0, Math.min(rect.width, pct * rect.width));
        const m = document.createElement('div');
        m.style.position = 'absolute';
        m.style.left = (left - 5) + 'px';
        m.style.top = '2px';
        m.style.width = '10px';
        m.style.height = '10px';
        m.style.transform = 'rotate(45deg)';
        m.style.background = color;
        m.style.border = '1px solid #3b3b3b';
        m.style.boxShadow = '0 0 6px rgba(99,102,241,0.45)';
        m.style.pointerEvents = 'auto';
        m.style.cursor = 'ew-resize';
        // Default drag targets to whichever prop/key provided
        m.addEventListener('mousedown', (e) => beginPropKeyDrag(e, prop, keyObj));
        // Tag with time so flickerCutoutNodesAt can highlight these diamonds on bar-click
        const tStr = String(Math.max(0, Math.min(cutoutDuration, time)).toFixed(4));
        m.setAttribute('data-key-time', tStr);
        // Do not attach a click handler here to avoid conflict with dragging;
        // jumping is handled by clicking the ruler key bars instead.
        propKeysContainer.appendChild(m);
      };
      // Ensure keys binding and color reflect either pending selection or the active object
      let activeColor = '#6366f1';
      if (cutoutPendingSelection && cutoutPendingKeys) {
        cutoutPropertyKeys = cutoutPendingKeys;
        activeColor = cutoutPendingColor || activeColor;
      } else {
        const activeIdx = getActiveCutoutClipIndexAt(cutoutCurrentTime);
        if (activeIdx >= 0) {
          const c = cutoutClips[activeIdx];
          const obj = cutoutActiveObject || (Array.isArray(c.objects) ? c.objects[0] : null);
          if (obj && obj.keys) cutoutPropertyKeys = obj.keys;
          if (obj && obj.color) activeColor = obj.color;
        }
      }
      // Build unique times across all prop keys; pick a representative key/prop for drag
      const timeMap = new Map();
      const addSet = (prop, arr) => {
        (arr || []).forEach(k => {
          const t = k.time;
          if (!timeMap.has(t)) timeMap.set(t, { prop, key: k });
        });
      };
      addSet('position', cutoutPropertyKeys.position);
      addSet('zoom', cutoutPropertyKeys.zoom);
      addSet('rotation', cutoutPropertyKeys.rotation);
      addSet('opacity', cutoutPropertyKeys.opacity);
      Array.from(timeMap.entries()).forEach(([time, ref]) => {
        drawCombinedMarker(time, ref.prop, ref.key, activeColor);
      });
    }
    
    function jumpToCutoutTime(time) {
      const t = Math.max(0, Math.min(cutoutDuration, time || 0));
      cutoutCurrentTime = t;
      updateCutoutScrubber();
    }
    
    /* Removed timeline node flicker effect */
    
    function formatCutoutTime(totalSeconds) {
      const clamped = Math.max(0, totalSeconds);
      const minutes = Math.floor(clamped / 60);
      const seconds = Math.floor(clamped % 60);
      // Frames at 60 fps (00â€“59). When it hits 60, a second has passed.
      const frames = Math.floor((clamped - Math.floor(clamped)) * 60);
      const pad2 = (n) => String(n).padStart(2, '0');
      // Order: MM:SS:FF (rightmost two digits are frames out of 60)
      return pad2(minutes) + ':' + pad2(seconds) + ':' + pad2(frames);
    }
    
    function getActiveCutoutClipIndexAt(time) {
      for (let i = 0; i < cutoutClips.length; i++) {
        const c = cutoutClips[i];
        if (time >= c.start && time < c.end) return i;
      }
      return -1;
    }
    
    function renderCutoutPreviewForTime() {
      if (!cutoutCanvas || !cutoutCtx) return;
      // Clear
      cutoutCtx.clearRect(0, 0, cutoutCanvas.width, cutoutCanvas.height);
      // Background: chess when idle, blackish when playing
      if (cutoutIsPlaying) {
        cutoutCtx.fillStyle = '#1a1a1a';
        cutoutCtx.fillRect(0, 0, cutoutCanvas.width, cutoutCanvas.height);
      } else {
        fillCheckerboard(cutoutCtx, cutoutCanvas.width, cutoutCanvas.height);
      }
      // Draw active clip if any
      const idx = getActiveCutoutClipIndexAt(cutoutCurrentTime);
      if (idx >= 0) {
        const c = cutoutClips[idx];
        
        // Draw fill layer first (if present) so fills sit underneath objects
        if (c && c.fillCanvas && c.fillCanvas.width > 0 && c.fillCanvas.height > 0) {
          if (c.fillCanvas.width === cutoutCanvas.width && c.fillCanvas.height === cutoutCanvas.height) {
            cutoutCtx.drawImage(c.fillCanvas, 0, 0);
          } else {
            cutoutCtx.drawImage(c.fillCanvas, 0, 0, c.fillCanvas.width, c.fillCanvas.height, 0, 0, cutoutCanvas.width, cutoutCanvas.height);
          }
        }
        // Draw the base clip canvas next so fills remain below brush strokes
        if (c && c.canvas && c.canvas.width > 0 && c.canvas.height > 0) {
          if (c.canvas.width === cutoutCanvas.width && c.canvas.height === cutoutCanvas.height) {
            cutoutCtx.drawImage(c.canvas, 0, 0);
          } else {
            cutoutCtx.drawImage(c.canvas, 0, 0, c.canvas.width, c.canvas.height, 0, 0, cutoutCanvas.width, cutoutCanvas.height);
          }
        }
        
        // Draw animated objects above the canvas with correct layering and stable tiebreaker by id
        let objects = Array.isArray(c.objects) ? c.objects.slice() : (c.object ? [c.object] : []);
        objects.sort((a, b) => {
          const ai = Number.isFinite(a && a.layerIndex) ? a.layerIndex : 0;
          const bi = Number.isFinite(b && b.layerIndex) ? b.layerIndex : 0;
          if (ai !== bi) return bi - ai; // higher layerIndex first (bottom), lower later (on top)
          const aid = (a && a.id != null) ? a.id : 0;
          const bid = (b && b.id != null) ? b.id : 0;
          return aid - bid; // smaller id first, larger id later (on top)
        });
        for (const obj of objects) {
          if (!obj || !obj.img) continue;
          // If actively interacting with selection, overlay draws the selected object.
          // Only skip drawing in base while interacting to avoid flicker and shadows.
          const isInteracting = !!(cutoutIsDraggingObj || cutoutIsResizingObj || cutoutIsRotatingObj);
          if (isInteracting && cutoutSelectedObject) {
            const sameRef = (obj === cutoutSelectedObject);
            const sameId = (obj && cutoutSelectedObject && obj.id != null && cutoutSelectedObject.id != null && obj.id === cutoutSelectedObject.id);
            if (sameRef || sameId) continue;
          }
          const t = Math.max(0, Math.min(cutoutDuration, cutoutCurrentTime || 0));
          // Start from stored base transform
          const drawObj = {
            img: obj.img,
            src: obj.src,
            x: Number.isFinite(obj.x) ? obj.x : 0,
            y: Number.isFinite(obj.y) ? obj.y : 0,
            scale: Number.isFinite(obj.scale) ? obj.scale : 1,
            scaleX: Number.isFinite(obj.scaleX) ? obj.scaleX : 1,
            scaleY: Number.isFinite(obj.scaleY) ? obj.scaleY : 1,
            rotation: Number.isFinite(obj.rotation) ? obj.rotation : 0,
            opacity: Number.isFinite(obj.opacity) ? obj.opacity : 1,
            drawW: obj.drawW,
            drawH: obj.drawH
          };
          // Apply keyframed transforms at time t if available (use object-local keys only)
          const keys = (obj.keys && typeof obj.keys === 'object') ? obj.keys : { position: [], zoom: [], rotation: [], opacity: [] };
          const pos = sampleKeyframes(keys.position, t, (a, b, alpha) => ({
            x: lerp(a.x, b.x, alpha),
            y: lerp(a.y, b.y, alpha)
          }));
          if (pos) { drawObj.x = pos.x; drawObj.y = pos.y; }
          const zm = sampleKeyframes(keys.zoom, t, (a, b, alpha) => ({
            sx: lerp(a.sx, b.sx, alpha),
            sy: lerp(a.sy, b.sy, alpha)
          }));
          if (zm) { drawObj.scaleX = zm.sx; drawObj.scaleY = zm.sy; }
          const rot = sampleKeyframes(keys.rotation, t, (a, b, alpha) => {
            const target = shortestAngleDeg(a.deg, b.deg);
            return { deg: lerp(a.deg, target, alpha) };
          });
          if (rot) { drawObj.rotation = (rot.deg * Math.PI) / 180; }
          const op = sampleKeyframes(keys.opacity, t, (a, b, alpha) => ({
            value: lerp(a.value, b.value, alpha)
          }));
          if (op) { drawObj.opacity = Math.max(0, Math.min(1, op.value)); }
          // Apply bone transformation AFTER keyframes to keep bone-pinned position consistent
          // This ensures the object stays at its bone-adjusted position even when keyframes exist
          try {
            let linkedBone = null;
            for (let bi = 0; bi < cutoutBones.length; bi++) {
              const bone = cutoutBones[bi];
              if (!bone || bone.clipIndex !== idx) continue;
              if (bone.objectRef === obj || (bone.objectRef && obj && bone.objectRef.id != null && obj.id != null && bone.objectRef.id === obj.id)) {
                linkedBone = bone;
                break;
              }
            }
            if (linkedBone && typeof linkedBone.pinnedLocalX === 'number' && typeof linkedBone.pinnedLocalY === 'number') {
              const boneBaseW = (drawObj.drawW != null) ? drawObj.drawW : ((drawObj.img && (drawObj.img.naturalWidth || drawObj.img.width || drawObj.img.videoWidth)) || 0);
              const boneBaseH = (drawObj.drawH != null) ? drawObj.drawH : ((drawObj.img && (drawObj.img.naturalHeight || drawObj.img.height || drawObj.img.videoHeight)) || 0);
              const boneEffScaleX = (typeof drawObj.scaleX === 'number' ? drawObj.scaleX : 1);
              const boneEffScaleY = (typeof drawObj.scaleY === 'number' ? drawObj.scaleY : 1);
              const boneW = boneBaseW * (drawObj.scale || 1) * boneEffScaleX;
              const boneH = boneBaseH * (drawObj.scale || 1) * boneEffScaleY;
              const bonePx = linkedBone.pinnedLocalX;
              const bonePy = linkedBone.pinnedLocalY;
              const boneRot = drawObj.rotation || 0;
              const boneCos = Math.cos(boneRot), boneSin = Math.sin(boneRot);
              const boneRx = bonePx * boneCos - bonePy * boneSin;
              const boneRy = bonePx * boneSin + bonePy * boneCos;
              const boneCenterX = linkedBone.startX - boneRx;
              const boneCenterY = linkedBone.startY - boneRy;
              drawObj.x = boneCenterX - boneW / 2;
              drawObj.y = boneCenterY - boneH / 2;
              // Also update the source object to keep state consistent
              obj.x = drawObj.x;
              obj.y = drawObj.y;
            }
          } catch (_boneErr) {}
          // Composite animated object
          drawRotatedImage(cutoutCtx, drawObj);
        }
        // Apply effects assigned to this clip
        if (typeof applyCutoutClipEffects === 'function') applyCutoutClipEffects(c);
      } else {
        // No active clip: disable any cutout-controlled overlays
        if (typeof applyCutoutClipEffects === 'function') applyCutoutClipEffects(null);
      }
      // Apply transition visuals if any at current time
      if (typeof applyTransitionAtTime === 'function') applyTransitionAtTime(cutoutCurrentTime || 0);
    }
    
    function updateCutoutPositionDisplay(x, y) {
      const ex = document.getElementById('cutout-pos-x');
      const ey = document.getElementById('cutout-pos-y');
      if (ex) ex.textContent = Number.isFinite(x) ? x.toFixed(3) : '00.000';
      if (ey) ey.textContent = Number.isFinite(y) ? y.toFixed(3) : '00.000';
    }
    function clearCutoutPositionDisplay() {
      const ex = document.getElementById('cutout-pos-x');
      const ey = document.getElementById('cutout-pos-y');
      if (ex) ex.textContent = '00.000';
      if (ey) ey.textContent = '00.000';
    }
    
    function updateCutoutZoomDisplay(sx, sy) {
      const zx = document.getElementById('cutout-zoom-x');
      const zy = document.getElementById('cutout-zoom-y');
      if (zx) zx.textContent = Number.isFinite(sx) ? sx.toFixed(3) : '1.000';
      if (zy) zy.textContent = Number.isFinite(sy) ? sy.toFixed(3) : '1.000';
    }
    function clearCutoutZoomDisplay() {
      const zx = document.getElementById('cutout-zoom-x');
      const zy = document.getElementById('cutout-zoom-y');
      if (zx) zx.textContent = '1.000';
      if (zy) zy.textContent = '1.000';
    }
    
    function updateCutoutRotationDisplay(degrees) {
      const rv = document.getElementById('cutout-rot-value');
      if (rv) rv.textContent = Number.isFinite(degrees) ? degrees.toFixed(3) : '0.000';
      // Update knob position along track: -180..+180 maps to 0..100%
      const track = document.getElementById('cutout-rot-track');
      const knob = document.getElementById('cutout-rot-knob');
      if (track && knob) {
        const clamped = Math.max(-180, Math.min(180, degrees || 0));
        const pct = (clamped + 180) / 360; // 0..1
        const tw = track.clientWidth || 120;
        const leftPx = pct * tw;
        knob.style.left = `${leftPx}px`;
        knob.style.transform = 'translate(-50%, -50%)';
      }
      updateRowKeyActiveStates();
    }
    function clearCutoutRotationDisplay() {
      updateCutoutRotationDisplay(0);
    }
    // Blur display removed
    function updateCutoutOpacityDisplay(value) {
      const ov = document.getElementById('cutout-opa-value');
      if (ov) ov.textContent = Number.isFinite(value) ? value.toFixed(3) : '1.000';
      const track = document.getElementById('cutout-opa-track');
      const knob = document.getElementById('cutout-opa-knob');
      if (track && knob) {
        const clamped = Math.max(0, Math.min(1, value || 0));
        const pct = clamped; // 0..1
        const tw = track.clientWidth || 120;
        const leftPx = pct * tw;
        knob.style.left = `${leftPx}px`;
        knob.style.transform = 'translate(-50%, -50%)';
      }
      updateRowKeyActiveStates();
    }
    function clearCutoutOpacityDisplay() {
      updateCutoutOpacityDisplay(1);
    }

    let cutoutSelectedObject = null;

    // Re-sync slider knob positions after layout shifts (e.g., phone drawers)
    function refreshCutoutSliderUi() {
      const obj = cutoutSelectedObject;
      const rotDeg = obj && typeof obj.rotation === 'number'
        ? (obj.rotation * 180) / Math.PI
        : 0;
      const opaVal = obj && typeof obj.opacity === 'number'
        ? obj.opacity
        : 1;
      updateCutoutRotationDisplay(rotDeg);
      updateCutoutOpacityDisplay(opaVal);
    }
    
    // Cut Out per-clip effect application
    let cutoutActiveEffectsSet = new Set();
    function applyCutoutClipEffects(clip) {
      const target = new Set(Array.isArray(clip && clip.effects) ? clip.effects : []);
      const has = (id) => cutoutActiveEffectsSet.has(id);
      const wants = (id) => target.has(id);
      const enableIf = (id, enableFn) => { if (!has(id) && wants(id)) enableFn(); };
      const disableIf = (id, disableFn) => { if (has(id) && !wants(id)) disableFn(); };
      // Enable newly requested
      enableIf('oldTV', () => { if (typeof enableOldTVEffect === 'function') enableOldTVEffect(); });
      enableIf('snow', () => { if (typeof enableSnowEffect === 'function') enableSnowEffect(); });
      enableIf('rain', () => { if (typeof enableRainEffect === 'function') enableRainEffect(); });
      enableIf('oldFilm', () => { if (typeof enableOldFilmEffect === 'function') enableOldFilmEffect(); });
      enableIf('analogHorror', () => { if (typeof enableAnalogHorrorEffect === 'function') enableAnalogHorrorEffect(); });
      // Disable those no longer present
      disableIf('oldTV', () => { if (typeof disableOldTVEffect === 'function') disableOldTVEffect(); });
      disableIf('snow', () => { if (typeof disableSnowEffect === 'function') disableSnowEffect(); });
      disableIf('rain', () => { if (typeof disableRainEffect === 'function') disableRainEffect(); });
      disableIf('oldFilm', () => { if (typeof disableOldFilmEffect === 'function') disableOldFilmEffect(); });
      disableIf('analogHorror', () => { if (typeof disableAnalogHorrorEffect === 'function') disableAnalogHorrorEffect(); });
      cutoutActiveEffectsSet = target;
    }
    function cutoutTimeFromEvent(e) {
      const track = document.getElementById('cutout-ruler-area');
      if (!track) return cutoutCurrentTime || 0;
      const rect = track.getBoundingClientRect();
      const x = Math.max(0, Math.min(rect.width, (e.clientX || 0) - rect.left));
      const t = (rect.width > 0) ? (x / rect.width) * cutoutDuration : (cutoutCurrentTime || 0);
      return Math.max(0, Math.min(cutoutDuration, t));
    }
    function handleCutoutEffectDrop(e) {
      e.preventDefault();
      const effectId = e.dataTransfer ? (e.dataTransfer.getData('text/effect-id') || e.dataTransfer.getData('text/plain')) : '';
      if (!effectId) return;
      const t = cutoutTimeFromEvent(e);
      const idx = getActiveCutoutClipIndexAt(t);
      if (idx < 0) return;
      const clip = cutoutClips[idx];
      if (!Array.isArray(clip.effects)) clip.effects = [];
      if (!clip.effects.includes(effectId)) clip.effects.push(effectId);
      // Select the newly added effect for immediate visibility and easy deletion
      selectedCutoutEffectClipIndex = idx;
      selectedCutoutEffectId = effectId;
      if (typeof renderCutoutClips === 'function') renderCutoutClips();
      if (typeof applyCutoutClipEffects === 'function') applyCutoutClipEffects(clip);
      if (typeof showCopyPasteFeedback === 'function') showCopyPasteFeedback(`${effectId} added`);
    }
    // Transitions
    let cutoutTransitions = []; // {id, start, end, type}
    // Selection state for effects and transitions
    let selectedCutoutEffectClipIndex = -1;
    let selectedCutoutEffectId = '';
    function handleCutoutTransitionDrop(e) {
      const tid = e.dataTransfer ? (e.dataTransfer.getData('text/transition-id')) : '';
      if (!tid) return;
      const t = cutoutTimeFromEvent(e);
      const dur = 0.4; // default 0.4s
      cutoutTransitions.push({ id: `tr-${Date.now()}`, start: Math.max(0, t - dur/2), end: Math.min(cutoutDuration, t + dur/2), type: tid });
      renderCutoutClips();
      if (typeof renderCutoutPreviewForTime === 'function') renderCutoutPreviewForTime();
      if (typeof showCopyPasteFeedback === 'function') showCopyPasteFeedback(`Transition added`);
    }
    let selectedCutoutTransitionId = '';
    function onCutoutTransitionsKeyDown(e) {
      const key = e.key || '';
      if ((key === 'Delete' || key === 'Backspace') && selectedCutoutTransitionId) {
        cutoutTransitions = (Array.isArray(cutoutTransitions) ? cutoutTransitions : []).filter(tr => tr.id !== selectedCutoutTransitionId);
        selectedCutoutTransitionId = '';
        renderCutoutClips();
        if (typeof renderCutoutPreviewForTime === 'function') renderCutoutPreviewForTime();
        try { e.preventDefault(); } catch (_e) {}
      }
    }
    
    // Position both panels below the "Cut Out Mode" title at same height
    function positionCutoutTransformPanel() {
      if (document.body && document.body.classList.contains('cutout-mobile-mode')) return;
      const transformPanel = document.getElementById('cutout-transform-panel');
      const pictureBoard = document.getElementById('cutout-picture-board');
      // Position below "Cut Out Mode" title (which is at top:12px with ~14px height)
      // Both panels should be at the same fixed position with proper clearance
      const topOffset = 56; // Below the Cut Out Mode title with margin
      if (transformPanel) transformPanel.style.top = topOffset + 'px';
      if (pictureBoard) pictureBoard.style.top = topOffset + 'px';
    }

    if (cutoutPhoneMediaQuery) {
      if (typeof cutoutPhoneMediaQuery.addEventListener === 'function') {
        cutoutPhoneMediaQuery.addEventListener('change', syncCutoutMobileUi);
      } else if (typeof cutoutPhoneMediaQuery.addListener === 'function') {
        cutoutPhoneMediaQuery.addListener(syncCutoutMobileUi);
      }
    }
    window.addEventListener('resize', syncCutoutMobileUi);
    window.addEventListener('resize', refreshCutoutSliderUi);
    
    // Cutout selection object and overlay (mirrors regular mode but scoped to cutout)
    let cutoutActiveObject = null;
    let cutoutObjectCounter = 0;
    let lastOilAngle = 0;
    // Throttle preview/timeline updates to once per animation frame during scrubbing
    let cutoutPreviewRAF = null;
    const cutoutObjectPalette = ['#10b981','#f59e0b','#3b82f6','#ef4444','#8b5cf6','#22c55e','#e11d48','#14b8a6','#a855f7','#f97316'];
    // Pending selection state (before committing to an object)
    let cutoutPendingSelection = false;
    let cutoutPendingKeys = null; // { position:[], zoom:[], rotation:[], opacity:[] }
    let cutoutPendingColor = null;
    // Overlay readiness flag to avoid one-frame disappearance before overlay draws
    let cutoutOverlayHasCurrent = false;
    let cutoutMoveOverlayCanvas = null;
    let cutoutMoveOverlayCtx = null;
    let cutoutDragBaseCanvas = null;
    let cutoutDragBaseCtx = null;
    let cutoutIsDraggingObj = false;
    let cutoutIsRotatingObj = false;
    let cutoutIsResizingObj = false;
    let cutoutIsDraggingPivot = false;
    let cutoutResizeCorner = '';
    let cutoutResizeStartX = 0, cutoutResizeStartY = 0, cutoutResizeStartScale = 1;
    let cutoutResizeStartWidth = 0, cutoutResizeStartHeight = 0;
    let cutoutResizeStartPosX = 0, cutoutResizeStartPosY = 0;
    // Cutout zoom level for wheel zoom
    let cutoutZoomLevel = 1;
    // Pan offsets (CSS translate) so zoom can pivot around cursor
    let cutoutPanX = 0, cutoutPanY = 0;
    // Recorder state: playing (recording) vs paused (armed for keying)
    let cutoutRecorderIsPlaying = false;
    let cutoutRecorderArmed = true; // true when paused
    let cutoutRecordRAF = null;
    let cutoutRecordStartTime = 0;
    let cutoutRecordStartTs = 0;
    let isDraggingRecTime = false;
    let recDragStartX = 0;
    let recDragStartTime = 0;
    // Dragging X/Y value fields
    let isDraggingPosX = false, isDraggingPosY = false;
    let posDragStartMouseX = 0;
    let posDragStartValue = 0;
    // Cutout resize (center-preserving uniform scale)
    let cutoutResizeStartCenterX = 0, cutoutResizeStartCenterY = 0;
    let cutoutResizeStartScaleX = 1, cutoutResizeStartScaleY = 1;
    let cutoutResizeStartMouseDist = 1;
    let cutoutResizeBaseW = 0, cutoutResizeBaseH = 0;
    let cutoutResizeObjScale = 1;
    // Track pivot ratio at resize start to scale proportionally
    let cutoutResizeStartPivotRatioX = 0.5, cutoutResizeStartPivotRatioY = 0.5;
    let cutoutResizeHasPivot = false;
    // Dragging Zoom value fields (X or Y adjusts both simultaneously)
    let isDraggingZoom = false;
    let zoomDragStartMouseX = 0;
    let zoomDragStartValueX = 1;
    let zoomDragStartValueY = 1;
    let zoomDragStartCenterX = 0, zoomDragStartCenterY = 0;
    let zoomDragBaseW = 0, zoomDragBaseH = 0;
    let zoomDragObjScale = 1;
    // Buffer key updates during drags and commit once on release to reduce per-move churn
    let cutoutPendingDragKeys = { position: null, rotation: null, zoom: null, opacity: null };
    // Detect click vs drag on property keys (diamonds)
    let propKeyDragDidMove = false;
    // Throttle cutout preview redraws during brush moves to one per animation frame
    let cutoutPreviewRaf = null;
    // Active layer selection for Cut Out mode (0-based). Lasso and merges operate only on this layer.
    let cutoutActiveLayerIndex = 0;
    function scheduleCutoutPreviewForTime() {
      if (cutoutPreviewRaf != null) return;
      cutoutPreviewRaf = requestAnimationFrame(() => {
        cutoutPreviewRaf = null;
        renderCutoutPreviewForTime();
      });
    }
    
    function cutoutCreateSelectionFromPolygon() {
      const activeIdx = selectedCutoutClipIndex >= 0 ? selectedCutoutClipIndex : getActiveCutoutClipIndexAt(cutoutCurrentTime);
      if (activeIdx < 0) return;
      const clip = cutoutClips[activeIdx];
      if (!clip || !clip.canvas || magicLassoPoints.length < 3) return;
      // Helper: compute polygon bbox
      const polyBounds = (() => {
        let polyMinX = Infinity, polyMinY = Infinity, polyMaxX = -Infinity, polyMaxY = -Infinity;
        for (const p of magicLassoPoints) {
          if (p[0] < polyMinX) polyMinX = p[0];
          if (p[1] < polyMinY) polyMinY = p[1];
          if (p[0] > polyMaxX) polyMaxX = p[0];
          if (p[1] > polyMaxY) polyMaxY = p[1];
        }
        return { x: polyMinX, y: polyMinY, r: polyMaxX, b: polyMaxY };
      })();
      // First: if polygon intersects an image object, perform "image breakaway" (bake transform)
      try {
        const objects = Array.isArray(clip.objects) ? clip.objects : [];
        const onActiveLayer = (o) => ((Number.isFinite(o.layerIndex) ? o.layerIndex : 0) === cutoutActiveLayerIndex);
        let hitImage = null;
        // Build polygon mask once and prefer top-most pixel-overlap hit
        const testCanvas = document.createElement('canvas');
        testCanvas.width = cutoutCanvas.width;
        testCanvas.height = cutoutCanvas.height;
        const tctx = testCanvas.getContext('2d', { willReadFrequently: true });
        const polyMask = document.createElement('canvas');
        polyMask.width = testCanvas.width;
        polyMask.height = testCanvas.height;
        const pmx = polyMask.getContext('2d');
        pmx.save();
        pmx.beginPath();
        pmx.moveTo(magicLassoPoints[0][0], magicLassoPoints[0][1]);
        for (let i = 1; i < magicLassoPoints.length; i++) pmx.lineTo(magicLassoPoints[i][0], magicLassoPoints[i][1]);
        pmx.closePath();
        pmx.fillStyle = '#fff';
        pmx.fill();
        pmx.restore();
        // Filter candidates by AABB first for speed
        const candidates = objects.filter(o => o && o.isImage && onActiveLayer(o) && (function intersects(o) {
          const baseW = (o.drawW != null) ? o.drawW : ((o.img && (o.img.naturalWidth || o.img.width || o.img.videoWidth)) || 0);
          const baseH = (o.drawH != null) ? o.drawH : ((o.img && (o.img.naturalHeight || o.img.height || o.img.videoHeight)) || 0);
          const w = baseW * (o.scale || 1) * (o.scaleX || 1);
          const h = baseH * (o.scale || 1) * (o.scaleY || 1);
          const r1 = { x: Math.min(o.x, o.x + w), y: Math.min(o.y, o.y + h), r: Math.max(o.x, o.x + w), b: Math.max(o.y, o.y + h) };
          const r2 = polyBounds;
          return !(r1.r < r2.x || r1.x > r2.r || r1.b < r2.y || r1.y > r2.b);
        })(o));
        // Iterate from top-most to bottom-most: assume later objects are on top
        for (let i = candidates.length - 1; i >= 0; i--) {
          const o = candidates[i];
          tctx.clearRect(0, 0, testCanvas.width, testCanvas.height);
          drawRotatedImage(tctx, o);
          // Apply polygon mask
          tctx.save();
          tctx.globalCompositeOperation = 'destination-in';
          tctx.drawImage(polyMask, 0, 0);
          tctx.restore();
          // Quick alpha presence check in the polygon bbox only
          const bx = Math.max(0, Math.floor(polyBounds.x));
          const by = Math.max(0, Math.floor(polyBounds.y));
          const bw = Math.max(1, Math.ceil(polyBounds.r) - bx);
          const bh = Math.max(1, Math.ceil(polyBounds.b) - by);
          try {
            const data = tctx.getImageData(bx, by, bw, bh).data;
            let found = false;
            for (let k = 3; k < data.length; k += 32) {
              if (data[k] > 0) { found = true; break; }
            }
            if (found) { hitImage = o; break; }
          } catch (_e) { /* ignore read failures */ }
        }
        if (hitImage && hitImage.img) {
          saveState();
          // Render image object to a full-size offscreen with current transform
          const fullW = cutoutCanvas.width, fullH = cutoutCanvas.height;
          const drawOnlyObj = (dstCtx) => {
            dstCtx.clearRect(0,0,fullW,fullH);
            drawRotatedImage(dstCtx, hitImage);
          };
          const makeMaskClip = (ctx) => {
            ctx.save();
            ctx.beginPath();
            ctx.moveTo(magicLassoPoints[0][0], magicLassoPoints[0][1]);
            for (let i = 1; i < magicLassoPoints.length; i++) ctx.lineTo(magicLassoPoints[i][0], magicLassoPoints[i][1]);
            ctx.closePath();
            ctx.clip();
          };
          // Segment canvas (masked region)
          const segFull = document.createElement('canvas'); segFull.width = fullW; segFull.height = fullH;
          const segCtx = segFull.getContext('2d');
          makeMaskClip(segCtx);
          drawOnlyObj(segCtx);
          segCtx.restore();
          const bboxFrom = (canvas) => {
            const ctx = canvas.getContext('2d');
            const img = ctx.getImageData(0,0,canvas.width,canvas.height).data;
            let minX = canvas.width, minY = canvas.height, maxX = -1, maxY = -1;
            for (let y = 0; y < canvas.height; y++) {
              for (let x = 0; x < canvas.width; x++) {
                const a = img[(y*canvas.width + x)*4 + 3];
                if (a > 0) { if (x < minX) minX = x; if (x > maxX) maxX = x; if (y < minY) minY = y; if (y > maxY) maxY = y; }
              }
            }
            if (maxX < minX || maxY < minY) return null;
            return { x: minX, y: minY, w: maxX - minX + 1, h: maxY - minY + 1 };
          };
          const segBox = bboxFrom(segFull);
          if (segBox) {
            const segCrop = document.createElement('canvas'); segCrop.width = segBox.w; segCrop.height = segBox.h;
            segCrop.getContext('2d').drawImage(segFull, segBox.x, segBox.y, segBox.w, segBox.h, 0, 0, segBox.w, segBox.h);
            // Remainder canvas (original minus masked region)
            const remFull = document.createElement('canvas'); remFull.width = fullW; remFull.height = fullH;
            const remCtx = remFull.getContext('2d');
            drawOnlyObj(remCtx);
            remCtx.save();
            makeMaskClip(remCtx);
            remCtx.globalCompositeOperation = 'destination-out';
            remCtx.fillStyle = '#000';
            remCtx.fillRect(0,0,fullW,fullH);
            remCtx.restore();
            const remBox = bboxFrom(remFull);
            // Update original image object to remaining portion (or remove if empty)
            if (remBox) {
              const remCrop = document.createElement('canvas'); remCrop.width = remBox.w; remCrop.height = remBox.h;
              remCrop.getContext('2d').drawImage(remFull, remBox.x, remBox.y, remBox.w, remBox.h, 0, 0, remBox.w, remBox.h);
              const newImg = new Image();
              newImg.onload = () => {
                // Preserve the user's reported position values (top-left) by padding the baked remainder
                const oldX = hitImage.x;
                const oldY = hitImage.y;
                const baseW0 = (hitImage && hitImage.drawW != null)
                  ? hitImage.drawW
                  : ((hitImage && hitImage.img && (hitImage.img.naturalWidth || hitImage.img.width || hitImage.img.videoWidth)) || 0);
                const baseH0 = (hitImage && hitImage.drawH != null)
                  ? hitImage.drawH
                  : ((hitImage && hitImage.img && (hitImage.img.naturalHeight || hitImage.img.height || hitImage.img.videoHeight)) || 0);
                const effScaleX0 = (hitImage && typeof hitImage.scaleX === 'number') ? hitImage.scaleX : 1;
                const effScaleY0 = (hitImage && typeof hitImage.scaleY === 'number') ? hitImage.scaleY : 1;
                const oldDrawW = Math.max(1, Math.round(baseW0 * (hitImage.scale || 1) * effScaleX0));
                const oldDrawH = Math.max(1, Math.round(baseH0 * (hitImage.scale || 1) * effScaleY0));
                // Build an aligned canvas the size of the old unrotated draw rect and place the remainder at the proper offset
                const aligned = document.createElement('canvas');
                aligned.width = oldDrawW;
                aligned.height = oldDrawH;
                const actx = aligned.getContext('2d');
                const offsetX = Math.max(0, Math.round(remBox.x - oldX));
                const offsetY = Math.max(0, Math.round(remBox.y - oldY));
                actx.drawImage(newImg, offsetX, offsetY);
                // Swap in aligned remainder; keep x,y unchanged so the UI-reported position remains identical
                hitImage.img = aligned;
                hitImage.src = aligned.toDataURL('image/png');
                hitImage.x = oldX; hitImage.y = oldY;
                hitImage.scale = 1; hitImage.scaleX = 1; hitImage.scaleY = 1; hitImage.rotation = 0;
                hitImage.drawW = aligned.width; hitImage.drawH = aligned.height;
                // We baked transforms into pixels; clear zoom/rotation keys to avoid reapplying scale/rotation
                if (hitImage.keys) {
                  if (Array.isArray(hitImage.keys.zoom)) hitImage.keys.zoom = [];
                  if (Array.isArray(hitImage.keys.rotation)) hitImage.keys.rotation = [];
                }
                // Create new independent image object for the segmented part
                const segImg = new Image();
                segImg.onload = () => {
                  const color = cutoutObjectPalette[Array.isArray(clip.objects) ? clip.objects.length % cutoutObjectPalette.length : 0];
                  const objId = (++cutoutObjectCounter);
                  const newObj = {
                    id: objId, name: `Image ${objId}`, color,
                    img: segImg, src: segCrop.toDataURL('image/png'),
                    layerIndex: hitImage.layerIndex,
                    x: segBox.x, y: segBox.y,
                    scale: 1, scaleX: 1, scaleY: 1, rotation: 0, opacity: hitImage.opacity || 1,
                    drawW: segCrop.width, drawH: segCrop.height,
                isImage: true,
                // Start fresh keys to avoid inheriting any previous zoom/rotation animation
                keys: { position: [], zoom: [], rotation: [], opacity: [] }
                  };
                  if (!Array.isArray(clip.objects)) clip.objects = [];
                  clip.objects.push(newObj);
                  cutoutActiveObject = newObj;
                  cutoutPropertyKeys = newObj.keys;
                  // Seed initial keys at the start of the clip so diamonds appear immediately
                  try {
                    const t0 = Number.isFinite(clip.start) ? clip.start : 0;
                    newObj.keys.position.push({ time: t0, x: newObj.x, y: newObj.y });
                    newObj.keys.zoom.push({ time: t0, sx: newObj.scaleX, sy: newObj.scaleY });
                    newObj.keys.rotation.push({ time: t0, deg: 0 });
                    newObj.keys.opacity.push({ time: t0, value: newObj.opacity });
                    newObj.keys.position.sort((a, b) => a.time - b.time);
                    newObj.keys.zoom.sort((a, b) => a.time - b.time);
                    newObj.keys.rotation.sort((a, b) => a.time - b.time);
                    newObj.keys.opacity.sort((a, b) => a.time - b.time);
                    // Also add current-time keys so transform nodes reflect current values immediately
                    const tNow = cutoutCurrentTime || t0;
                    addOrUpdatePropKeyAt('position', tNow, { x: newObj.x, y: newObj.y });
                    addOrUpdatePropKeyAt('zoom', tNow, { sx: newObj.scaleX, sy: newObj.scaleY });
                    addOrUpdatePropKeyAt('rotation', tNow, { deg: 0 });
                    addOrUpdatePropKeyAt('opacity', tNow, { value: newObj.opacity });
                  } catch (_e) {}
                  // Switch to move/select with this image selected and show handles
                  try { setTool('select'); } catch (_e) {}
                  try {
                    cutoutSelectedObject = newObj;
                    if (typeof cutoutBeginSelectionOverlay === 'function') cutoutBeginSelectionOverlay();
                    if (typeof updateCutoutPositionDisplay === 'function') updateCutoutPositionDisplay(newObj.x, newObj.y);
                    if (typeof updateCutoutZoomDisplay === 'function') updateCutoutZoomDisplay(newObj.scaleX || 1, newObj.scaleY || 1);
                    if (typeof updateCutoutRotationDisplay === 'function') updateCutoutRotationDisplay(0);
                    if (typeof updateCutoutOpacityDisplay === 'function') updateCutoutOpacityDisplay(newObj.opacity || 1);
                  } catch (_e) {}
                  drawCutoutTimeline();
                  renderCutoutPreviewForTime();
                  if (typeof renderCutoutObjectsList === 'function') renderCutoutObjectsList();
                  saveState();
                };
                segImg.src = segCrop.toDataURL('image/png');
              };
              newImg.src = remCrop.toDataURL('image/png');
            } else {
              // Entire image moved into segment; remove original
              const idx = clip.objects.indexOf(hitImage);
              if (idx >= 0) clip.objects.splice(idx, 1);
              const segImg = new Image();
              segImg.onload = () => {
                const color = cutoutObjectPalette[Array.isArray(clip.objects) ? clip.objects.length % cutoutObjectPalette.length : 0];
                const objId = (++cutoutObjectCounter);
                const newObj = {
                  id: objId, name: `Image ${objId}`, color,
                  img: segImg, src: segCrop.toDataURL('image/png'),
                  layerIndex: hitImage.layerIndex,
                  x: segBox.x, y: segBox.y,
                  scale: 1, scaleX: 1, scaleY: 1, rotation: 0, opacity: hitImage.opacity || 1,
                  drawW: segCrop.width, drawH: segCrop.height,
                isImage: true,
                keys: { position: [], zoom: [], rotation: [], opacity: [] }
                };
                if (!Array.isArray(clip.objects)) clip.objects = [];
                clip.objects.push(newObj);
                cutoutActiveObject = newObj;
                cutoutPropertyKeys = newObj.keys;
                // Seed initial keys at the start of the clip and at current time
                try {
                  const t0 = Number.isFinite(clip.start) ? clip.start : 0;
                  newObj.keys.position.push({ time: t0, x: newObj.x, y: newObj.y });
                  newObj.keys.zoom.push({ time: t0, sx: newObj.scaleX, sy: newObj.scaleY });
                  newObj.keys.rotation.push({ time: t0, deg: 0 });
                  newObj.keys.opacity.push({ time: t0, value: newObj.opacity });
                  newObj.keys.position.sort((a, b) => a.time - b.time);
                  newObj.keys.zoom.sort((a, b) => a.time - b.time);
                  newObj.keys.rotation.sort((a, b) => a.time - b.time);
                  newObj.keys.opacity.sort((a, b) => a.time - b.time);
                  const tNow = cutoutCurrentTime || t0;
                  addOrUpdatePropKeyAt('position', tNow, { x: newObj.x, y: newObj.y });
                  addOrUpdatePropKeyAt('zoom', tNow, { sx: newObj.scaleX, sy: newObj.scaleY });
                  addOrUpdatePropKeyAt('rotation', tNow, { deg: 0 });
                  addOrUpdatePropKeyAt('opacity', tNow, { value: newObj.opacity });
                } catch (_e) {}
                try { setTool('select'); } catch (_e) {}
                try {
                  cutoutSelectedObject = newObj;
                  if (typeof cutoutBeginSelectionOverlay === 'function') cutoutBeginSelectionOverlay();
                  if (typeof updateCutoutPositionDisplay === 'function') updateCutoutPositionDisplay(newObj.x, newObj.y);
                  if (typeof updateCutoutZoomDisplay === 'function') updateCutoutZoomDisplay(newObj.scaleX || 1, newObj.scaleY || 1);
                  if (typeof updateCutoutRotationDisplay === 'function') updateCutoutRotationDisplay(0);
                  if (typeof updateCutoutOpacityDisplay === 'function') updateCutoutOpacityDisplay(newObj.opacity || 1);
                } catch (_e) {}
                drawCutoutTimeline();
                renderCutoutPreviewForTime();
                if (typeof renderCutoutObjectsList === 'function') renderCutoutObjectsList();
                saveState();
              };
              segImg.src = segCrop.toDataURL('image/png');
            }
            // Cancel further processing; we handled as image breakaway
            cutoutPendingSelection = false;
            cutoutPendingKeys = null;
            cutoutPendingColor = null;
            return;
          }
        }
      } catch (_e) { /* ignore image breakaway errors */ }
      // First try to re-select an existing object whose center lies within the lasso polygon
      try {
        const objects = Array.isArray(clip.objects) ? clip.objects : [];
        if (objects.length) {
          // Compute polygon bounding box and centroid
          let polyMinX = Infinity, polyMinY = Infinity, polyMaxX = -Infinity, polyMaxY = -Infinity;
          for (const p of magicLassoPoints) {
            if (p[0] < polyMinX) polyMinX = p[0];
            if (p[1] < polyMinY) polyMinY = p[1];
            if (p[0] > polyMaxX) polyMaxX = p[0];
            if (p[1] > polyMaxY) polyMaxY = p[1];
          }
          const centroidX = (polyMinX + polyMaxX) / 2;
          const centroidY = (polyMinY + polyMaxY) / 2;
          // Ray-casting point-in-polygon
          const pointInPoly = (x, y) => {
            let inside = false;
            for (let i = 0, j = magicLassoPoints.length - 1; i < magicLassoPoints.length; j = i++) {
              const xi = magicLassoPoints[i][0], yi = magicLassoPoints[i][1];
              const xj = magicLassoPoints[j][0], yj = magicLassoPoints[j][1];
              const intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / Math.max(1e-6, (yj - yi)) + xi);
              if (intersect) inside = !inside;
            }
            return inside;
          };
          // Find matches whose center is inside polygon
          const matches = [];
          for (const obj of objects) {
            // Do not allow merging into Background objects; they are exempt from lasso-merge
            if (obj && obj.isBackground) continue;
            // Do not reselect or merge into Image objects via select-lasso
            if (obj && obj.isImage) continue;
            // Only consider objects on the active layer
            const objLayer = Number.isFinite(obj.layerIndex) ? obj.layerIndex : 0;
            if (objLayer !== cutoutActiveLayerIndex) continue;
            const objScaleX = (obj && typeof obj.scaleX === 'number') ? obj.scaleX : 1;
            const objScaleY = (obj && typeof obj.scaleY === 'number') ? obj.scaleY : 1;
            const baseW = (obj && obj.drawW != null) ? obj.drawW : ((obj && obj.img && (obj.img.naturalWidth || obj.img.width || obj.img.videoWidth)) || 0);
            const baseH = (obj && obj.drawH != null) ? obj.drawH : ((obj && obj.img && (obj.img.naturalHeight || obj.img.height || obj.img.videoHeight)) || 0);
            const w = baseW * (obj.scale || 1) * objScaleX;
            const h = baseH * (obj.scale || 1) * objScaleY;
            const cx = obj.x + w / 2;
            const cy = obj.y + h / 2;
            if (pointInPoly(cx, cy)) {
              const dx = cx - centroidX, dy = cy - centroidY;
              const dist2 = dx * dx + dy * dy;
              matches.push({ obj, dist2 });
            }
          }
          if (matches.length) {
            matches.sort((a, b) => a.dist2 - b.dist2);
            const picked = matches[0].obj;
            // If picked is not on active layer, skip merging (safety, though we filtered above)
            if ((Number.isFinite(picked.layerIndex) ? picked.layerIndex : 0) !== cutoutActiveLayerIndex) {
              // fall through to create new object
            } else {
            // Merge any new drawing inside the lasso into the picked object
            try {
              saveState();
              const baseCanvas = clip.canvas;
              const baseCtx = clip.ctx;
              // Compute union bbox of object and polygon
              const imgW = (picked && picked.img && (picked.img.naturalWidth || picked.img.width || 0)) || 0;
              const imgH = (picked && picked.img && (picked.img.naturalHeight || picked.img.height || 0)) || 0;
              const objRect = { x: picked.x, y: picked.y, r: picked.x + imgW, b: picked.y + imgH };
              const polyRect = { x: polyMinX, y: polyMinY, r: polyMaxX, b: polyMaxY };
              const union = {
                x: Math.floor(Math.min(objRect.x, polyRect.x)),
                y: Math.floor(Math.min(objRect.y, polyRect.y)),
                r: Math.ceil(Math.max(objRect.r, polyRect.r)),
                b: Math.ceil(Math.max(objRect.b, polyRect.b))
              };
              const newW = Math.max(1, union.r - union.x);
              const newH = Math.max(1, union.b - union.y);
              const merged = document.createElement('canvas');
              merged.width = newW;
              merged.height = newH;
              const mctx = merged.getContext('2d');
              // Draw existing object image at its relative offset
              if (picked && picked.img) {
                const ox = picked.x - union.x;
                const oy = picked.y - union.y;
                mctx.drawImage(picked.img, ox, oy);
              }
              // Draw new drawing content from base within polygon
              mctx.save();
              mctx.translate(-union.x, -union.y);
              pathFromPoints(mctx, magicLassoPoints);
              mctx.clip();
              mctx.drawImage(baseCanvas, 0, 0);
              mctx.restore();
              // Clear the newly captured polygon area from the base so it doesn't duplicate
              baseCtx.save();
              pathFromPoints(baseCtx, magicLassoPoints);
              baseCtx.clip();
              baseCtx.clearRect(0, 0, baseCanvas.width, baseCanvas.height);
              baseCtx.restore();
              // Update picked object's bitmap and rect
              const dataUrl = merged.toDataURL('image/png');
              // Immediately update object to merged canvas to avoid flicker before image load
              picked.img = merged; // Canvas is valid for drawImage
              picked.src = dataUrl;
              picked.drawW = merged.width;
              picked.drawH = merged.height;
              picked.x = union.x;
              picked.y = union.y;
              renderCutoutPreviewForTime();
              // Also kick async Image load to normalize to Image element for future ops
              const newImg = new Image();
              newImg.onload = () => {
                // Swap in Image after it loads
                picked.img = newImg;
                // Ensure preview reflects final image
                renderCutoutPreviewForTime();
                renderCutoutClips();
                if (typeof renderCutoutObjectsList === 'function') renderCutoutObjectsList();
              };
              newImg.src = dataUrl;
              saveState();
            } catch (_e) {
              // If merge fails, continue with simple reselect
            }
            // Select this object and pop up movement nodes/overlay
            cutoutActiveObject = picked;
            cutoutSelectedObject = picked;
            // Cancel any pending selection staging
            cutoutPendingSelection = false;
            cutoutPendingKeys = null;
            cutoutPendingColor = null;
            // Bind timeline keys to object
            cutoutPropertyKeys = picked.keys || (picked.keys = { position: [], zoom: [], rotation: [], opacity: [] });
            // Build overlay for handles
            cutoutBeginSelectionOverlay();
            updateCutoutPositionDisplay(picked.x, picked.y);
            updateCutoutZoomDisplay(picked.scaleX || 1, picked.scaleY || 1);
            const deg = ((picked.rotation || 0) * 180) / Math.PI;
            updateCutoutRotationDisplay(deg);
            updateCutoutOpacityDisplay((typeof picked.opacity === 'number') ? picked.opacity : 1);
            if (typeof drawCutoutTimeline === 'function') drawCutoutTimeline();
            if (typeof updateRowKeyActiveStates === 'function') updateRowKeyActiveStates();
            if (typeof renderCutoutObjectsList === 'function') renderCutoutObjectsList();
            return; // Do not create a new object
            }
          }
        }
      } catch (_e) { /* ignore selection-from-existing errors */ }
      // Build mask and crop for a new object selection
      const baseCanvas = clip.canvas;
      const baseCtx = clip.ctx;
      const maskCanvas = document.createElement('canvas');
      maskCanvas.width = baseCanvas.width;
      maskCanvas.height = baseCanvas.height;
      const maskCtx = maskCanvas.getContext('2d');
      maskCtx.save();
      pathFromPoints(maskCtx, magicLassoPoints);
      maskCtx.clip();
      maskCtx.drawImage(baseCanvas, 0, 0);
      maskCtx.restore();
      // bbox
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      for (const p of magicLassoPoints) { if (p[0] < minX) minX = p[0]; if (p[1] < minY) minY = p[1]; if (p[0] > maxX) maxX = p[0]; if (p[1] > maxY) maxY = p[1]; }
      minX = Math.max(0, Math.floor(minX));
      minY = Math.max(0, Math.floor(minY));
      maxX = Math.min(baseCanvas.width, Math.ceil(maxX));
      maxY = Math.min(baseCanvas.height, Math.ceil(maxY));
      const selW = Math.max(1, maxX - minX);
      const selH = Math.max(1, maxY - minY);
      const cropped = document.createElement('canvas');
      cropped.width = selW; cropped.height = selH;
      const croppedCtx = cropped.getContext('2d');
      croppedCtx.drawImage(maskCanvas, minX, minY, selW, selH, 0, 0, selW, selH);
      // Validate that selection contains visible pixels; if empty, abort without altering base
      try {
        const imgData = croppedCtx.getImageData(0, 0, selW, selH).data;
        let hasContent = false;
        // Scan with stride to optimize
        for (let i = 3; i < imgData.length; i += 16) {
          if (imgData[i] > 0) { hasContent = true; break; }
        }
        if (!hasContent) {
          // No visible pixels selected; do not create selection
          return;
        }
      } catch (_e) { /* ignore validation errors, continue */ }
      // clear original within polygon
      baseCtx.save();
      pathFromPoints(baseCtx, magicLassoPoints);
      baseCtx.clip();
      baseCtx.clearRect(0, 0, baseCanvas.width, baseCanvas.height);
      baseCtx.restore();
      const src = cropped.toDataURL('image/png');
      const img = new Image();
      img.onload = () => {
        // Create an object immediately so it appears in Objects Created right away
        if (!Array.isArray(clip.objects)) clip.objects = [];
        const objId = (++cutoutObjectCounter);
        const color = cutoutObjectPalette[clip.objects.length % cutoutObjectPalette.length];
        const newObj = {
          id: objId,
          name: `Object ${objId}`,
          color,
          src,
          img,
          layerIndex: Number.isFinite(cutoutActiveLayerIndex) ? cutoutActiveLayerIndex : 0,
          x: minX,
          y: minY,
          scale: 1,
          scaleX: 1,
          scaleY: 1,
          rotation: 0,
          opacity: 1,
          drawW: cropped.width,
          drawH: cropped.height,
          keys: { position: [], zoom: [], rotation: [], opacity: [] }
        };
        clip.objects.push(newObj);
        cutoutActiveObject = newObj;
        cutoutSelectedObject = newObj;
        // Bind timeline keys to this object's keys immediately
        cutoutPropertyKeys = newObj.keys;
        // Seed initial keys at the start of the clip so icons show color at frame start
        const t0 = Number.isFinite(clip.start) ? clip.start : 0;
        newObj.keys.position.push({ time: t0, x: newObj.x, y: newObj.y });
        newObj.keys.zoom.push({ time: t0, sx: newObj.scaleX, sy: newObj.scaleY });
        newObj.keys.rotation.push({ time: t0, deg: 0 });
        newObj.keys.opacity.push({ time: t0, value: newObj.opacity });
        // Keep arrays sorted
        newObj.keys.position.sort((a, b) => a.time - b.time);
        newObj.keys.zoom.sort((a, b) => a.time - b.time);
        newObj.keys.rotation.sort((a, b) => a.time - b.time);
        newObj.keys.opacity.sort((a, b) => a.time - b.time);
        // Begin selection overlay with this object and update displays
        cutoutBeginSelectionOverlay();
        updateCutoutPositionDisplay(newObj.x, newObj.y);
        updateCutoutZoomDisplay(newObj.scaleX || 1, newObj.scaleY || 1);
        updateCutoutRotationDisplay(0);
        updateCutoutOpacityDisplay(1);
        // If recorder is armed, seed initial keys now
        if (cutoutRecorderArmed) {
          const t = cutoutCurrentTime || 0;
          addOrUpdatePropKeyAt('position', t, { x: newObj.x, y: newObj.y });
          addOrUpdatePropKeyAt('zoom', t, { sx: newObj.scaleX, sy: newObj.scaleY });
          addOrUpdatePropKeyAt('rotation', t, { deg: 0 });
          addOrUpdatePropKeyAt('opacity', t, { value: newObj.opacity });
          drawCutoutTimeline();
          updateRowKeyActiveStates();
        }
        if (typeof renderCutoutObjectsList === 'function') renderCutoutObjectsList();
        if (typeof renderCutoutLayersPanel === 'function') renderCutoutLayersPanel();
        drawCutoutTimeline();
        updateRowKeyActiveStates();
      };
      img.src = src;
    }
    
    function cutoutBeginSelectionOverlay() {
      const container = document.getElementById('cutout-canvas-container');
      if (!container || !cutoutCanvas) return;
      // base canvas: draw current clip content (without selection)
      cutoutDragBaseCanvas = document.createElement('canvas');
      cutoutDragBaseCanvas.width = cutoutCanvas.width;
      cutoutDragBaseCanvas.height = cutoutCanvas.height;
      cutoutDragBaseCtx = cutoutDragBaseCanvas.getContext('2d');
      const idx = getActiveCutoutClipIndexAt(cutoutCurrentTime);
      if (idx >= 0 && cutoutClips[idx]) {
        const clipObj = cutoutClips[idx];
        if (clipObj.canvas) {
          // Base layer (brush drawings)
          cutoutDragBaseCtx.drawImage(clipObj.canvas, 0, 0);
        }
        // Draw all non-selected objects to the base to avoid flicker on selection switch
        const objs = Array.isArray(clipObj.objects) ? clipObj.objects.slice() : [];
        // Draw only objects that should appear BELOW the selected, from back to front
        objs.sort((a, b) => {
          const ai = Number.isFinite(a && a.layerIndex) ? a.layerIndex : 0;
          const bi = Number.isFinite(b && b.layerIndex) ? b.layerIndex : 0;
          if (ai !== bi) return bi - ai; // higher index first (bottom)
          const aid = (a && a.id != null) ? a.id : 0;
          const bid = (b && b.id != null) ? b.id : 0;
          return aid - bid; // lower id first, higher id later (on top)
        });
        for (const obj of objs) {
          if (!obj || !obj.img) continue;
          // Skip those that should be above selected; draw only below
          if (cutoutSelectedObject) {
            const sel = cutoutSelectedObject;
            const oi = Number.isFinite(obj.layerIndex) ? obj.layerIndex : 0;
            const si = Number.isFinite(sel.layerIndex) ? sel.layerIndex : 0;
            const oid = (obj.id != null) ? obj.id : 0;
            const sid = (sel.id != null) ? sel.id : 0;
            const above = (oi < si) || (oi === si && oid > sid);
            if (above) continue;
            // Skip selected itself
            if (obj === sel || (obj.id != null && sel.id != null && obj.id === sel.id)) continue;
          }
          drawRotatedImage(cutoutDragBaseCtx, obj);
        }
      }
      if (cutoutMoveOverlayCanvas) cutoutMoveOverlayCanvas.remove();
      cutoutMoveOverlayCanvas = document.createElement('canvas');
      cutoutMoveOverlayCanvas.width = cutoutCanvas.width;
      cutoutMoveOverlayCanvas.height = cutoutCanvas.height;
      cutoutMoveOverlayCanvas.style.position = 'absolute';
      cutoutMoveOverlayCanvas.style.top = '0';
      cutoutMoveOverlayCanvas.style.left = '0';
      cutoutMoveOverlayCanvas.style.width = '100%';
      cutoutMoveOverlayCanvas.style.height = '100%';
      cutoutMoveOverlayCanvas.style.pointerEvents = 'auto';
      cutoutMoveOverlayCanvas.style.zIndex = '1002';
      cutoutMoveOverlayCtx = cutoutMoveOverlayCanvas.getContext('2d');
      const cs = window.getComputedStyle(container);
      if (cs.position === 'static') container.style.position = 'relative';
      container.appendChild(cutoutMoveOverlayCanvas);
      cutoutMoveOverlayCanvas.addEventListener('mousedown', cutoutSelectionMouseDown);
      window.addEventListener('mouseup', cutoutSelectionMouseUp);
      window.addEventListener('mousemove', cutoutSelectionMouseMove);
      // Commit selection when clicking outside the canvas container
      document.addEventListener('mousedown', cutoutOutsideClickCommit, true);
      // Reset overlay readiness; render will set it true once drawn
      cutoutOverlayHasCurrent = false;
      cutoutRenderSelectionOverlay();
      // Ensure overlay scales with current cutout zoom immediately
      if (typeof applyCutoutZoomTransforms === 'function') applyCutoutZoomTransforms();
    }
    
    function cutoutRenderSelectionOverlay() {
      if (!cutoutMoveOverlayCtx || !cutoutMoveOverlayCanvas) return;
      cutoutMoveOverlayCtx.clearRect(0, 0, cutoutMoveOverlayCanvas.width, cutoutMoveOverlayCanvas.height);
      // Do not draw base content here; the underlying preview already renders
      // all non-selected content in proper Z-order, and drawing base here would
      // occlude objects that should appear above the selection.
      if (cutoutSelectedObject) {
        // Draw the selected image on overlay only during active interaction; otherwise, only draw handles.
        const isInteracting = !!(cutoutIsDraggingObj || cutoutIsResizingObj || cutoutIsRotatingObj);
        if (isInteracting) {
          drawRotatedImage(cutoutMoveOverlayCtx, cutoutSelectedObject);
        }
        if (currentTool === 'select' || currentTool === 'select-lasso') {
          drawResizeHandles(cutoutMoveOverlayCtx, cutoutSelectedObject);
        }
        // Mark overlay as ready with current object drawn
        cutoutOverlayHasCurrent = true;
      } else {
        cutoutOverlayHasCurrent = false;
      }
    }
    
    function cutoutCommitSelection() {
      if (!cutoutSelectedObject) return;
      let activeIdx = selectedCutoutClipIndex >= 0 ? selectedCutoutClipIndex : getActiveCutoutClipIndexAt(cutoutCurrentTime);
      // Ensure a clip exists so committing never discards the dropped image
      if (activeIdx < 0) {
        try { cutoutCreateClipSnapshot(); } catch (_e) {}
        activeIdx = cutoutClips.length - 1;
        selectedCutoutClipIndex = activeIdx;
      }
      const clip = cutoutClips[activeIdx];
      if (clip) {
        // Persist selection: update existing object if reselecting, else create new
        saveState();
        if (!Array.isArray(clip.objects)) clip.objects = [];
        const existingIdx = (cutoutSelectedObject.id != null)
          ? clip.objects.findIndex(o => o && o.id === cutoutSelectedObject.id)
          : -1;
        if (existingIdx >= 0) {
          // Update existing object transforms (no duplicate)
          const obj = clip.objects[existingIdx];
          obj.x = cutoutSelectedObject.x;
          obj.y = cutoutSelectedObject.y;
          if (Number.isFinite(cutoutSelectedObject.layerIndex)) {
            obj.layerIndex = cutoutSelectedObject.layerIndex;
          }
          obj.scale = cutoutSelectedObject.scale || 1;
          obj.scaleX = (typeof cutoutSelectedObject.scaleX === 'number') ? cutoutSelectedObject.scaleX : 1;
          obj.scaleY = (typeof cutoutSelectedObject.scaleY === 'number') ? cutoutSelectedObject.scaleY : 1;
          obj.rotation = cutoutSelectedObject.rotation || 0;
          obj.opacity = (typeof cutoutSelectedObject.opacity === 'number') ? cutoutSelectedObject.opacity : 1;
          obj.drawW = cutoutSelectedObject.drawW;
          obj.drawH = cutoutSelectedObject.drawH;
          if (cutoutSelectedObject.isImage) obj.isImage = true;
          // Preserve pivot and handle distance
          if (typeof cutoutSelectedObject.pivotLocalX === 'number') obj.pivotLocalX = cutoutSelectedObject.pivotLocalX;
          if (typeof cutoutSelectedObject.pivotLocalY === 'number') obj.pivotLocalY = cutoutSelectedObject.pivotLocalY;
          if (typeof cutoutSelectedObject.rotationHandleDistance === 'number') obj.rotationHandleDistance = cutoutSelectedObject.rotationHandleDistance;
          // Merge any pending keys (if present) into object's keys
          if (cutoutPendingSelection && cutoutPendingKeys && obj.keys) {
            const mergeArr = (dst, src, key) => {
              if (!Array.isArray(src)) return;
              // Simple merge, then sort by time, de-dup by time epsilon
              const epsilon = 1 / 60;
              const out = dst.concat(src);
              out.sort((a, b) => a.time - b.time);
              const dedup = [];
              for (const k of out) {
                if (!dedup.length || Math.abs(dedup[dedup.length - 1].time - k.time) > epsilon) dedup.push(k);
                else dedup[dedup.length - 1] = k;
              }
              return dedup;
            };
            obj.keys.position = mergeArr(obj.keys.position || [], cutoutPendingKeys.position, 'position') || obj.keys.position;
            obj.keys.zoom = mergeArr(obj.keys.zoom || [], cutoutPendingKeys.zoom, 'zoom') || obj.keys.zoom;
            obj.keys.rotation = mergeArr(obj.keys.rotation || [], cutoutPendingKeys.rotation, 'rotation') || obj.keys.rotation;
            obj.keys.opacity = mergeArr(obj.keys.opacity || [], cutoutPendingKeys.opacity, 'opacity') || obj.keys.opacity;
          }
          cutoutActiveObject = obj;
          cutoutPropertyKeys = obj.keys || (obj.keys = { position: [], zoom: [], rotation: [], opacity: [] });
          // No re-seeding keys for existing object here
        } else {
          const color = cutoutPendingColor || cutoutObjectPalette[clip.objects.length % cutoutObjectPalette.length];
          const objId = (++cutoutObjectCounter);
          const newObj = {
            id: objId,
            name: (cutoutSelectedObject.isImage ? `Image ${objId}` : `Object ${objId}`),
            color,
            src: cutoutSelectedObject.src,
            img: cutoutSelectedObject.img,
            layerIndex: Number.isFinite(cutoutSelectedObject.layerIndex) ? cutoutSelectedObject.layerIndex : 1,
            x: cutoutSelectedObject.x,
            y: cutoutSelectedObject.y,
            scale: cutoutSelectedObject.scale || 1,
            scaleX: (typeof cutoutSelectedObject.scaleX === 'number') ? cutoutSelectedObject.scaleX : 1,
            scaleY: (typeof cutoutSelectedObject.scaleY === 'number') ? cutoutSelectedObject.scaleY : 1,
            rotation: cutoutSelectedObject.rotation || 0,
            opacity: (typeof cutoutSelectedObject.opacity === 'number') ? cutoutSelectedObject.opacity : 1,
            drawW: cutoutSelectedObject.drawW,
            drawH: cutoutSelectedObject.drawH,
            isImage: !!cutoutSelectedObject.isImage,
            pivotLocalX: (typeof cutoutSelectedObject.pivotLocalX === 'number') ? cutoutSelectedObject.pivotLocalX : undefined,
            pivotLocalY: (typeof cutoutSelectedObject.pivotLocalY === 'number') ? cutoutSelectedObject.pivotLocalY : undefined,
            rotationHandleDistance: (typeof cutoutSelectedObject.rotationHandleDistance === 'number') ? cutoutSelectedObject.rotationHandleDistance : undefined,
            keys: (cutoutPendingKeys && cutoutPendingSelection) ? cutoutPendingKeys : { position: [], zoom: [], rotation: [], opacity: [] }
          };
          clip.objects.push(newObj);
          cutoutActiveObject = newObj;
          cutoutPropertyKeys = newObj.keys;
          if (cutoutRecorderArmed) {
            const t = cutoutCurrentTime || 0;
            addOrUpdatePropKeyAt('position', t, { x: newObj.x, y: newObj.y });
            addOrUpdatePropKeyAt('zoom', t, { sx: newObj.scaleX, sy: newObj.scaleY });
            addOrUpdatePropKeyAt('rotation', t, { deg: 0 });
            addOrUpdatePropKeyAt('opacity', t, { value: newObj.opacity });
          }
        }
        drawCutoutTimeline();
        updateRowKeyActiveStates();
        if (typeof renderCutoutObjectsList === 'function') renderCutoutObjectsList();
        saveState();
        // Clear pending selection state
        cutoutPendingSelection = false;
        cutoutPendingKeys = null;
        cutoutPendingColor = null;
      }
      // Tear down overlay and selection
      cutoutSelectedObject = null;
      if (cutoutMoveOverlayCanvas) {
        cutoutMoveOverlayCanvas.remove();
        cutoutMoveOverlayCanvas = null;
        cutoutMoveOverlayCtx = null;
      }
      cutoutOverlayHasCurrent = false;
      // Ensure selection overlay listeners are removed to avoid extra mousemove work
      try {
        window.removeEventListener('mousemove', cutoutSelectionMouseMove);
        window.removeEventListener('mouseup', cutoutSelectionMouseUp);
      } catch (_e) {}
      cutoutDragBaseCanvas = null;
      cutoutDragBaseCtx = null;
      document.removeEventListener('mousedown', cutoutOutsideClickCommit, true);
      renderCutoutPreviewForTime();
      clearCutoutPositionDisplay();
      clearCutoutZoomDisplay();
      clearCutoutRotationDisplay();
      clearCutoutOpacityDisplay();
    }
    
    // Cancel selection overlay without committing to the clip
    function cutoutCancelSelectionOverlay() {
      // Tear down overlay and selection without drawing to underlying clip
      cutoutSelectedObject = null;
      if (cutoutMoveOverlayCanvas) {
        cutoutMoveOverlayCanvas.remove();
        cutoutMoveOverlayCanvas = null;
        cutoutMoveOverlayCtx = null;
      }
    // Ensure selection overlay listeners are removed to avoid extra mousemove work
    try {
      window.removeEventListener('mousemove', cutoutSelectionMouseMove);
      window.removeEventListener('mouseup', cutoutSelectionMouseUp);
    } catch (_e) {}
      cutoutDragBaseCanvas = null;
      cutoutDragBaseCtx = null;
      document.removeEventListener('mousedown', cutoutOutsideClickCommit, true);
      renderCutoutPreviewForTime();
      clearCutoutPositionDisplay();
      clearCutoutZoomDisplay();
      clearCutoutRotationDisplay();
      clearCutoutOpacityDisplay();
      // Clear pending selection keys if any (do not persist uncommitted keys)
      if (cutoutPendingSelection) {
        cutoutPendingSelection = false;
        cutoutPendingKeys = null;
        cutoutPendingColor = null;
        // Re-bind property keys to active object if present
        const idx = getActiveCutoutClipIndexAt(cutoutCurrentTime);
        if (idx >= 0) {
          const c = cutoutClips[idx];
          const obj = cutoutActiveObject || (Array.isArray(c.objects) ? c.objects[0] : null);
          if (obj && obj.keys) cutoutPropertyKeys = obj.keys;
        }
      }
    }
    
    function renderCutoutObjectsList() {
      const list = document.getElementById('cutout-objects-list');
      if (!list) return;
      list.innerHTML = '';
      const idx = (typeof selectedCutoutClipIndex === 'number' && selectedCutoutClipIndex >= 0) ? selectedCutoutClipIndex : getActiveCutoutClipIndexAt(cutoutCurrentTime);
      if (idx < 0) return;
      const clip = cutoutClips[idx];
      const objects = Array.isArray(clip && clip.objects) ? clip.objects : [];
      objects.forEach((obj) => {
        const row = document.createElement('div');
        row.style.display = 'flex';
        row.style.alignItems = 'center';
        row.style.gap = '8px';
        row.style.padding = '4px 6px';
        // Highlight active object; otherwise emphasize objects on the active layer
        const isActiveObj = (obj === cutoutActiveObject);
        const isOnActiveLayer = ((Number.isFinite(obj.layerIndex) ? obj.layerIndex : 0) === cutoutActiveLayerIndex);
        row.style.border = `1px solid ${isActiveObj ? (obj.color || '#6366f1') : (isOnActiveLayer ? '#6366f1' : '#2a2a2a')}`;
        row.style.borderRadius = '6px';
        row.style.cursor = 'pointer';
        // Keep content LTR inside a right-starting grid
        row.style.direction = 'ltr';
        row.setAttribute('draggable', 'true');
        row.addEventListener('dragstart', (e) => {
          try {
            e.dataTransfer.setData('text/plain', String(obj.id));
          } catch (_e) {}
          e.dataTransfer.dropEffect = 'move';
          e.dataTransfer.effectAllowed = 'copyMove';
        });
        // Allow dropping another object row onto this row to merge objects
        row.addEventListener('dragover', (e) => {
          e.preventDefault();
          e.stopPropagation();
          row.style.boxShadow = `0 0 0 1px ${obj.color || '#6366f1'} inset`;
        });
        row.addEventListener('dragleave', () => {
          row.style.boxShadow = '';
        });
        row.addEventListener('drop', (e) => {
          e.preventDefault();
          e.stopPropagation();
          row.style.boxShadow = '';
          const idStr = e.dataTransfer.getData('text/plain') || e.dataTransfer.getData('text/uri-list') || e.dataTransfer.getData('text');
          const sourceId = parseInt(idStr, 10);
          if (!Number.isFinite(sourceId)) return;
          const source = objects.find(o => o && o.id === sourceId);
          const target = obj;
          if (!source || !target || source === target) return;
          // Only merge within same clip and layer for predictability
          const srcLayer = Number.isFinite(source.layerIndex) ? source.layerIndex : 0;
          const tgtLayer = Number.isFinite(target.layerIndex) ? target.layerIndex : 0;
          if (srcLayer !== tgtLayer) return;
          try { saveState(); } catch (_e) {}
          try {
            mergeCutoutObjectsWithinClip(clip, source, target);
            if (typeof renderCutoutObjectsList === 'function') renderCutoutObjectsList();
            renderCutoutPreviewForTime();
            renderCutoutClips && renderCutoutClips();
          } catch (_e) {}
        });
        row.addEventListener('click', () => {
          // Selecting an object also sets the active layer to that object's layer
          if (Number.isFinite(obj.layerIndex)) {
            cutoutActiveLayerIndex = obj.layerIndex;
            if (typeof renderCutoutLayersPanel === 'function') renderCutoutLayersPanel();
          }
          cutoutActiveObject = obj;
          cutoutPropertyKeys = obj.keys || (obj.keys = { position: [], zoom: [], rotation: [], opacity: [] });
          // Set selection to the object for transform overlay
          cutoutSelectedObject = obj;
          cutoutBeginSelectionOverlay();
          drawCutoutTimeline();
          renderCutoutObjectsList();
          if (typeof renderCutoutLayersPanel === 'function') renderCutoutLayersPanel();
        });
        const thumb = document.createElement('div');
        thumb.style.width = '24px';
        thumb.style.height = '24px';
        thumb.style.borderRadius = '4px';
        thumb.style.overflow = 'hidden';
        thumb.style.border = `2px solid ${obj.color || '#6366f1'}`;
        const img = document.createElement('img');
        img.src = obj.src;
        img.style.width = '100%';
        img.style.height = '100%';
        img.style.objectFit = 'cover';
        thumb.appendChild(img);
        const label = document.createElement('div');
        label.textContent = obj.name || `Object ${obj.id || '?'}`;
        label.style.fontSize = '12px';
        label.style.color = '#e5e7eb';
        row.appendChild(thumb);
        row.appendChild(label);
        list.appendChild(row);
      });
    }
    
    // Merge two objects within the same clip by baking their bitmaps and keys.
    // The resulting object retains the lower id; the higher id object is removed.
    function mergeCutoutObjectsWithinClip(clip, a, b) {
      if (!clip || !a || !b) return;
      const keep = (Number.isFinite(a.id) && Number.isFinite(b.id)) ? (a.id <= b.id ? a : b) : a;
      const drop = (keep === a) ? b : a;
      // Helper to compute rotated AABB corners, matching drawRotatedImage geometry
      const computeRotatedAabb = (obj) => {
        const objScaleX = (obj && typeof obj.scaleX === 'number') ? obj.scaleX : 1;
        const objScaleY = (obj && typeof obj.scaleY === 'number') ? obj.scaleY : 1;
        const baseW = (obj && obj.drawW != null)
          ? obj.drawW
          : ((obj && obj.img && (obj.img.naturalWidth || obj.img.width || obj.img.videoWidth)) || 0);
        const baseH = (obj && obj.drawH != null)
          ? obj.drawH
          : ((obj && obj.img && (obj.img.naturalHeight || obj.img.height || obj.img.videoHeight)) || 0);
        const w = baseW * (obj.scale || 1) * objScaleX;
        const h = baseH * (obj.scale || 1) * objScaleY;
        const cx = obj.x + w / 2;
        const cy = obj.y + h / 2;
        const rot = obj.rotation || 0;
        const rotatePoint = (px, py) => {
          const dx = px - cx, dy = py - cy;
          return { x: cx + dx * Math.cos(rot) - dy * Math.sin(rot), y: cy + dx * Math.sin(rot) + dy * Math.cos(rot) };
        };
        const tl = rotatePoint(obj.x, obj.y);
        const tr = rotatePoint(obj.x + w, obj.y);
        const br = rotatePoint(obj.x + w, obj.y + h);
        const bl = rotatePoint(obj.x, obj.y + h);
        const xs = [tl.x, tr.x, br.x, bl.x];
        const ys = [tl.y, tr.y, br.y, bl.y];
        return {
          x: Math.floor(Math.min(...xs)),
          y: Math.floor(Math.min(...ys)),
          r: Math.ceil(Math.max(...xs)),
          b: Math.ceil(Math.max(...ys))
        };
      };
      const ra = computeRotatedAabb(keep);
      const rb = computeRotatedAabb(drop);
      const union = {
        x: Math.min(ra.x, rb.x),
        y: Math.min(ra.y, rb.y),
        r: Math.max(ra.r, rb.r),
        b: Math.max(ra.b, rb.b)
      };
      const newW = Math.max(1, union.r - union.x);
      const newH = Math.max(1, union.b - union.y);
      const merged = document.createElement('canvas');
      merged.width = newW; merged.height = newH;
      const mctx = merged.getContext('2d', { willReadFrequently: true });
      // Draw both objects into union canvas using drawRotatedImage with offsets
      try { drawRotatedImage(mctx, keep, 1, 1, -union.x, -union.y); } catch (_e) {}
      try { drawRotatedImage(mctx, drop, 1, 1, -union.x, -union.y); } catch (_e) {}
      const dataUrl = merged.toDataURL('image/png');
      // Update keep object to merged
      keep.img = merged;
      keep.src = dataUrl;
      keep.drawW = merged.width;
      keep.drawH = merged.height;
      keep.x = union.x;
      keep.y = union.y;
      // Merge keys across both objects with de-duplication around same time
      const epsilon = 1 / 60;
      const joinKeys = (arr1, arr2, key) => {
        const combined = []
          .concat(Array.isArray(arr1) ? arr1 : [])
          .concat(Array.isArray(arr2) ? arr2 : []);
        combined.sort((a, b) => (a.time || 0) - (b.time || 0));
        const out = [];
        for (const k of combined) {
          if (!out.length || Math.abs((out[out.length - 1].time || 0) - (k.time || 0)) > epsilon) out.push(k);
          else out[out.length - 1] = k;
        }
        return out;
      };
      const aKeys = keep.keys || (keep.keys = { position: [], zoom: [], rotation: [], opacity: [] });
      const bKeys = drop.keys || { position: [], zoom: [], rotation: [], opacity: [] };
      aKeys.position = joinKeys(aKeys.position, bKeys.position, 'position');
      aKeys.zoom = joinKeys(aKeys.zoom, bKeys.zoom, 'zoom');
      aKeys.rotation = joinKeys(aKeys.rotation, bKeys.rotation, 'rotation');
      aKeys.opacity = joinKeys(aKeys.opacity, bKeys.opacity, 'opacity');
      // Reassign any bones attached to drop to point at keep
      try {
        for (let i = 0; i < cutoutBones.length; i++) {
          const bbone = cutoutBones[i];
          if (bbone && bbone.objectRef === drop) {
            bbone.objectRef = keep;
          }
        }
      } catch (_e) {}
      // Remove drop object from clip
      if (Array.isArray(clip.objects)) {
        const idx = clip.objects.indexOf(drop);
        if (idx >= 0) clip.objects.splice(idx, 1);
      }
      // Normalize to an Image element asynchronously
      try {
        const newImg = new Image();
        newImg.onload = () => {
          keep.img = newImg;
          renderCutoutPreviewForTime();
        };
        newImg.src = dataUrl;
      } catch (_e) {}
      // Update selection to merged object
      cutoutActiveObject = keep;
      cutoutSelectedObject = keep;
      cutoutPropertyKeys = keep.keys || (keep.keys = { position: [], zoom: [], rotation: [], opacity: [] });
      if (typeof cutoutBeginSelectionOverlay === 'function') cutoutBeginSelectionOverlay();
      if (typeof renderCutoutObjectsList === 'function') renderCutoutObjectsList();
      drawCutoutTimeline && drawCutoutTimeline();
      updateRowKeyActiveStates && updateRowKeyActiveStates();
      saveState && saveState();
    }
    
    function addCutoutLayer() {
      const idx = (typeof selectedCutoutClipIndex === 'number' && selectedCutoutClipIndex >= 0) ? selectedCutoutClipIndex : getActiveCutoutClipIndexAt(cutoutCurrentTime);
      if (idx < 0) return;
      const clip = cutoutClips[idx];
      if (!clip) return;
      const currentMax = Array.isArray(clip.objects) ? clip.objects.reduce((m, o) => Math.max(m, Number.isFinite(o.layerIndex) ? o.layerIndex : 0), -1) : -1;
      clip.numLayers = Math.max(Number.isFinite(clip.numLayers) ? clip.numLayers : 0, currentMax + 1) + 1;
      if (typeof renderCutoutLayersPanel === 'function') renderCutoutLayersPanel();
    }
    
    function renderCutoutLayersPanel() {
      const list = document.getElementById('cutout-layers-list');
      if (!list) return;
      list.innerHTML = '';
      const idx = (typeof selectedCutoutClipIndex === 'number' && selectedCutoutClipIndex >= 0) ? selectedCutoutClipIndex : getActiveCutoutClipIndexAt(cutoutCurrentTime);
      if (idx < 0) return;
      const clip = cutoutClips[idx];
      const objects = Array.isArray(clip && clip.objects) ? clip.objects : [];
      // Determine number of layers
      const maxIndex = objects.reduce((m, o) => Math.max(m, Number.isFinite(o.layerIndex) ? o.layerIndex : 0), -1);
      const numLayers = Math.max(Number.isFinite(clip.numLayers) ? clip.numLayers : 0, maxIndex + 1, 1);
      clip.numLayers = numLayers;
      for (let li = 0; li < numLayers; li++) {
        const layerRow = document.createElement('div');
        layerRow.style.border = `1px solid ${li === cutoutActiveLayerIndex ? '#6366f1' : '#2a2a2a'}`;
        layerRow.style.borderRadius = '6px';
        layerRow.style.padding = '6px';
        layerRow.style.background = '#0f0f0f';
        layerRow.style.display = 'flex';
        layerRow.style.flexDirection = 'column';
        layerRow.style.gap = '6px';
        layerRow.style.cursor = 'pointer';
        layerRow.addEventListener('click', () => {
          cutoutActiveLayerIndex = li;
          renderCutoutLayersPanel();
          if (typeof renderCutoutObjectsList === 'function') renderCutoutObjectsList();
        });
        // Header
        const header = document.createElement('div');
        header.textContent = `Layer ${li + 1}`;
        header.style.color = '#d1d5db';
        header.style.fontSize = '12px';
        header.style.fontWeight = '600';
        layerRow.appendChild(header);
        // Objects container
        const objs = document.createElement('div');
        objs.style.display = 'flex';
        objs.style.flexWrap = 'wrap';
        objs.style.gap = '6px';
        objs.style.minHeight = '28px';
        objs.style.border = '1px dashed transparent';
        objs.style.borderRadius = '4px';
        // Drop handlers to move object into this layer
        objs.addEventListener('dragover', (e) => {
          e.preventDefault();
          e.stopPropagation();
          e.dataTransfer.dropEffect = 'move';
          objs.style.borderColor = '#6366f1';
        });
        objs.addEventListener('dragleave', (e) => {
          e.stopPropagation();
          objs.style.borderColor = 'transparent';
        });
        objs.addEventListener('drop', (e) => {
          e.preventDefault();
          e.stopPropagation();
          objs.style.borderColor = 'transparent';
          const idStr = e.dataTransfer.getData('text/plain') || e.dataTransfer.getData('text/uri-list') || e.dataTransfer.getData('text');
          const targetId = parseInt(idStr, 10);
          if (!Number.isFinite(targetId)) return;
          const obj = objects.find(o => o && o.id === targetId);
          if (!obj) return;
          if (obj.layerIndex === li) return;
          obj.layerIndex = li;
          // Persist and redraw
          if (typeof saveState === 'function') saveState();
          renderCutoutLayersPanel();
          renderCutoutObjectsList();
          renderCutoutPreviewForTime();
          if (typeof renderCutoutClips === 'function') renderCutoutClips();
        });
        // Populate objects in this layer
        objects.filter(o => (Number.isFinite(o.layerIndex) ? o.layerIndex : 0) === li).forEach((obj) => {
          const chip = document.createElement('div');
          chip.textContent = obj.name || `Object ${obj.id || '?'}`;
          chip.style.fontSize = '11px';
          chip.style.color = '#e5e7eb';
          chip.style.padding = '2px 6px';
          chip.style.borderRadius = '4px';
          chip.style.border = `1px solid ${obj.color || '#6366f1'}`;
          chip.style.cursor = 'grab';
          chip.setAttribute('draggable', 'true');
          chip.addEventListener('dragstart', (e) => {
            e.dataTransfer.setData('text/plain', String(obj.id));
            e.dataTransfer.effectAllowed = 'move';
          });
          // Emphasize the chip if it belongs to the active layer
          if ((Number.isFinite(obj.layerIndex) ? obj.layerIndex : 0) === cutoutActiveLayerIndex) {
            chip.style.boxShadow = '0 0 0 1px #6366f1 inset';
          }
          objs.appendChild(chip);
        });
        layerRow.appendChild(objs);
        list.appendChild(layerRow);
      }
    }
    
    function beginPosDrag(e, axis) {
      if (!cutoutSelectedObject) return;
      e.preventDefault();
      e.stopPropagation();
      // Clear unrelated pending keys to avoid committing stale transforms from prior drags
      if (!cutoutPendingDragKeys) cutoutPendingDragKeys = { position: null, rotation: null, zoom: null, opacity: null };
      else { cutoutPendingDragKeys.rotation = null; cutoutPendingDragKeys.zoom = null; cutoutPendingDragKeys.opacity = null; }
      if (axis === 'x') { isDraggingPosX = true; isDraggingPosY = false; posDragStartValue = cutoutSelectedObject.x; }
      else { isDraggingPosX = false; isDraggingPosY = true; posDragStartValue = cutoutSelectedObject.y; }
      posDragStartMouseX = e.clientX;
      window.addEventListener('mousemove', onPosDragMove);
      window.addEventListener('mouseup', endPosDrag, { once: true });
    }
    function onPosDragMove(e) {
      if (!cutoutSelectedObject) return;
      if (!isDraggingPosX && !isDraggingPosY) return;
      const delta = e.clientX - posDragStartMouseX; // right increases, left decreases
      // Compute new position and preserve previous to move any attached bones accordingly
      const prevX = cutoutSelectedObject.x;
      const prevY = cutoutSelectedObject.y;
      if (isDraggingPosX) { cutoutSelectedObject.x = posDragStartValue + delta; }
      else if (isDraggingPosY) { cutoutSelectedObject.y = posDragStartValue + delta; }
      const dx = (cutoutSelectedObject.x - prevX) || 0;
      const dy = (cutoutSelectedObject.y - prevY) || 0;
      // Move any bones attached to this object to maintain relative positions
      try {
        const activeClip = typeof getActiveCutoutClipIndex === 'function' ? getActiveCutoutClipIndex() : -1;
        for (let i = 0; i < cutoutBones.length; i++) {
          const b = cutoutBones[i];
          if (!b || (activeClip >= 0 && b.clipIndex !== activeClip)) continue;
          if (b.objectRef === cutoutSelectedObject) {
            b.startX += dx; b.startY += dy;
            b.endX += dx; b.endY += dy;
            const cw = cutoutCanvas ? cutoutCanvas.width : 0;
            const ch = cutoutCanvas ? cutoutCanvas.height : 0;
            if (cw && ch) {
              b.startX = Math.max(0, Math.min(cw, b.startX));
              b.startY = Math.max(0, Math.min(ch, b.startY));
              b.endX = Math.max(0, Math.min(cw, b.endX));
              b.endY = Math.max(0, Math.min(ch, b.endY));
            }
          }
        }
      } catch (_e) {}
      cutoutRenderSelectionOverlay();
      // Keep base preview in sync to avoid any trails during numeric position drags
      try { scheduleCutoutPreviewForTime(); } catch (_e) {}
      updateCutoutPositionDisplay(cutoutSelectedObject.x, cutoutSelectedObject.y);
      if (cutoutRecorderArmed) {
        addOrUpdatePropKeyAt('position', cutoutCurrentTime, { x: cutoutSelectedObject.x, y: cutoutSelectedObject.y });
        drawCutoutTimeline(); updateRowKeyActiveStates();
      }
    }
    function endPosDrag() {
      isDraggingPosX = false;
      isDraggingPosY = false;
      window.removeEventListener('mousemove', onPosDragMove);
      // Keep selection active; do not commit automatically
    }
    
    function beginZoomDrag(e) {
      if (!cutoutSelectedObject) return;
      e.preventDefault();
      e.stopPropagation();
      // Clear unrelated pending keys so only zoom (and derived position) will be committed
      if (!cutoutPendingDragKeys) cutoutPendingDragKeys = { position: null, rotation: null, zoom: null, opacity: null };
      else { cutoutPendingDragKeys.rotation = null; cutoutPendingDragKeys.position = null; cutoutPendingDragKeys.opacity = null; }
      if (typeof cutoutSelectedObject.scaleX !== 'number') cutoutSelectedObject.scaleX = 1;
      if (typeof cutoutSelectedObject.scaleY !== 'number') cutoutSelectedObject.scaleY = 1;
      isDraggingZoom = true;
      zoomDragStartMouseX = e.clientX;
      zoomDragStartValueX = cutoutSelectedObject.scaleX;
      zoomDragStartValueY = cutoutSelectedObject.scaleY;
      // Capture center and base dims to keep center fixed while scaling
      const baseW = (cutoutSelectedObject && cutoutSelectedObject.drawW != null)
        ? cutoutSelectedObject.drawW
        : ((cutoutSelectedObject && cutoutSelectedObject.img && (cutoutSelectedObject.img.naturalWidth || cutoutSelectedObject.img.width || cutoutSelectedObject.img.videoWidth)) || 0);
      const baseH = (cutoutSelectedObject && cutoutSelectedObject.drawH != null)
        ? cutoutSelectedObject.drawH
        : ((cutoutSelectedObject && cutoutSelectedObject.img && (cutoutSelectedObject.img.naturalHeight || cutoutSelectedObject.img.height || cutoutSelectedObject.img.videoHeight)) || 0);
      zoomDragBaseW = baseW;
      zoomDragBaseH = baseH;
      zoomDragObjScale = cutoutSelectedObject.scale || 1;
      const startW = baseW * zoomDragObjScale * zoomDragStartValueX;
      const startH = baseH * zoomDragObjScale * zoomDragStartValueY;
      zoomDragStartCenterX = cutoutSelectedObject.x + startW / 2;
      zoomDragStartCenterY = cutoutSelectedObject.y + startH / 2;
      window.addEventListener('mousemove', onZoomDragMove);
      window.addEventListener('mouseup', endZoomDrag, { once: true });
    }
    function onZoomDragMove(e) {
      if (!cutoutSelectedObject || !isDraggingZoom) return;
      const delta = e.clientX - zoomDragStartMouseX;
      // Adjust both scales uniformly; 0.01 per pixel, clamped
      const startAvg = (zoomDragStartValueX + zoomDragStartValueY) / 2;
      const newScale = Math.max(0.1, Math.min(10.0, startAvg + (delta * 0.01)));
      cutoutSelectedObject.scaleX = newScale;
      cutoutSelectedObject.scaleY = newScale;
      // Keep center fixed
      const newW = zoomDragBaseW * zoomDragObjScale * newScale;
      const newH = zoomDragBaseH * zoomDragObjScale * newScale;
      cutoutSelectedObject.x = zoomDragStartCenterX - newW / 2;
      cutoutSelectedObject.y = zoomDragStartCenterY - newH / 2;
      cutoutRenderSelectionOverlay();
      updateCutoutZoomDisplay(cutoutSelectedObject.scaleX, cutoutSelectedObject.scaleY);
      updateCutoutPositionDisplay(cutoutSelectedObject.x, cutoutSelectedObject.y);
      if (cutoutRecorderArmed) {
        cutoutPendingDragKeys.zoom = { time: cutoutCurrentTime, sx: cutoutSelectedObject.scaleX, sy: cutoutSelectedObject.scaleY };
      }
    }
    function endZoomDrag() {
      isDraggingZoom = false;
      window.removeEventListener('mousemove', onZoomDragMove);
      // Commit buffered zoom key once dragging ends
      if (cutoutRecorderArmed && cutoutPendingDragKeys && cutoutPendingDragKeys.zoom) {
        try { saveState(); } catch (_e) {}
        const k = cutoutPendingDragKeys.zoom;
        addOrUpdatePropKeyAt('zoom', k.time, { sx: k.sx, sy: k.sy });
        cutoutPendingDragKeys.zoom = null;
        drawCutoutTimeline();
        updateRowKeyActiveStates();
      }
    }
    
    // Rotation slider interactions
    let isDraggingRotSlider = false;
    let rotSliderStartX = 0;
    function setCutoutRotationFromDegrees(deg) {
      if (!cutoutSelectedObject) return;
      const radians = (deg || 0) * Math.PI / 180;
      cutoutSelectedObject.rotation = radians;
      cutoutRenderSelectionOverlay();
      updateCutoutRotationDisplay(deg);
    }
    function beginRotSliderDrag(e) {
      if (!cutoutSelectedObject) return;
      const cx = getPointerClientX(e);
      if (cx === null) return;
      e.preventDefault();
      e.stopPropagation();
      // Clear unrelated pending keys to avoid committing stale position/zoom on rotation change
      if (!cutoutPendingDragKeys) cutoutPendingDragKeys = { position: null, rotation: null, zoom: null, opacity: null };
      else { cutoutPendingDragKeys.position = null; cutoutPendingDragKeys.zoom = null; cutoutPendingDragKeys.opacity = null; }
      isDraggingRotSlider = true;
      rotSliderStartX = cx;
      window.addEventListener('mousemove', onRotSliderDrag);
      window.addEventListener('touchmove', onRotSliderDrag, { passive: false });
      window.addEventListener('mouseup', endRotSliderDrag, { once: true });
      window.addEventListener('touchend', endRotSliderDrag, { once: true });
      // Update immediately based on click position
      onRotSliderDrag(e);
    }
    function onRotSliderDrag(e) {
      if (!isDraggingRotSlider || !cutoutSelectedObject) return;
      const track = document.getElementById('cutout-rot-track');
      if (!track) return;
      const rect = track.getBoundingClientRect();
      const cx = getPointerClientX(e);
      if (cx === null) return;
      const px = Math.max(rect.left, Math.min(rect.right, cx));
      const pct = (px - rect.left) / rect.width; // 0..1
      const deg = (pct * 360) - 180; // -180..+180
      setCutoutRotationFromDegrees(deg);
      if (cutoutRecorderArmed) {
        addOrUpdatePropKeyAt('rotation', cutoutCurrentTime, { deg });
        drawCutoutTimeline(); updateRowKeyActiveStates();
      }
    }
    function endRotSliderDrag() {
      isDraggingRotSlider = false;
      window.removeEventListener('mousemove', onRotSliderDrag);
      window.removeEventListener('touchmove', onRotSliderDrag);
    }
    
    // Blur slider removed
    // Opacity slider interactions (0..1)
    let isDraggingOpaSlider = false;
    function setCutoutOpacityFromValue(value) {
      if (!cutoutSelectedObject) return;
      const v = Math.max(0, Math.min(1, value || 0));
      cutoutSelectedObject.opacity = v;
      cutoutRenderSelectionOverlay();
      updateCutoutOpacityDisplay(v);
    }
    function beginOpaSliderDrag(e) {
      if (!cutoutSelectedObject) return;
      const cx = getPointerClientX(e);
      if (cx === null) return;
      e.preventDefault();
      e.stopPropagation();
      isDraggingOpaSlider = true;
      window.addEventListener('mousemove', onOpaSliderDrag);
      window.addEventListener('touchmove', onOpaSliderDrag, { passive: false });
      window.addEventListener('mouseup', endOpaSliderDrag, { once: true });
      window.addEventListener('touchend', endOpaSliderDrag, { once: true });
      onOpaSliderDrag(e);
    }
    function onOpaSliderDrag(e) {
      if (!isDraggingOpaSlider || !cutoutSelectedObject) return;
      const track = document.getElementById('cutout-opa-track');
      if (!track) return;
      const rect = track.getBoundingClientRect();
      const cx = getPointerClientX(e);
      if (cx === null) return;
      const px = Math.max(rect.left, Math.min(rect.right, cx));
      const pct = (px - rect.left) / rect.width;
      setCutoutOpacityFromValue(pct);
      if (cutoutRecorderArmed) {
        addOrUpdatePropKeyAt('opacity', cutoutCurrentTime, { value: cutoutSelectedObject.opacity });
        drawCutoutTimeline(); updateRowKeyActiveStates();
      }
    }
    function endOpaSliderDrag() {
      isDraggingOpaSlider = false;
      window.removeEventListener('mousemove', onOpaSliderDrag);
      window.removeEventListener('touchmove', onOpaSliderDrag);
    }
    // Draggable property keys on timeline
    function beginPropKeyDrag(e, prop, keyRef) {
      const track = document.getElementById('cutout-ruler-area');
      if (!track) return;
      isDraggingPropKey = true;
      document.body.style.userSelect = 'none';
  propKeyDragDidMove = false;
      const rect = track.getBoundingClientRect();
      // Build a group of keys at the same timestamp across all transform properties
      const epsilon = 1 / 60;
      const t0 = keyRef.time;
      const group = [];
      const pushIfMatch = (p) => {
        const arr = (cutoutPropertyKeys && Array.isArray(cutoutPropertyKeys[p])) ? cutoutPropertyKeys[p] : [];
        for (let i = 0; i < arr.length; i++) {
          const k = arr[i];
          if (Math.abs(k.time - t0) <= epsilon) {
            group.push({ prop: p, keyRef: k });
          }
        }
      };
      pushIfMatch('position');
      pushIfMatch('zoom');
      pushIfMatch('rotation');
      pushIfMatch('opacity');
      dragPropKey = {
        group,
        startMouseX: e.clientX,
        startTime: t0,
        trackLeft: rect.left,
        trackWidth: rect.width
      };
      window.addEventListener('mousemove', onPropKeyDragMove);
      window.addEventListener('mouseup', endPropKeyDrag, { once: true });
      e.stopPropagation();
      e.preventDefault();
    }
    function onPropKeyDragMove(e) {
      if (!isDraggingPropKey || !dragPropKey) return;
  propKeyDragDidMove = true;
      const { group, startMouseX, startTime, trackLeft, trackWidth } = dragPropKey;
      const dx = e.clientX - startMouseX;
      const pixelsPerSecond = trackWidth / Math.max(0.1, cutoutDuration);
      const dt = dx / Math.max(1, pixelsPerSecond);
      let newTime = Math.max(0, Math.min(cutoutDuration, startTime + dt));
      // Update all keys in the group to the new time (keep arrays unsorted during drag)
      for (const entry of group) {
        if (entry && entry.keyRef) entry.keyRef.time = newTime;
      }
      // Redraw only the prop keys overlay for visual feedback
      drawCutoutTimeline();
      updateRowKeyActiveStates();
      applyCutoutKeyframedTransformsAtTime();
    }
    function endPropKeyDrag() {
      if (!isDraggingPropKey) return;
      isDraggingPropKey = false;
      document.body.style.userSelect = '';
      window.removeEventListener('mousemove', onPropKeyDragMove);
  // If there was no movement, interpret as click: jump
  try {
    if (!propKeyDragDidMove && dragPropKey && typeof dragPropKey.startTime === 'number') {
      jumpToCutoutTime(dragPropKey.startTime);
    }
  } catch (_e) {}
      // Resort and deduplicate arrays so keys are in time order and merged on collisions
      const epsilon = 1 / 60;
      ['position','zoom','rotation','opacity'].forEach((p) => {
        if (Array.isArray(cutoutPropertyKeys[p])) {
          const arr = cutoutPropertyKeys[p].slice().sort((a, b) => a.time - b.time);
          const dedup = [];
          for (const k of arr) {
            if (!dedup.length || Math.abs(dedup[dedup.length - 1].time - k.time) > epsilon) {
              dedup.push(k);
            } else {
              // Merge: later one wins
              dedup[dedup.length - 1] = k;
            }
          }
          cutoutPropertyKeys[p] = dedup;
        }
      });
      drawCutoutTimeline();
      updateRowKeyActiveStates();
      applyCutoutKeyframedTransformsAtTime();
      saveState();
    }
    
    // Keying per-property
    function getOrCreatePropKeys(prop) {
      if (!cutoutPropertyKeys[prop]) cutoutPropertyKeys[prop] = [];
      return cutoutPropertyKeys[prop];
    }
    function extendActiveCutoutClipToTime(timeSec) {
      // Prefer explicitly selected clip; otherwise, active at current time
      let idx = (typeof selectedCutoutClipIndex === 'number' && selectedCutoutClipIndex >= 0)
        ? selectedCutoutClipIndex
        : getActiveCutoutClipIndexAt(timeSec);
      if (idx < 0) return;
      // Build neighbor info
      const sorted = cutoutClips.map((c, i) => ({ ...c, i })).sort((a, b) => a.start - b.start);
      const pos = sorted.findIndex(c => c.i === idx);
      if (pos === -1) return;
      const prev = pos > 0 ? sorted[pos - 1] : null;
      const next = pos < sorted.length - 1 ? sorted[pos + 1] : null;
      const clip = cutoutClips[idx];
      const epsilon = 1 / 60;
      // Extend end forward if needed, without overlapping next
      if (timeSec > clip.end - epsilon) {
        const maxEnd = next ? Math.max(clip.start + epsilon, next.start - epsilon) : cutoutDuration;
        clip.end = Math.min(maxEnd, Math.max(clip.end, timeSec + epsilon));
      }
      // Also extend backward if keys created earlier than start, without overlapping prev
      if (timeSec < clip.start + epsilon) {
        const minStart = prev ? Math.min(clip.end - epsilon, prev.end + epsilon) : 0;
        clip.start = Math.max(minStart, Math.min(clip.start, Math.max(0, timeSec - epsilon)));
      }
    }
    function addOrUpdatePropKeyAt(prop, time, values) {
      const arr = getOrCreatePropKeys(prop);
      const epsilon = 1 / 60;
      const idx = arr.findIndex(k => Math.abs(k.time - time) <= epsilon);
      if (idx >= 0) {
        Object.assign(arr[idx], { time, ...values });
      } else {
        arr.push({ time, ...values });
      }
      arr.sort((a, b) => a.time - b.time);
      // Ensure the underlying clip extends to cover this key's time
      extendActiveCutoutClipToTime(time);
    }
    function togglePropertyKey(prop) {
      saveState();
      const t = Math.max(0, Math.min(cutoutDuration, cutoutCurrentTime || 0));
      const arr = getOrCreatePropKeys(prop);
      // if a key exists near current time (+/- 1 frame), remove it; else add with current values
      const epsilon = 1 / 60; // ~1 frame at 60fps
      const idx = arr.findIndex(k => Math.abs(k.time - t) <= epsilon);
      if (idx >= 0) {
        arr.splice(idx, 1);
      } else {
        if (prop === 'position' && cutoutSelectedObject) {
          arr.push({ time: t, x: cutoutSelectedObject.x, y: cutoutSelectedObject.y });
        } else if (prop === 'zoom' && cutoutSelectedObject) {
          const sx = typeof cutoutSelectedObject.scaleX === 'number' ? cutoutSelectedObject.scaleX : 1;
          const sy = typeof cutoutSelectedObject.scaleY === 'number' ? cutoutSelectedObject.scaleY : 1;
          arr.push({ time: t, sx, sy });
        } else if (prop === 'rotation' && cutoutSelectedObject) {
          const deg = ((cutoutSelectedObject.rotation || 0) * 180) / Math.PI;
          arr.push({ time: t, deg });
        } else if (prop === 'opacity' && cutoutSelectedObject) {
          const value = typeof cutoutSelectedObject.opacity === 'number' ? cutoutSelectedObject.opacity : 1;
          arr.push({ time: t, value });
        } else {
          // No selection; still record default-neutral key
          if (prop === 'position') arr.push({ time: t, x: 0, y: 0 });
          if (prop === 'zoom') arr.push({ time: t, sx: 1, sy: 1 });
          if (prop === 'rotation') arr.push({ time: t, deg: 0 });
          if (prop === 'opacity') arr.push({ time: t, value: 1 });
        }
      }
      arr.sort((a, b) => a.time - b.time);
      drawCutoutTimeline();
      updateRowKeyActiveStates();
      applyCutoutKeyframedTransformsAtTime();
      saveState();
    }
    function hasKeyAtTime(prop, t) {
      const arr = getOrCreatePropKeys(prop);
      const epsilon = 1 / 60;
      return arr.some(k => Math.abs(k.time - t) <= epsilon);
    }
    function updateRowKeyActiveStates() {
      const t = Math.max(0, Math.min(cutoutDuration, cutoutCurrentTime || 0));
      // Determine active object color (pending selection color takes precedence)
      let activeColor = '#6366f1';
      try {
        if (cutoutPendingSelection && cutoutPendingColor) {
          activeColor = cutoutPendingColor;
        } else {
          const idx = getActiveCutoutClipIndexAt(cutoutCurrentTime);
          if (idx >= 0) {
            const c = cutoutClips[idx];
            const obj = cutoutActiveObject || (Array.isArray(c.objects) ? c.objects[0] : null);
            if (obj && obj.color) activeColor = obj.color;
          }
        }
      } catch (_e) {}
      const setActive = (id, active) => {
        const el = document.getElementById(id);
        if (!el) return;
        if (active) {
          el.style.background = activeColor;
          el.style.boxShadow = '0 0 6px rgba(99,102,241,0.6)';
        } else {
          // Inactive: show neutral color
          el.style.boxShadow = '';
          el.style.background = '#6b7280';
        }
      };
      setActive('cutout-pos-key', hasKeyAtTime('position', t));
      setActive('cutout-zoom-key', hasKeyAtTime('zoom', t));
      setActive('cutout-rot-key', hasKeyAtTime('rotation', t));
      setActive('cutout-opa-key', hasKeyAtTime('opacity', t));
    }
    function lerp(a, b, t) { return a + (b - a) * t; }
    function shortestAngleDeg(from, to) {
      let delta = ((to - from + 540) % 360) - 180;
      return from + delta;
    }
    function sampleKeyframes(arr, t, getter) {
      if (!arr || arr.length === 0) return null;
      if (t <= arr[0].time) return getter(arr[0], arr[0], 0);
      if (t >= arr[arr.length - 1].time) return getter(arr[arr.length - 1], arr[arr.length - 1], 1);
      for (let i = 0; i < arr.length - 1; i++) {
        const a = arr[i], b = arr[i + 1];
        if (t >= a.time && t <= b.time) {
          const alpha = (t - a.time) / (b.time - a.time);
          return getter(a, b, alpha);
        }
      }
      return getter(arr[arr.length - 1], arr[arr.length - 1], 1);
    }
    function applyCutoutKeyframedTransformsAtTime() {
      if (!cutoutSelectedObject) return;
      const t = Math.max(0, Math.min(cutoutDuration, cutoutCurrentTime || 0));
      // Position
      const pos = sampleKeyframes(cutoutPropertyKeys.position, t, (a, b, alpha) => ({
        x: lerp(a.x, b.x, alpha),
        y: lerp(a.y, b.y, alpha)
      }));
      if (pos) {
        cutoutSelectedObject.x = pos.x;
        cutoutSelectedObject.y = pos.y;
        updateCutoutPositionDisplay(pos.x, pos.y);
      }
      // Zoom (uniform, follow our earlier behavior of using both axes the same when dragged)
      const zm = sampleKeyframes(cutoutPropertyKeys.zoom, t, (a, b, alpha) => ({
        sx: lerp(a.sx, b.sx, alpha),
        sy: lerp(a.sy, b.sy, alpha)
      }));
      if (zm) {
        cutoutSelectedObject.scaleX = zm.sx;
        cutoutSelectedObject.scaleY = zm.sy;
        updateCutoutZoomDisplay(zm.sx, zm.sy);
      }
      // Rotation
      const rot = sampleKeyframes(cutoutPropertyKeys.rotation, t, (a, b, alpha) => {
        const target = shortestAngleDeg(a.deg, b.deg);
        return { deg: lerp(a.deg, target, alpha) };
      });
      if (rot) {
        cutoutSelectedObject.rotation = (rot.deg * Math.PI) / 180;
        updateCutoutRotationDisplay(rot.deg);
      }
      // Opacity
      const op = sampleKeyframes(cutoutPropertyKeys.opacity, t, (a, b, alpha) => ({
        value: lerp(a.value, b.value, alpha)
      }));
      if (op) {
        cutoutSelectedObject.opacity = Math.max(0, Math.min(1, op.value));
        updateCutoutOpacityDisplay(cutoutSelectedObject.opacity);
      }
      cutoutRenderSelectionOverlay();
    }
    
    function cutoutOutsideClickCommit(e) {
      const container = document.getElementById('cutout-canvas-container');
      if (!container) return;
      if (container.contains(e.target)) return;
      // Only commit selection if the click is on a UI element that changes tool.
      // Keep selection when clicking elsewhere outside the canvas.
      const toolSwitchEl = e.target.closest('.tool-btn, [data-effect-id], #detail-btn');
      if (toolSwitchEl) cutoutCommitSelection();
    }
    
    function cutoutSelectionMouseDown(e) {
      // Allow picking different objects with the Select tool
      const rect = cutoutMoveOverlayCanvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (cutoutCanvas.width / rect.width);
      const y = (e.clientY - rect.top) * (cutoutCanvas.height / rect.height);
      // PRIORITY: if we already have a selection, honor its handles before attempting to pick another object
      if (cutoutSelectedObject) {
        const handle0 = getResizeHandleAtPoint(cutoutSelectedObject, x, y);
        if (handle0 === 'rotation') {
          const geometry = calculateSelectionHandleGeometry(cutoutSelectedObject);
          const pivot = geometry.pivot || geometry.center;
          rotationCenterX = pivot.x;
          rotationCenterY = pivot.y;
          rotationStartAngle = Math.atan2(y - rotationCenterY, x - rotationCenterX);
          rotationCurrentAngle = cutoutSelectedObject.rotation || 0;
          cutoutIsRotatingObj = true;
          activeTransformHandle = 'rotation';
          return;
        }
        if (handle0 === 'pivot') {
          cutoutIsDraggingPivot = true;
          activeTransformHandle = 'pivot';
          // Ensure overlay updates immediately
          try { cutoutRenderSelectionOverlay(); } catch (_e) {}
          return;
        }
        if (handle0) {
          cutoutIsResizingObj = true;
          cutoutResizeCorner = handle0;
          const geometry = calculateSelectionHandleGeometry(cutoutSelectedObject);
          cutoutResizeStartCenterX = geometry.center.x;
          cutoutResizeStartCenterY = geometry.center.y;
          cutoutResizeStartScaleX = (typeof cutoutSelectedObject.scaleX === 'number') ? cutoutSelectedObject.scaleX : 1;
          cutoutResizeStartScaleY = (typeof cutoutSelectedObject.scaleY === 'number') ? cutoutSelectedObject.scaleY : 1;
          const baseW = (cutoutSelectedObject && cutoutSelectedObject.drawW != null)
            ? cutoutSelectedObject.drawW
            : ((cutoutSelectedObject && cutoutSelectedObject.img && (cutoutSelectedObject.img.naturalWidth || cutoutSelectedObject.img.width || cutoutSelectedObject.img.videoWidth)) || 0);
          const baseH = (cutoutSelectedObject && cutoutSelectedObject.drawH != null)
            ? cutoutSelectedObject.drawH
            : ((cutoutSelectedObject && cutoutSelectedObject.img && (cutoutSelectedObject.img.naturalHeight || cutoutSelectedObject.img.height || cutoutSelectedObject.img.videoHeight)) || 0);
          cutoutResizeBaseW = baseW;
          cutoutResizeBaseH = baseH;
        cutoutResizeObjScale = cutoutSelectedObject.scale || 1;
        cutoutResizeStartMouseDist = Math.max(1, Math.hypot(x - cutoutResizeStartCenterX, y - cutoutResizeStartCenterY));
          // Capture pivot ratio for proportional scaling
          const initW = cutoutResizeBaseW * cutoutResizeObjScale * cutoutResizeStartScaleX;
          const initH = cutoutResizeBaseH * cutoutResizeObjScale * cutoutResizeStartScaleY;
          cutoutResizeHasPivot = (typeof cutoutSelectedObject.pivotLocalX === 'number');
          if (cutoutResizeHasPivot && initW > 0 && initH > 0) {
            cutoutResizeStartPivotRatioX = cutoutSelectedObject.pivotLocalX / initW;
            cutoutResizeStartPivotRatioY = cutoutSelectedObject.pivotLocalY / initH;
          } else {
            cutoutResizeStartPivotRatioX = 0.5;
            cutoutResizeStartPivotRatioY = 0.5;
          }
          activeTransformHandle = handle0;
          return;
        }
        // If click is inside the selected object and using Select tool, prefer topmost object under cursor.
        // If the topmost hit is a different object, switch selection to it; otherwise begin move.
        if (currentTool === 'select' && isPointInsideSelectedObject(cutoutSelectedObject, x, y)) {
          const activeIdx0 = getActiveCutoutClipIndexAt(cutoutCurrentTime);
          let switched = false;
          if (activeIdx0 >= 0) {
            const clip0 = cutoutClips[activeIdx0];
            const objects0 = Array.isArray(clip0 && clip0.objects) ? clip0.objects : [];
            const sorted0 = objects0.slice().sort((a,b) => {
              const ai = Number.isFinite(a && a.layerIndex) ? a.layerIndex : 0;
              const bi = Number.isFinite(b && b.layerIndex) ? b.layerIndex : 0;
              if (ai !== bi) return ai - bi; // lower index first (topmost)
              const aid = (a && a.id != null) ? a.id : 0;
              const bid = (b && b.id != null) ? b.id : 0;
              return bid - aid; // higher id first
            });
            const hitTop = sorted0.find((obj) => {
              if (!obj || !obj.img) return false;
              const baseW = (obj.drawW != null) ? obj.drawW : ((obj.img.naturalWidth || obj.img.width || 0));
              const baseH = (obj.drawH != null) ? obj.drawH : ((obj.img.naturalHeight || obj.img.height || 0));
              const w = baseW * (obj.scale || 1) * (obj.scaleX || 1);
              const h = baseH * (obj.scale || 1) * (obj.scaleY || 1);
              return x >= obj.x && x <= obj.x + w && y >= obj.y && y <= obj.y + h;
            });
            if (hitTop && hitTop !== cutoutSelectedObject) {
              cutoutSelectedObject = hitTop;
              cutoutActiveObject = hitTop;
              cutoutPropertyKeys = hitTop.keys || (hitTop.keys = { position: [], zoom: [], rotation: [], opacity: [] });
              try { cutoutBeginSelectionOverlay(); } catch (_e) {}
              if (typeof updateCutoutPositionDisplay === 'function') updateCutoutPositionDisplay(hitTop.x, hitTop.y);
              if (typeof updateCutoutZoomDisplay === 'function') updateCutoutZoomDisplay(hitTop.scaleX || 1, hitTop.scaleY || 1);
              const deg = ((hitTop.rotation || 0) * 180) / Math.PI;
              if (typeof updateCutoutRotationDisplay === 'function') updateCutoutRotationDisplay(deg);
              if (typeof updateCutoutOpacityDisplay === 'function') updateCutoutOpacityDisplay((typeof hitTop.opacity === 'number') ? hitTop.opacity : 1);
              drawCutoutTimeline();
              switched = true;
              return;
            }
          }
          if (!switched) {
            cutoutIsDraggingObj = true;
            imageDragOffsetX = x - cutoutSelectedObject.x;
            imageDragOffsetY = y - cutoutSelectedObject.y;
            activeTransformHandle = '';
            // Immediately re-render base without selected and draw overlay to avoid ghost traces
            try { cutoutRenderSelectionOverlay(); } catch (_e) {}
            try { renderCutoutPreviewForTime(); } catch (_e) {}
            return;
          }
        }
      }
      // If no current selection or clicking outside current selection in Select tool, pick another object
      if (currentTool === 'select') {
        const activeIdx = getActiveCutoutClipIndexAt(cutoutCurrentTime);
        if (activeIdx >= 0) {
          const clip = cutoutClips[activeIdx];
          const objects = Array.isArray(clip && clip.objects) ? clip.objects : [];
          // Search top-most first: lower layerIndex on top; for same layer, higher id on top
          const sorted = objects.slice().sort((a,b) => {
            const ai = Number.isFinite(a && a.layerIndex) ? a.layerIndex : 0;
            const bi = Number.isFinite(b && b.layerIndex) ? b.layerIndex : 0;
            if (ai !== bi) return ai - bi; // lower index first (topmost)
            const aid = (a && a.id != null) ? a.id : 0;
            const bid = (b && b.id != null) ? b.id : 0;
            return bid - aid; // higher id first (topmost among same layer)
          });
          const hit = sorted.find((obj) => {
            if (!obj || !obj.img) return false;
            const baseW = (obj.drawW != null) ? obj.drawW : ((obj.img.naturalWidth || obj.img.width || 0));
            const baseH = (obj.drawH != null) ? obj.drawH : ((obj.img.naturalHeight || obj.img.height || 0));
            const w = baseW * (obj.scale || 1) * (obj.scaleX || 1);
            const h = baseH * (obj.scale || 1) * (obj.scaleY || 1);
            // AABB hit test (rotation ignored for click pick)
            return x >= obj.x && x <= obj.x + w && y >= obj.y && y <= obj.y + h;
          });
          if (hit && (!cutoutSelectedObject || hit !== cutoutSelectedObject)) {
            e.stopPropagation();
            cutoutSelectedObject = hit;
            cutoutActiveObject = hit;
            cutoutPropertyKeys = hit.keys || (hit.keys = { position: [], zoom: [], rotation: [], opacity: [] });
            // Start overlay and update UI readouts
            try {
              if (!cutoutMoveOverlayCanvas) {
                cutoutBeginSelectionOverlay();
              } else {
                // Rebuild base with non-selected objects, then redraw overlay to avoid flicker
                if (cutoutCanvas) {
                  cutoutDragBaseCanvas = document.createElement('canvas');
                  cutoutDragBaseCanvas.width = cutoutCanvas.width;
                  cutoutDragBaseCanvas.height = cutoutCanvas.height;
                  cutoutDragBaseCtx = cutoutDragBaseCanvas.getContext('2d');
                  const idx2 = getActiveCutoutClipIndexAt(cutoutCurrentTime);
                  if (idx2 >= 0 && cutoutClips[idx2]) {
                    const clip2 = cutoutClips[idx2];
                if (clip2.canvas) cutoutDragBaseCtx.drawImage(clip2.canvas, 0, 0);
                const objs2 = Array.isArray(clip2.objects) ? clip2.objects.slice() : [];
                objs2.sort((a, b) => {
                      const ai = Number.isFinite(a && a.layerIndex) ? a.layerIndex : 0;
                      const bi = Number.isFinite(b && b.layerIndex) ? b.layerIndex : 0;
                  if (ai !== bi) return bi - ai;
                  const aid = (a && a.id != null) ? a.id : 0;
                  const bid = (b && b.id != null) ? b.id : 0;
                  return aid - bid;
                });
                for (const o of objs2) {
                      if (!o || !o.img) continue;
                  if (cutoutSelectedObject) {
                    const sel = cutoutSelectedObject;
                    const oi = Number.isFinite(o.layerIndex) ? o.layerIndex : 0;
                    const si = Number.isFinite(sel.layerIndex) ? sel.layerIndex : 0;
                    const oid = (o.id != null) ? o.id : 0;
                    const sid = (sel.id != null) ? sel.id : 0;
                    const above = (oi < si) || (oi === si && oid > sid);
                    if (above) continue;
                    if (o === sel || (o.id != null && sel.id != null && o.id === sel.id)) continue;
                  }
                  drawRotatedImage(cutoutDragBaseCtx, o);
                }
                  }
                }
                cutoutOverlayHasCurrent = true;
                cutoutRenderSelectionOverlay();
              }
            } catch (_e) {}
            if (typeof updateCutoutPositionDisplay === 'function') updateCutoutPositionDisplay(hit.x, hit.y);
            if (typeof updateCutoutZoomDisplay === 'function') updateCutoutZoomDisplay(hit.scaleX || 1, hit.scaleY || 1);
            const deg = ((hit.rotation || 0) * 180) / Math.PI;
            if (typeof updateCutoutRotationDisplay === 'function') updateCutoutRotationDisplay(deg);
            if (typeof updateCutoutOpacityDisplay === 'function') updateCutoutOpacityDisplay((typeof hit.opacity === 'number') ? hit.opacity : 1);
            drawCutoutTimeline();
            return;
          }
        }
      }
      if (!cutoutSelectedObject) return;
      const handle = getResizeHandleAtPoint(cutoutSelectedObject, x, y);
      activeTransformHandle = handle;
      // If click is not on a handle and not inside the selected object, and we're in select-lasso,
      // commit current selection and begin a new lasso selection immediately.
      if (!handle && currentTool === 'select-lasso' && !isPointInsideSelectedObject(cutoutSelectedObject, x, y)) {
        e.preventDefault();
        try { cutoutCommitSelection(); } catch (_e) {}
        // Ensure we have an active target clip similar to cutoutStartDraw()
        const activeIdx = getActiveCutoutClipIndexAt(cutoutCurrentTime);
        if (activeIdx >= 0) {
          cutoutDrawingClipIndex = activeIdx;
          selectedCutoutClipIndex = activeIdx;
          renderCutoutClips();
        } else {
          cutoutCreateClipSnapshot();
        }
        isCutoutDrawing = true;
          // Start new lasso capture in cutout canvas space
        magicLassoMode = 'select-lasso';
        magicLassoPoints = [[x, y]];
        isMagicLassoActive = true;
        // Build/attach lasso overlay canvas if missing
        const container = document.getElementById('cutout-canvas-container');
        if (lassoOverlayCanvas) {
          lassoOverlayCanvas.remove();
        }
        lassoOverlayCanvas = document.createElement('canvas');
        lassoOverlayCanvas.width = cutoutCanvas.width;
        lassoOverlayCanvas.height = cutoutCanvas.height;
        lassoOverlayCanvas.style.position = 'absolute';
        lassoOverlayCanvas.style.top = '0';
        lassoOverlayCanvas.style.left = '0';
        lassoOverlayCanvas.style.width = '100%';
        lassoOverlayCanvas.style.height = '100%';
        lassoOverlayCanvas.style.pointerEvents = 'none';
        lassoOverlayCanvas.style.zIndex = '9';
        lassoOverlayCtx = lassoOverlayCanvas.getContext('2d');
        if (container) {
          const computed = window.getComputedStyle(container);
          if (computed.position === 'static') container.style.position = 'relative';
          container.appendChild(lassoOverlayCanvas);
        }
        return;
      }
      if (handle === 'rotation') {
        // begin rotation
        const geometry = calculateSelectionHandleGeometry(cutoutSelectedObject);
        const pivot = geometry.pivot || geometry.center;
        rotationCenterX = pivot.x;
        rotationCenterY = pivot.y;
        rotationStartAngle = Math.atan2(y - rotationCenterY, x - rotationCenterX);
        rotationCurrentAngle = cutoutSelectedObject.rotation || 0;
        cutoutIsRotatingObj = true;
        // Clear unrelated pending keys so only rotation is committed on mouseup
        // But for bone-linked objects, position may also change during rotation
        if (!cutoutPendingDragKeys) cutoutPendingDragKeys = { position: null, rotation: null, zoom: null, opacity: null };
        else { cutoutPendingDragKeys.zoom = null; cutoutPendingDragKeys.opacity = null; }
        // Check if object is bone-linked - if so, keep position tracking enabled
        let hasBoneLink = false;
        try {
          const activeClipCheck = getActiveCutoutClipIndex();
          for (let i = 0; i < cutoutBones.length; i++) {
            const bb = cutoutBones[i];
            if (bb && bb.clipIndex === activeClipCheck && bb.objectRef === cutoutSelectedObject) { hasBoneLink = true; break; }
          }
        } catch (_e) {}
        if (!hasBoneLink) cutoutPendingDragKeys.position = null;
        // Immediately re-render base without the selected object and draw overlay to avoid trails
        try { renderCutoutPreviewForTime(); } catch (_e) {}
        try { cutoutRenderSelectionOverlay(); } catch (_e) {}
        // If this object is attached to a bone, compute pinned local offset to keep start node fixed during rotation
        try {
          const activeClip = getActiveCutoutClipIndex();
          let linked = null;
          for (let i = 0; i < cutoutBones.length; i++) {
            const bb = cutoutBones[i];
            if (!bb || bb.clipIndex !== activeClip) continue;
            if (bb.objectRef === cutoutSelectedObject) { linked = bb; break; }
          }
          if (linked) {
            const obj = cutoutSelectedObject;
            const baseW = (obj && obj.drawW != null) ? obj.drawW : ((obj && obj.img && (obj.img.naturalWidth || obj.img.width || obj.img.videoWidth)) || 0);
            const baseH = (obj && obj.drawH != null) ? obj.drawH : ((obj && obj.img && (obj.img.naturalHeight || obj.img.height || obj.img.videoHeight)) || 0);
            const effScaleX = (typeof obj.scaleX === 'number' ? obj.scaleX : 1);
            const effScaleY = (typeof obj.scaleY === 'number' ? obj.scaleY : 1);
            const w = baseW * (obj.scale || 1) * effScaleX;
            const h = baseH * (obj.scale || 1) * effScaleY;
            const cX = obj.x + w / 2;
            const cY = obj.y + h / 2;
            const rot = obj.rotation || 0;
            const dx = linked.startX - cX;
            const dy = linked.startY - cY;
            const cos = Math.cos(rot), sin = Math.sin(rot);
            linked.pinnedLocalX = dx * cos + dy * sin;
            linked.pinnedLocalY = -dx * sin + dy * cos;
          }
        } catch (_e) {}
        return;
      }
      if (handle) {
        // Begin center-preserving uniform resize (zoom)
        cutoutIsResizingObj = true;
        cutoutResizeCorner = handle;
        const geometry = calculateSelectionHandleGeometry(cutoutSelectedObject);
        cutoutResizeStartCenterX = geometry.center.x;
        cutoutResizeStartCenterY = geometry.center.y;
        cutoutResizeStartScaleX = (typeof cutoutSelectedObject.scaleX === 'number') ? cutoutSelectedObject.scaleX : 1;
        cutoutResizeStartScaleY = (typeof cutoutSelectedObject.scaleY === 'number') ? cutoutSelectedObject.scaleY : 1;
        const baseW = (cutoutSelectedObject && cutoutSelectedObject.drawW != null)
          ? cutoutSelectedObject.drawW
          : ((cutoutSelectedObject && cutoutSelectedObject.img && (cutoutSelectedObject.img.naturalWidth || cutoutSelectedObject.img.width || cutoutSelectedObject.img.videoWidth)) || 0);
        const baseH = (cutoutSelectedObject && cutoutSelectedObject.drawH != null)
          ? cutoutSelectedObject.drawH
          : ((cutoutSelectedObject && cutoutSelectedObject.img && (cutoutSelectedObject.img.naturalHeight || cutoutSelectedObject.img.height || cutoutSelectedObject.img.videoHeight)) || 0);
        cutoutResizeBaseW = baseW;
        cutoutResizeBaseH = baseH;
        cutoutResizeObjScale = cutoutSelectedObject.scale || 1;
        // Initial distance from center to cursor
        cutoutResizeStartMouseDist = Math.max(1, Math.hypot(x - cutoutResizeStartCenterX, y - cutoutResizeStartCenterY));
        // Capture pivot ratio for proportional scaling
        const initW2 = cutoutResizeBaseW * cutoutResizeObjScale * cutoutResizeStartScaleX;
        const initH2 = cutoutResizeBaseH * cutoutResizeObjScale * cutoutResizeStartScaleY;
        cutoutResizeHasPivot = (typeof cutoutSelectedObject.pivotLocalX === 'number');
        if (cutoutResizeHasPivot && initW2 > 0 && initH2 > 0) {
          cutoutResizeStartPivotRatioX = cutoutSelectedObject.pivotLocalX / initW2;
          cutoutResizeStartPivotRatioY = cutoutSelectedObject.pivotLocalY / initH2;
        } else {
          cutoutResizeStartPivotRatioX = 0.5;
          cutoutResizeStartPivotRatioY = 0.5;
        }
        return;
      }
      // Default: move
      cutoutIsDraggingObj = true;
      imageDragOffsetX = x - cutoutSelectedObject.x;
      imageDragOffsetY = y - cutoutSelectedObject.y;
    // Immediately re-render base without selected and draw overlay to avoid ghost traces
    try { cutoutRenderSelectionOverlay(); } catch (_e) {}
    try { renderCutoutPreviewForTime(); } catch (_e) {}
    }
    
    function cutoutSelectionMouseMove(e) {
      if (!cutoutSelectedObject) return;
      const rect = cutoutMoveOverlayCanvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (cutoutCanvas.width / rect.width);
      const y = (e.clientY - rect.top) * (cutoutCanvas.height / rect.height);
      if (cutoutIsDraggingPivot) {
        const obj = cutoutSelectedObject;
        const objScaleX = (obj && typeof obj.scaleX === 'number') ? obj.scaleX : 1;
        const objScaleY = (obj && typeof obj.scaleY === 'number') ? obj.scaleY : 1;
        const baseW = (obj && obj.drawW != null) ? obj.drawW : ((obj && obj.img && (obj.img.naturalWidth || obj.img.width || obj.img.videoWidth)) || 0);
        const baseH = (obj && obj.drawH != null) ? obj.drawH : ((obj && obj.img && (obj.img.naturalHeight || obj.img.height || obj.img.videoHeight)) || 0);
        const w = baseW * (obj.scale || 1) * objScaleX;
        const h = baseH * (obj.scale || 1) * objScaleY;
        const centerX = obj.x + w / 2;
        const centerY = obj.y + h / 2;
        const rot = obj.rotation || 0;
        const dx = x - centerX;
        const dy = y - centerY;
        const localX = centerX + dx * Math.cos(-rot) - dy * Math.sin(-rot);
        const localY = centerY + dx * Math.sin(-rot) + dy * Math.cos(-rot);
        obj.pivotLocalX = Math.max(0, Math.min(w, localX - obj.x));
        obj.pivotLocalY = Math.max(0, Math.min(h, localY - obj.y));
        // update handle distance baseline so the rotation node follows the pivot
        try {
          const geom = calculateSelectionHandleGeometry(obj);
          const baseLen = Math.hypot(geom.topMid.x - geom.pivot.x, geom.topMid.y - geom.pivot.y);
          obj.rotationHandleDistance = baseLen + ROTATION_HANDLE_OFFSET;
        } catch (_e) {}
        try { cutoutRenderSelectionOverlay(); } catch (_e) {}
        return;
      }
      if (cutoutIsRotatingObj) {
        const currentAngle = Math.atan2(y - rotationCenterY, x - rotationCenterX);
        const angleDelta = currentAngle - rotationStartAngle;
        cutoutSelectedObject.rotation = rotationCurrentAngle + angleDelta;
        // Extend/shrink rotation handle based on projection along handle direction
        const geometry = calculateSelectionHandleGeometry(cutoutSelectedObject);
        if (geometry && geometry.direction) {
          const relX = x - rotationCenterX;
          const relY = y - rotationCenterY;
          const projection = relX * geometry.direction.x + relY * geometry.direction.y;
          cutoutSelectedObject.rotationHandleDistance = Math.max(0, projection);
        }
        // If attached to a bone, shift position to keep start node pinned
        try {
          const activeClip = getActiveCutoutClipIndex();
          let linked = null;
          for (let i = 0; i < cutoutBones.length; i++) {
            const bb = cutoutBones[i];
            if (!bb || bb.clipIndex !== activeClip) continue;
            if (bb.objectRef === cutoutSelectedObject) { linked = bb; break; }
          }
          if (linked) {
            const obj = cutoutSelectedObject;
            const baseW = (obj && obj.drawW != null) ? obj.drawW : ((obj && obj.img && (obj.img.naturalWidth || obj.img.width || obj.img.videoWidth)) || 0);
            const baseH = (obj && obj.drawH != null) ? obj.drawH : ((obj && obj.img && (obj.img.naturalHeight || obj.img.height || obj.img.videoHeight)) || 0);
            const effScaleX = (typeof obj.scaleX === 'number' ? obj.scaleX : 1);
            const effScaleY = (typeof obj.scaleY === 'number' ? obj.scaleY : 1);
            const w = baseW * (obj.scale || 1) * effScaleX;
            const h = baseH * (obj.scale || 1) * effScaleY;
            const px = (typeof linked.pinnedLocalX === 'number') ? linked.pinnedLocalX : 0;
            const py = (typeof linked.pinnedLocalY === 'number') ? linked.pinnedLocalY : 0;
            const rot = obj.rotation || 0;
            const cos = Math.cos(rot), sin = Math.sin(rot);
            const rx = px * cos - py * sin;
            const ry = px * sin + py * cos;
            const centerX = linked.startX - rx;
            const centerY = linked.startY - ry;
            obj.x = centerX - w / 2;
            obj.y = centerY - h / 2;
            // Track position change for bone-linked rotation (position changes to keep bone pinned)
            if (cutoutRecorderArmed) {
              if (!cutoutPendingDragKeys) cutoutPendingDragKeys = {};
              cutoutPendingDragKeys.position = { time: cutoutCurrentTime, x: obj.x, y: obj.y };
            }
          } else {
            // Keep pivot fixed by adjusting position when rotating
            const obj = cutoutSelectedObject;
            const objScaleX = (obj && typeof obj.scaleX === 'number') ? obj.scaleX : 1;
            const objScaleY = (obj && typeof obj.scaleY === 'number') ? obj.scaleY : 1;
            const baseW = (obj && obj.drawW != null) ? obj.drawW : ((obj && obj.img && (obj.img.naturalWidth || obj.img.width || obj.img.videoWidth)) || 0);
            const baseH = (obj && obj.drawH != null) ? obj.drawH : ((obj && obj.img && (obj.img.naturalHeight || obj.img.height || obj.img.videoHeight)) || 0);
            const w = baseW * (obj.scale || 1) * objScaleX;
            const h = baseH * (obj.scale || 1) * objScaleY;
            const dpx = ((typeof obj.pivotLocalX === 'number') ? obj.pivotLocalX : (w / 2)) - (w / 2);
            const dpy = ((typeof obj.pivotLocalY === 'number') ? obj.pivotLocalY : (h / 2)) - (h / 2);
            const rot = obj.rotation || 0;
            const cx = rotationCenterX - (dpx * Math.cos(rot) - dpy * Math.sin(rot));
            const cy = rotationCenterY - (dpx * Math.sin(rot) + dpy * Math.cos(rot));
            obj.x = cx - w / 2;
            obj.y = cy - h / 2;
            // Track position change for pivot-fixed rotation so it persists when recording
            if (cutoutRecorderArmed) {
              if (!cutoutPendingDragKeys) cutoutPendingDragKeys = {};
              cutoutPendingDragKeys.position = { time: cutoutCurrentTime, x: obj.x, y: obj.y };
            }
          }
        } catch (_e) {}
        cutoutRenderSelectionOverlay();
        // Keep the base preview in sync during rotation so no trails remain
        try { scheduleCutoutPreviewForTime(); } catch (_e) {}
        updateCutoutPositionDisplay(cutoutSelectedObject.x, cutoutSelectedObject.y);
        if (cutoutRecorderArmed) {
          const deg = ((cutoutSelectedObject.rotation || 0) * 180) / Math.PI;
          cutoutPendingDragKeys.rotation = { time: cutoutCurrentTime, deg };
        }
        return;
      }
      if (cutoutIsResizingObj) {
        // Uniform scale based on distance change, keep geometric center fixed
        const currentDist = Math.max(1, Math.hypot(x - cutoutResizeStartCenterX, y - cutoutResizeStartCenterY));
        const startAvg = (cutoutResizeStartScaleX + cutoutResizeStartScaleY) / 2;
        const scaleFactor = currentDist / cutoutResizeStartMouseDist;
        const newScale = Math.max(0.1, Math.min(10.0, startAvg * scaleFactor));
        
        // Compute new dimensions
        const newW = cutoutResizeBaseW * cutoutResizeObjScale * newScale;
        const newH = cutoutResizeBaseH * cutoutResizeObjScale * newScale;
        
        // Scale pivotLocalX/Y proportionally to maintain relative pivot position
        // This ensures the central anchor point doesn't shift during scaling
        if (cutoutResizeHasPivot) {
          cutoutSelectedObject.pivotLocalX = cutoutResizeStartPivotRatioX * newW;
          cutoutSelectedObject.pivotLocalY = cutoutResizeStartPivotRatioY * newH;
        }
        
        cutoutSelectedObject.scaleX = newScale;
        cutoutSelectedObject.scaleY = newScale;
        cutoutSelectedObject.x = cutoutResizeStartCenterX - newW / 2;
        cutoutSelectedObject.y = cutoutResizeStartCenterY - newH / 2;
        cutoutRenderSelectionOverlay();
        updateCutoutZoomDisplay(cutoutSelectedObject.scaleX, cutoutSelectedObject.scaleY);
        updateCutoutPositionDisplay(cutoutSelectedObject.x, cutoutSelectedObject.y);
        // Record pending keys while resizing via handles (to mirror slider behavior)
        if (cutoutRecorderArmed) {
          if (!cutoutPendingDragKeys) cutoutPendingDragKeys = {};
          cutoutPendingDragKeys.zoom = { time: cutoutCurrentTime, sx: cutoutSelectedObject.scaleX, sy: cutoutSelectedObject.scaleY };
          cutoutPendingDragKeys.position = { time: cutoutCurrentTime, x: cutoutSelectedObject.x, y: cutoutSelectedObject.y };
        }
        return;
      }
      if (cutoutIsDraggingObj) {
        const newX = x - imageDragOffsetX;
        const newY = y - imageDragOffsetY;
        const dx = newX - cutoutSelectedObject.x;
        const dy = newY - cutoutSelectedObject.y;
        cutoutSelectedObject.x = newX;
        cutoutSelectedObject.y = newY;
        // Move any bones attached to this object along with it
        try {
          const activeClip = getActiveCutoutClipIndex();
          for (let i = 0; i < cutoutBones.length; i++) {
            const b = cutoutBones[i];
            if (!b || b.clipIndex !== activeClip) continue;
            if (b.objectRef === cutoutSelectedObject) {
              b.startX += dx; b.startY += dy;
              b.endX += dx; b.endY += dy;
              // Clamp to canvas
              try {
                const cw = cutoutCanvas ? cutoutCanvas.width : 0;
                const ch = cutoutCanvas ? cutoutCanvas.height : 0;
                if (cw && ch) {
                  b.startX = Math.max(0, Math.min(cw, b.startX));
                  b.startY = Math.max(0, Math.min(ch, b.startY));
                  b.endX = Math.max(0, Math.min(cw, b.endX));
                  b.endY = Math.max(0, Math.min(ch, b.endY));
                }
              } catch (_e) {}
            }
          }
        } catch (_e) {}
        cutoutRenderSelectionOverlay();
        updateCutoutPositionDisplay(cutoutSelectedObject.x, cutoutSelectedObject.y);
        if (cutoutRecorderArmed) {
          cutoutPendingDragKeys.position = { time: cutoutCurrentTime, x: cutoutSelectedObject.x, y: cutoutSelectedObject.y };
        }
      }
    }
    
    function cutoutSelectionMouseUp() {
      if (!cutoutSelectedObject) return;
      // Check if this was a bone-linked rotation - if so, position changed and should be persisted
      let wasBoneLinkedRotation = false;
      try {
        const activeClipUp = getActiveCutoutClipIndex();
        for (let bi = 0; bi < cutoutBones.length; bi++) {
          const bone = cutoutBones[bi];
          if (bone && bone.clipIndex === activeClipUp && bone.objectRef === cutoutSelectedObject) {
            wasBoneLinkedRotation = cutoutIsRotatingObj;
            break;
          }
        }
      } catch (_e) {}
      // Stop interaction but keep selection and overlay active
      cutoutIsDraggingObj = false;
      cutoutIsRotatingObj = false;
      cutoutIsResizingObj = false;
      cutoutIsDraggingPivot = false;
      activeTransformHandle = '';
      cutoutRenderSelectionOverlay();
      renderCutoutPreviewForTime();
      // For bone-linked rotation, ensure position is persisted even without recorder armed
      // This makes the bone-adjusted position the new "memory" state
      if (wasBoneLinkedRotation && !cutoutRecorderArmed) {
        // Update any existing position keyframe at current time to the bone-adjusted position
        try {
          const posKeys = getOrCreatePropKeys('position');
          const epsilon = 1 / 60;
          const existingIdx = posKeys.findIndex(k => Math.abs(k.time - cutoutCurrentTime) <= epsilon);
          if (existingIdx >= 0) {
            posKeys[existingIdx].x = cutoutSelectedObject.x;
            posKeys[existingIdx].y = cutoutSelectedObject.y;
          }
          drawCutoutTimeline();
          updateRowKeyActiveStates();
        } catch (_e) {}
      }
      // Commit any buffered key updates from drag/rotate now that interaction ended
      if (cutoutRecorderArmed && cutoutPendingDragKeys) {
        let committed = false;
        try { saveState(); } catch (_e) {}
        if (cutoutPendingDragKeys.position) {
          const k = cutoutPendingDragKeys.position;
          addOrUpdatePropKeyAt('position', k.time, { x: k.x, y: k.y });
          committed = true;
          cutoutPendingDragKeys.position = null;
        }
        if (cutoutPendingDragKeys.rotation) {
          const k = cutoutPendingDragKeys.rotation;
          addOrUpdatePropKeyAt('rotation', k.time, { deg: k.deg });
          committed = true;
          cutoutPendingDragKeys.rotation = null;
        }
        if (cutoutPendingDragKeys.zoom) {
          const k = cutoutPendingDragKeys.zoom;
          addOrUpdatePropKeyAt('zoom', k.time, { sx: k.sx, sy: k.sy });
          committed = true;
          cutoutPendingDragKeys.zoom = null;
        }
        if (cutoutPendingDragKeys.opacity) {
          const k = cutoutPendingDragKeys.opacity;
          addOrUpdatePropKeyAt('opacity', k.time, { value: k.value });
          committed = true;
          cutoutPendingDragKeys.opacity = null;
        }
        if (committed) {
          drawCutoutTimeline();
          updateRowKeyActiveStates();
        }
      }
      // Do not auto-create/sync keys when not recording; keys are created only via key icons.
      // Just ensure preview reflects latest transforms at the current time.
      try { renderCutoutPreviewForTime(); updateRowKeyActiveStates(); } catch (_e) {}
    }
    
    function pathFromPoints(ctx, points) {
      ctx.beginPath();
      ctx.moveTo(points[0][0], points[0][1]);
      for (let i = 1; i < points.length; i++) ctx.lineTo(points[i][0], points[i][1]);
      ctx.closePath();
    }
    
    function cutoutApplyEraserLasso(ctx, points) {
      // 1) Erase raster within lasso on the clip canvas
      ctx.save();
      pathFromPoints(ctx, points);
      ctx.globalCompositeOperation = 'destination-out';
      ctx.fillStyle = '#000';
      ctx.fill();
      ctx.restore();
      // 2) Segment intersecting image objects in the current cutout clip (breakaway piece removal)
      try {
        const idx = (typeof selectedCutoutClipIndex === 'number' && selectedCutoutClipIndex >= 0)
          ? selectedCutoutClipIndex
          : (typeof getActiveCutoutClipIndexAt === 'function' ? getActiveCutoutClipIndexAt(cutoutCurrentTime) : -1);
        if (idx < 0 || !Array.isArray(cutoutClips)) return;
        const clip = cutoutClips[idx];
        const objects = Array.isArray(clip && clip.objects) ? clip.objects : [];
        if (!objects.length) return;
        // Precompute polygon bbox for quick reject
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        for (const p of points) { if (p[0] < minX) minX = p[0]; if (p[1] < minY) minY = p[1]; if (p[0] > maxX) maxX = p[0]; if (p[1] > maxY) maxY = p[1]; }
        const polyAABB = { x: Math.floor(minX), y: Math.floor(minY), r: Math.ceil(maxX), b: Math.ceil(maxY) };
        const drawPolyPath = (g, ox = 0, oy = 0) => { g.beginPath(); g.moveTo(points[0][0] - ox, points[0][1] - oy); for (let i = 1; i < points.length; i++) g.lineTo(points[i][0] - ox, points[i][1] - oy); g.closePath(); };
        const keep = [];
        for (let i = 0; i < objects.length; i++) {
          const obj = objects[i];
          if (!obj || !obj.img) { keep.push(obj); continue; }
          // AABB overlap with polygon
          const baseW = (obj && obj.drawW != null) ? obj.drawW : ((obj && obj.img && (obj.img.naturalWidth || obj.img.width || obj.img.videoWidth)) || 0);
          const baseH = (obj && obj.drawH != null) ? obj.drawH : ((obj && obj.img && (obj.img.naturalHeight || obj.img.height || obj.img.videoHeight)) || 0);
          const objScaleX = (obj && typeof obj.scaleX === 'number') ? obj.scaleX : 1;
          const objScaleY = (obj && typeof obj.scaleY === 'number') ? obj.scaleY : 1;
          const ow = baseW * (obj.scale || 1) * objScaleX;
          const oh = baseH * (obj.scale || 1) * objScaleY;
          const objAABB = { x: Math.floor(obj.x), y: Math.floor(obj.y), r: Math.ceil(obj.x + ow), b: Math.ceil(obj.y + oh) };
          const overlaps = !(objAABB.r < polyAABB.x || objAABB.x > polyAABB.r || objAABB.b < polyAABB.y || objAABB.y > polyAABB.b);
          if (!overlaps) { keep.push(obj); continue; }
          // Compute rotated object AABB in world coords
          const objScaleX2 = (obj && typeof obj.scaleX === 'number') ? obj.scaleX : 1;
          const objScaleY2 = (obj && typeof obj.scaleY === 'number') ? obj.scaleY : 1;
          const wDraw = baseW * (obj.scale || 1) * objScaleX2;
          const hDraw = baseH * (obj.scale || 1) * objScaleY2;
          const cx = obj.x + wDraw / 2;
          const cy = obj.y + hDraw / 2;
          const rot = obj.rotation || 0;
          const cosR = Math.cos(rot), sinR = Math.sin(rot);
          const corners = [
            { x: obj.x,           y: obj.y },
            { x: obj.x + wDraw,   y: obj.y },
            { x: obj.x + wDraw,   y: obj.y + hDraw },
            { x: obj.x,           y: obj.y + hDraw }
          ].map(p => {
            const dx = p.x - cx, dy = p.y - cy;
            return { x: cx + dx * cosR - dy * sinR, y: cy + dx * sinR + dy * cosR };
          });
          let ax = Infinity, ay = Infinity, ar = -Infinity, ab = -Infinity;
          for (const c of corners) { if (c.x < ax) ax = c.x; if (c.y < ay) ay = c.y; if (c.x > ar) ar = c.x; if (c.y > ab) ab = c.y; }
          ax = Math.floor(ax); ay = Math.floor(ay); ar = Math.ceil(ar); ab = Math.ceil(ab);
          const offW = Math.max(1, ar - ax), offH = Math.max(1, ab - ay);
          // For eraser behavior, do NOT create a new object for the removed piece.
          // Only subtract the polygon from the object and keep the remainder.
          // Rasterize object to offscreen sized to its rotated bounds, subtract polygon, crop remainder
          const off = document.createElement('canvas'); off.width = offW; off.height = offH;
          const octx = off.getContext('2d', { willReadFrequently: true });
          drawRotatedImage(octx, obj, 1, 1, -ax, -ay);
          octx.save();
          drawPolyPath(octx, ax, ay);
          octx.globalCompositeOperation = 'destination-out';
          octx.fillStyle = '#fff';
          octx.fill();
          octx.restore();
          const id = octx.getImageData(0, 0, offW, offH);
          const data = id.data;
          let rx = offW, ry = offH, rr = -1, rb = -1;
          for (let y = 0; y < offH; y++) {
            for (let x = 0; x < offW; x++) {
              const a = data[(y * offW + x) * 4 + 3];
              if (a > 0) { if (x < rx) rx = x; if (y < ry) ry = y; if (x > rr) rr = x; if (y > rb) rb = y; }
            }
          }
          if (rr < rx || rb < ry) {
            // Entire object erased
            continue;
          }
          const cw = Math.max(1, rr - rx + 1);
          const ch = Math.max(1, rb - ry + 1);
          const crop = document.createElement('canvas'); crop.width = cw; crop.height = ch;
          const cctx = crop.getContext('2d');
          cctx.drawImage(off, rx, ry, cw, ch, 0, 0, cw, ch);
          const dataUrl = crop.toDataURL('image/png');
          const img = new Image();
          img.onload = () => {
            // Preserve object's top-left by padding remainder into an aligned canvas
            const oldX = obj.x, oldY = obj.y;
            const baseW0 = (obj && obj.drawW != null)
              ? obj.drawW
              : ((obj && obj.img && (obj.img.naturalWidth || obj.img.width || obj.img.videoWidth)) || 0);
            const baseH0 = (obj && obj.drawH != null)
              ? obj.drawH
              : ((obj && obj.img && (obj.img.naturalHeight || obj.img.height || obj.img.videoHeight)) || 0);
            const effScaleX0 = (obj && typeof obj.scaleX === 'number') ? obj.scaleX : 1;
            const effScaleY0 = (obj && typeof obj.scaleY === 'number') ? obj.scaleY : 1;
            const oldDrawW = Math.max(1, Math.round(baseW0 * (obj.scale || 1) * effScaleX0));
            const oldDrawH = Math.max(1, Math.round(baseH0 * (obj.scale || 1) * effScaleY0));
            const aligned = document.createElement('canvas'); aligned.width = oldDrawW; aligned.height = oldDrawH;
            const actx = aligned.getContext('2d');
            const offsetX = Math.max(0, Math.round((ax + rx) - oldX));
            const offsetY = Math.max(0, Math.round((ay + ry) - oldY));
            actx.drawImage(img, offsetX, offsetY);
            // Preserve existing transform (scale/rotation) so bones stay aligned
            const prevScale = obj.scale;
            const prevScaleX = obj.scaleX;
            const prevScaleY = obj.scaleY;
            const prevRotation = obj.rotation;
            obj.img = aligned;
            obj.src = aligned.toDataURL('image/png');
            obj.x = oldX; obj.y = oldY;
            obj.scale = prevScale;
            obj.scaleX = prevScaleX;
            obj.scaleY = prevScaleY;
            obj.rotation = prevRotation;
            // Avoid double-scaling: derive base draw size from the new raster size and current scales
            const safeScale = (prevScale || 1) * (prevScaleX || 1);
            const safeScaleY = (prevScale || 1) * (prevScaleY || 1);
            obj.drawW = safeScale ? aligned.width / safeScale : aligned.width;
            obj.drawH = safeScaleY ? aligned.height / safeScaleY : aligned.height;
            obj.isImage = true;
            // Keep existing keys; do not clear rotation/zoom so bone-linked transforms remain intact
            renderCutoutPreviewForTime && renderCutoutPreviewForTime();
          };
          img.src = dataUrl;
          keep.push(obj);
        }
        clip.objects = keep;
      } catch (_e) { /* ignore cutout segmentation failures */ }
    }
    
    // cutoutApplyMirrorLasso removed (Flip Region disabled)
    
    function cutoutApplyDetailLasso(ctx, points) {
      // Simple contrast/brightness enhancement within lasso
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      for (const p of points) { if (p[0] < minX) minX = p[0]; if (p[1] < minY) minY = p[1]; if (p[0] > maxX) maxX = p[0]; if (p[1] > maxY) maxY = p[1]; }
      const w = Math.max(1, Math.round(maxX - minX));
      const h = Math.max(1, Math.round(maxY - minY));
      try {
        const img = ctx.getImageData(minX, minY, w, h);
        const data = img.data;
        // Build a mask by rasterizing polygon into offscreen alpha
        const mask = document.createElement('canvas');
        mask.width = w; mask.height = h;
        const mctx = mask.getContext('2d');
        mctx.save();
        mctx.translate(-minX, -minY);
        pathFromPoints(mctx, points);
        mctx.fillStyle = '#fff'; mctx.fill();
        mctx.restore();
        const maskData = mctx.getImageData(0, 0, w, h).data;
        // Apply contrast/saturation boost where mask alpha > 0
        const contrast = 1.25; // 25% boost
        const brightness = 8; // slight brighten
        for (let i = 0; i < data.length; i += 4) {
          if (maskData[i + 3] > 0) {
            // contrast
            data[i] = Math.max(0, Math.min(255, (data[i] - 128) * contrast + 128 + brightness));
            data[i + 1] = Math.max(0, Math.min(255, (data[i + 1] - 128) * contrast + 128 + brightness));
            data[i + 2] = Math.max(0, Math.min(255, (data[i + 2] - 128) * contrast + 128 + brightness));
          }
        }
        ctx.putImageData(img, minX, minY);
      } catch (_e) { /* ignore */ }
    }
    
    function cutoutApplyInbetweenLasso(ctx, points) {
      // Lightweight motion-like smear within selection
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      for (const p of points) { if (p[0] < minX) minX = p[0]; if (p[1] < minY) minY = p[1]; if (p[0] > maxX) maxX = p[0]; if (p[1] > maxY) maxY = p[1]; }
      const w = Math.max(1, Math.round(maxX - minX));
      const h = Math.max(1, Math.round(maxY - minY));
      try {
        const src = ctx.getImageData(minX, minY, w, h);
        const off = document.createElement('canvas');
        off.width = w; off.height = h;
        const octx = off.getContext('2d');
        octx.putImageData(src, 0, 0);
        ctx.save();
        pathFromPoints(ctx, points);
        ctx.clip();
        ctx.globalAlpha = 0.6;
        ctx.drawImage(off, minX + 2, minY); // slight offset for "tween"
        ctx.globalAlpha = 1;
        ctx.restore();
      } catch (_e) { /* ignore */ }
    }
    
    // Helper: build polygon bbox and mask
    function buildLassoMask(points) {
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      for (const p of points) { if (p[0] < minX) minX = p[0]; if (p[1] < minY) minY = p[1]; if (p[0] > maxX) maxX = p[0]; if (p[1] > maxY) maxY = p[1]; }
      minX = Math.max(0, Math.floor(minX));
      minY = Math.max(0, Math.floor(minY));
      maxX = Math.ceil(maxX);
      maxY = Math.ceil(maxY);
      const bw = Math.max(1, maxX - minX);
      const bh = Math.max(1, maxY - minY);
      const maskCanvas = document.createElement('canvas');
      maskCanvas.width = bw; maskCanvas.height = bh;
      const maskCtx = maskCanvas.getContext('2d', { willReadFrequently: true });
      maskCtx.save();
      maskCtx.translate(-minX, -minY);
      pathFromPoints(maskCtx, points);
      maskCtx.fillStyle = '#fff';
      maskCtx.fill();
      maskCtx.restore();
      const maskData = maskCtx.getImageData(0, 0, bw, bh).data;
      return { minX, minY, bw, bh, maskData };
    }
    
    // State: repeatable extend masks
    let extendMasks = []; // per-frame -> per-layer -> {canvas, ctx}
    function getExtendMaskFor(frameIndex, layerIndex, w, h) {
      if (!extendMasks[frameIndex]) extendMasks[frameIndex] = [];
      let slot = extendMasks[frameIndex][layerIndex];
      if (!slot || slot.canvas.width !== w || slot.canvas.height !== h) {
        const c = document.createElement('canvas');
        c.width = w; c.height = h;
        const cx = c.getContext('2d', { willReadFrequently: true });
        extendMasks[frameIndex][layerIndex] = slot = { canvas: c, ctx: cx };
      }
      return slot;
    }
    
    let cutoutExtendMasks = {}; // by clip index -> {canvas, ctx}
    function getCutoutExtendMaskFor(clipIndex, w, h) {
      let slot = cutoutExtendMasks[clipIndex];
      if (!slot || slot.canvas.width !== w || slot.canvas.height !== h) {
        const c = document.createElement('canvas');
        c.width = w; c.height = h;
        const cx = c.getContext('2d', { willReadFrequently: true });
        cutoutExtendMasks[clipIndex] = slot = { canvas: c, ctx: cx };
      }
      return slot;
    }
    
    // Palette-based synthesis helpers for Extend Lasso
    function buildDominantPalette(baseData, maskData, bw, bh, bins = 8, maxColors = 5) {
      const binSize = 256 / bins;
      const map = new Map(); // key -> {count,sumR,sumG,sumB}
      let total = 0;
      for (let i = 0; i < baseData.length; i += 4) {
        if (maskData[i + 3] === 0 || baseData[i + 3] === 0) continue;
        const r = baseData[i], g = baseData[i + 1], b = baseData[i + 2];
        const rb = Math.min(bins - 1, Math.floor(r / binSize));
        const gb = Math.min(bins - 1, Math.floor(g / binSize));
        const bb = Math.min(bins - 1, Math.floor(b / binSize));
        const key = (rb << 16) | (gb << 8) | bb;
        let v = map.get(key);
        if (!v) { v = { count: 0, sumR: 0, sumG: 0, sumB: 0 }; map.set(key, v); }
        v.count++; v.sumR += r; v.sumG += g; v.sumB += b; total++;
      }
      const entries = Array.from(map.entries()).sort((a, b) => b[1].count - a[1].count);
      const palette = [];
      for (let i = 0; i < entries.length && palette.length < maxColors; i++) {
        const v = entries[i][1];
        const c = { r: Math.round(v.sumR / v.count), g: Math.round(v.sumG / v.count), b: Math.round(v.sumB / v.count), weight: v.count / Math.max(1, total) };
        palette.push(c);
      }
      if (palette.length === 0) return [];
      // Normalize weights
      let sumW = palette.reduce((s, c) => s + c.weight, 0);
      if (sumW <= 0) sumW = 1;
      palette.forEach(c => { c.weight = c.weight / sumW; });
      return palette;
    }
    function nearestPaletteIndex(r, g, b, palette) {
      let best = 0; let bestD = Infinity;
      for (let i = 0; i < palette.length; i++) {
        const c = palette[i];
        const dr = r - c.r, dg = g - c.g, db = b - c.b;
        const d = dr * dr + dg * dg + db * db;
        if (d < bestD) { bestD = d; best = i; }
      }
      return best;
    }
    function buildColumnPaletteWeights(baseData, maskData, bw, bh, palette) {
      const K = palette.length;
      const colWeights = new Array(bw);
      for (let x = 0; x < bw; x++) {
        const counts = new Array(K).fill(0);
        let total = 0;
        for (let y = 0; y < bh; y++) {
          const idx = (y * bw + x) * 4;
          if (maskData[idx + 3] === 0 || baseData[idx + 3] === 0) continue;
          const i = nearestPaletteIndex(baseData[idx], baseData[idx + 1], baseData[idx + 2], palette);
          counts[i]++; total++;
        }
        if (total === 0) {
          colWeights[x] = null; // fallback to global
        } else {
          const weights = counts.map(v => v / total);
          colWeights[x] = weights;
        }
      }
      return colWeights;
    }
    function rand01(x, y) {
      // Simple integer hash -> [0,1)
      let n = (x * 374761393 + y * 668265263) | 0;
      n = (n ^ (n >>> 13)) * 1274126177 | 0;
      n = (n ^ (n >>> 16)) >>> 0;
      return n / 4294967296;
    }
    function sampleIndexFromWeights(weights, r) {
      let acc = 0;
      for (let i = 0; i < weights.length; i++) {
        acc += weights[i];
        if (r <= acc) return i;
      }
      return weights.length - 1;
    }
    function computeStrayRadiusPx(bw) {
      // Up to ~6px, scaled by 5% of selection width
      return Math.max(1, Math.min(6, Math.round(bw * 0.05)));
    }
    function fillMaskWithPalette(palette, globalWeights, colWeights, maskData, bw, bh, verticalCoherence, horizontalJitter, strayPercent = 0.05, strayRadiusPx = null, noiseAmt = 2, slipMaxPx = 2, slipStepProb = 0.2, smearAmt = 0.15, smearMaxRadius = 2) {
      const out = new Uint8ClampedArray(bw * bh * 4);
      const strayRadius = (typeof strayRadiusPx === 'number' && strayRadiusPx >= 1) ? Math.floor(strayRadiusPx) : computeStrayRadiusPx(bw);
      // Per-column horizontal slip (random walk) to reduce perfect straightness
      const slip = new Int16Array(bw);
      // Top-down pass with vertical coherence, light horizontal mixing, and slip
      for (let x = 0; x < bw; x++) {
        const weights = colWeights[x] || globalWeights;
        let prev = null;
        for (let y = 0; y < bh; y++) {
          const idx = (y * bw + x) * 4;
          if (maskData[idx + 3] === 0) continue;
          // Random-walk slip update per column
          if (slipMaxPx > 0 && slipStepProb > 0 && rand01(x * 97 + 3, y * 101 + 7) < slipStepProb) {
            const delta = (rand01(x * 103 + 11, y * 107 + 13) < 0.5) ? -1 : 1;
            let s = slip[x] + delta;
            if (s < -slipMaxPx) s = -slipMaxPx;
            if (s > slipMaxPx) s = slipMaxPx;
            slip[x] = s;
          }
          // With small probability, "stray" to neighbor column's distribution
          let useX = x;
          if (slip[x] !== 0) {
            useX = Math.max(0, Math.min(bw - 1, x + slip[x]));
          }
          if (strayPercent > 0) {
            const p = rand01(x * 13 + 7, y * 17 + 3);
            if (p < strayPercent) {
              const dir = (rand01(x * 19 + 11, y * 23 + 5) < 0.5) ? -1 : 1;
              const mag = 1 + Math.floor(rand01(x * 29 + 13, y * 31 + 7) * strayRadius);
              useX = Math.max(0, Math.min(bw - 1, x + dir * mag));
            }
          }
          const wsrc = colWeights[useX] || globalWeights;
          const r = rand01(useX, y);
          const pickIdx = sampleIndexFromWeights(wsrc, r);
          const base = palette[pickIdx];
          let cr = base.r, cg = base.g, cb = base.b;
          if (prev) {
            cr = Math.round(prev.r * verticalCoherence + base.r * (1 - verticalCoherence));
            cg = Math.round(prev.g * verticalCoherence + base.g * (1 - verticalCoherence));
            cb = Math.round(prev.b * verticalCoherence + base.b * (1 - verticalCoherence));
          }
          // Horizontal jitter by mixing left neighbor at same row
          if (horizontalJitter > 0 && x > 0) {
            const li = (y * bw + (x - 1)) * 4;
            if (maskData[li + 3] > 0 && out[li + 3] > 0) {
              cr = Math.round(cr * (1 - horizontalJitter) + out[li] * horizontalJitter);
              cg = Math.round(cg * (1 - horizontalJitter) + out[li + 1] * horizontalJitter);
              cb = Math.round(cb * (1 - horizontalJitter) + out[li + 2] * horizontalJitter);
            }
          }
          // Very small per-pixel dithering to avoid overly smooth look
          if (noiseAmt > 0) {
            const n1 = rand01(x * 37 + 17, y * 41 + 19) * 2 - 1;
            const n2 = rand01(x * 43 + 23, y * 47 + 29) * 2 - 1;
            const n3 = rand01(x * 53 + 31, y * 59 + 37) * 2 - 1;
            cr = Math.max(0, Math.min(255, Math.round(cr + n1 * noiseAmt)));
            cg = Math.max(0, Math.min(255, Math.round(cg + n2 * noiseAmt)));
            cb = Math.max(0, Math.min(255, Math.round(cb + n3 * noiseAmt)));
          }
          out[idx] = cr; out[idx + 1] = cg; out[idx + 2] = cb; out[idx + 3] = 255;
          prev = { r: cr, g: cg, b: cb };
        }
      }
      // Bottom-up subtle blend to reduce top-only bias
      for (let x = 0; x < bw; x++) {
        for (let y = bh - 2; y >= 0; y--) {
          const idx = (y * bw + x) * 4;
          if (maskData[idx + 3] === 0) continue;
          const bi = ((y + 1) * bw + x) * 4;
          if (maskData[bi + 3] === 0 || out[bi + 3] === 0) continue;
          out[idx] = Math.round(out[idx] * 0.85 + out[bi] * 0.15);
          out[idx + 1] = Math.round(out[idx + 1] * 0.85 + out[bi + 1] * 0.15);
          out[idx + 2] = Math.round(out[idx + 2] * 0.85 + out[bi + 2] * 0.15);
          out[idx + 3] = 255;
        }
      }
      // Horizontal smear pass to add subtle lateral blending "smear" illusion
      if (smearAmt > 0 && smearMaxRadius > 0) {
        const src = out.slice();
        for (let y = 0; y < bh; y++) {
          const radius = 1 + Math.floor(rand01(1237, y * 7919 + 17) * smearMaxRadius);
          const kernelSize = radius * 2 + 1;
          // triangular weights
          let denom = 0;
          const weights = new Array(kernelSize);
          for (let dx = -radius; dx <= radius; dx++) {
            const w = radius + 1 - Math.abs(dx);
            weights[dx + radius] = w;
            denom += w;
          }
          for (let x = 0; x < bw; x++) {
            const idx = (y * bw + x) * 4;
            if (maskData[idx + 3] === 0 || src[idx + 3] === 0) continue;
            let ar = 0, ag = 0, ab = 0, aw = 0;
            for (let dx = -radius; dx <= radius; dx++) {
              const xx = x + dx;
              if (xx < 0 || xx >= bw) continue;
              const wi = weights[dx + radius];
              const pi = (y * bw + xx) * 4;
              if (maskData[pi + 3] === 0 || src[pi + 3] === 0) continue;
              ar += src[pi] * wi;
              ag += src[pi + 1] * wi;
              ab += src[pi + 2] * wi;
              aw += wi;
            }
            if (aw > 0) {
              const nr = Math.round(ar / aw);
              const ng = Math.round(ag / aw);
              const nb = Math.round(ab / aw);
              out[idx] = Math.round(src[idx] * (1 - smearAmt) + nr * smearAmt);
              out[idx + 1] = Math.round(src[idx + 1] * (1 - smearAmt) + ng * smearAmt);
              out[idx + 2] = Math.round(src[idx + 2] * (1 - smearAmt) + nb * smearAmt);
              out[idx + 3] = 255;
            }
          }
        }
      }
      return out;
    }
    
    // Helper: tile selected object's pixels into blank areas inside polygon (repeatable; uses mask)
    function extendLassoWithObjects(ctx, points, objects, maskSlot) {
      const { minX, minY, bw, bh, maskData } = buildLassoMask(points);
      // Find topmost object that contributes pixels inside polygon
      let objAlphaData = null;
      let targetObj = null;
      if (Array.isArray(objects) && objects.length) {
        for (let k = objects.length - 1; k >= 0; k--) {
          const obj = objects[k];
          if (!obj || !obj.img) continue;
          const off = document.createElement('canvas');
          off.width = bw; off.height = bh;
          const octx = off.getContext('2d', { willReadFrequently: true });
          try { drawRotatedImage(octx, obj, 1, 1, -minX, -minY); } catch (_e) {}
          const od = octx.getImageData(0, 0, bw, bh).data;
          let contributes = false;
          for (let i = 0; i < od.length; i += 4) {
            if (maskData[i + 3] > 0 && od[i + 3] > 0) { contributes = true; break; }
          }
          if (contributes) { objAlphaData = od; targetObj = obj; break; }
        }
      }
      // Ignore colors previously created by Extend Lasso by zeroing out pixels marked in the repeatable mask
      if (objAlphaData && maskSlot && maskSlot.ctx) {
        try {
          const prior = maskSlot.ctx.getImageData(minX, minY, bw, bh).data;
          const filtered = new Uint8ClampedArray(objAlphaData);
          for (let i = 0; i < filtered.length; i += 4) {
            // If mask alpha > 0, this pixel was generated by Extend Lasso earlier; exclude it from palette
            if (prior[i + 3] > 0) {
              filtered[i] = 0; filtered[i + 1] = 0; filtered[i + 2] = 0; filtered[i + 3] = 0;
            }
          }
          objAlphaData = filtered;
        } catch (_e) { /* ignore */ }
      }
      if (!objAlphaData) return false;
      // Build palette from the object's pixels within the lasso
      const palette = buildDominantPalette(objAlphaData, maskData, bw, bh, 8, 5);
      if (!palette.length) return false;
      const globalWeights = palette.map(c => c.weight);
      const colWeights = buildColumnPaletteWeights(objAlphaData, maskData, bw, bh, palette);
      // Synthesize full-coverage fill for the entire mask using palette with vertical coherence and slight horizontal jitter
      const fillData = fillMaskWithPalette(palette, globalWeights, colWeights, maskData, bw, bh, 0.9, 0.1, 0.05, computeStrayRadiusPx(bw), 2);
      // Compose: clip to polygon (do not subtract existing coverage so new extend overlays previous)
      const outCanvas = document.createElement('canvas');
      outCanvas.width = bw; outCanvas.height = bh;
      const outCtx = outCanvas.getContext('2d');
      const outImage = new ImageData(fillData, bw, bh);
      outCtx.putImageData(outImage, 0, 0);
      outCtx.save();
      outCtx.globalCompositeOperation = 'destination-in';
      const polyMask = document.createElement('canvas');
      polyMask.width = bw; polyMask.height = bh;
      const pmx = polyMask.getContext('2d');
      pmx.save(); pmx.translate(-minX, -minY); pathFromPoints(pmx, points); pmx.fillStyle = '#fff'; pmx.fill(); pmx.restore();
      outCtx.drawImage(polyMask, 0, 0);
      outCtx.restore();
      // 4) Persist: merge extended area into the contributing image object (no new objects), without changing its position
      try {
        if (targetObj && targetObj.img) {
          const oldX = targetObj.x;
          const oldY = targetObj.y;
          // Current unrotated draw size
          const baseW = (targetObj && targetObj.drawW != null)
            ? targetObj.drawW
            : ((targetObj && targetObj.img && (targetObj.img.naturalWidth || targetObj.img.width || targetObj.img.videoWidth)) || 0);
          const baseH = (targetObj && targetObj.drawH != null)
            ? targetObj.drawH
            : ((targetObj && targetObj.img && (targetObj.img.naturalHeight || targetObj.img.height || targetObj.img.videoHeight)) || 0);
          const effScaleX = (targetObj && typeof targetObj.scaleX === 'number') ? targetObj.scaleX : 1;
          const effScaleY = (targetObj && typeof targetObj.scaleY === 'number') ? targetObj.scaleY : 1;
          const oldDrawW = Math.max(1, Math.round(baseW * (targetObj.scale || 1) * effScaleX));
          const oldDrawH = Math.max(1, Math.round(baseH * (targetObj.scale || 1) * effScaleY));
          // New canvas size keeps original top-left at (0,0) to preserve x,y on screen
          const newW = Math.max(oldDrawW, (minX + bw) - oldX);
          const newH = Math.max(oldDrawH, (minY + bh) - oldY);
          const merged = document.createElement('canvas');
          merged.width = Math.max(1, Math.ceil(newW));
          merged.height = Math.max(1, Math.ceil(newH));
          const mctx = merged.getContext('2d', { willReadFrequently: true });
          // Draw original object anchored so its top-left remains at (0,0)
          try { drawRotatedImage(mctx, targetObj, 1, 1, -oldX, -oldY); } catch (_e) {}
          // Draw extended fill at its relative offset from old top-left
          mctx.save();
          mctx.globalCompositeOperation = 'source-over';
          mctx.drawImage(outCanvas, minX - oldX, minY - oldY);
          mctx.restore();
          // Update target object to merged; bake transforms and keep position unchanged
          const dataUrl = merged.toDataURL('image/png');
          const newImg = new Image();
          newImg.onload = () => {
            targetObj.img = newImg;
            targetObj.src = dataUrl;
            // Preserve original position values
            targetObj.x = oldX;
            targetObj.y = oldY;
            targetObj.drawW = merged.width;
            targetObj.drawH = merged.height;
            targetObj.isImage = true;
            // Bake transforms
            targetObj.scale = 1; targetObj.scaleX = 1; targetObj.scaleY = 1; targetObj.rotation = 0;
            // Clear zoom/rotation keys to avoid reapplying transforms
            if (targetObj.keys) {
              if (Array.isArray(targetObj.keys.zoom)) targetObj.keys.zoom = [];
              if (Array.isArray(targetObj.keys.rotation)) targetObj.keys.rotation = [];
            }
            // Ensure preview/UI reflect changes
            try { renderCutoutPreviewForTime && renderCutoutPreviewForTime(); } catch (_e) {}
            if (typeof renderCutoutObjectsList === 'function') renderCutoutObjectsList();
          };
          // Immediately set canvas to avoid flicker before Image load
          targetObj.img = merged;
          targetObj.src = dataUrl;
          newImg.src = dataUrl;
          try { saveState(); } catch (_e) {}
        }
      } catch (_e) { /* ignore extend update errors */ }
      // Record newly extended pixels into repeatable mask so future extensions ignore synthesized colors
      try {
        if (maskSlot && maskSlot.ctx) {
          const mctx = maskSlot.ctx;
          mctx.save();
          mctx.globalCompositeOperation = 'source-over';
          mctx.drawImage(outCanvas, minX, minY);
          mctx.restore();
        }
      } catch (_e) { /* ignore */ }
      return true;
    }
    
    // Fallback: sample from existing raster within polygon (for brush-only content), repeatable
    function extendLassoFromExistingRaster(ctx, points, maskSlot) {
      const { minX, minY, bw, bh, maskData } = buildLassoMask(points);
      const existing = ctx.getImageData(minX, minY, bw, bh);
      let existingData = existing.data;
      // Ignore previously extended pixels when sampling palette so we only sample original/segmented parts
      if (maskSlot && maskSlot.ctx) {
        try {
          const prior = maskSlot.ctx.getImageData(minX, minY, bw, bh).data;
          const filtered = new Uint8ClampedArray(existingData);
          for (let i = 0; i < filtered.length; i += 4) {
            if (prior[i + 3] > 0) {
              // zero alpha to exclude extended pixels from sampling
              filtered[i] = 0; filtered[i + 1] = 0; filtered[i + 2] = 0; filtered[i + 3] = 0;
            }
          }
          existingData = filtered;
        } catch (_e) { /* ignore */ }
      }
      // Ensure there is some seed inside the mask
      let hasAny = false;
      for (let i = 0; i < existingData.length; i += 4) {
        if (maskData[i + 3] > 0 && existingData[i + 3] > 0) { hasAny = true; break; }
      }
      if (!hasAny) return false;
      // Build palette from existing raster and synthesize full-coverage fill
      const palette = buildDominantPalette(existingData, maskData, bw, bh, 8, 5);
      if (!palette.length) return false;
      const globalWeights = palette.map(c => c.weight);
      const colWeights = buildColumnPaletteWeights(existingData, maskData, bw, bh, palette);
      const fillData = fillMaskWithPalette(palette, globalWeights, colWeights, maskData, bw, bh, 0.9, 0.1, 0.05, computeStrayRadiusPx(bw), 2);
      // Compose: clip to polygon and subtract original coverage (existing raster)
      const srcOffscreen = document.createElement('canvas');
      srcOffscreen.width = bw; srcOffscreen.height = bh;
      const srcCtx = srcOffscreen.getContext('2d', { willReadFrequently: true });
      srcCtx.putImageData(existing, 0, 0);
      const outCanvas = document.createElement('canvas');
      outCanvas.width = bw; outCanvas.height = bh;
      const outCtx = outCanvas.getContext('2d');
      outCtx.putImageData(new ImageData(fillData, bw, bh), 0, 0);
      outCtx.save();
      outCtx.globalCompositeOperation = 'destination-in';
      const polyMask = document.createElement('canvas');
      polyMask.width = bw; polyMask.height = bh;
      const pmx = polyMask.getContext('2d');
      pmx.save(); pmx.translate(-minX, -minY); pathFromPoints(pmx, points); pmx.fillStyle = '#fff'; pmx.fill(); pmx.restore();
      outCtx.drawImage(polyMask, 0, 0);
      outCtx.restore();
      outCtx.save();
      outCtx.globalCompositeOperation = 'destination-out';
      outCtx.drawImage(srcOffscreen, 0, 0);
      outCtx.restore();
      // 4) Repeatability: clear previously extended pixels inside polygon before drawing new fill
      if (maskSlot && maskSlot.canvas) {
        ctx.save();
        pathFromPoints(ctx, points);
        ctx.clip();
        ctx.globalCompositeOperation = 'destination-out';
        ctx.drawImage(maskSlot.canvas, 0, 0);
        ctx.restore();
        const mctx = maskSlot.ctx;
        mctx.save();
        mctx.globalCompositeOperation = 'destination-out';
        const clearPoly = document.createElement('canvas');
        clearPoly.width = ctx.canvas.width; clearPoly.height = ctx.canvas.height;
        const cpx = clearPoly.getContext('2d');
        cpx.save(); pathFromPoints(cpx, points); cpx.fillStyle = '#fff'; cpx.fill(); cpx.restore();
        mctx.drawImage(clearPoly, 0, 0);
        mctx.restore();
      }
      // 5) Draw and update mask
      ctx.save();
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      ctx.drawImage(outCanvas, minX, minY);
      ctx.restore();
      if (maskSlot && maskSlot.ctx) {
        const mctx = maskSlot.ctx;
        mctx.save();
        mctx.globalCompositeOperation = 'source-over';
        mctx.drawImage(outCanvas, minX, minY);
        mctx.restore();
      }
      return true;
    }
    
    // Regular mode: extend from imported image segments when available; otherwise from raster
    function applyExtendLasso(ctx, points) {
      try {
        const layer = (Array.isArray(frameLayers) && frameLayers[currentFrame] && frameLayers[currentFrame][currentLayer]) ? frameLayers[currentFrame][currentLayer] : null;
        const objects = (layer && Array.isArray(layer.images)) ? layer.images : [];
        const maskSlot = layer ? getExtendMaskFor(currentFrame, currentLayer, layer.canvas.width, layer.canvas.height) : null;
        const ok = extendLassoWithObjects(ctx, points, objects, maskSlot);
        if (ok) return;
      } catch (_e) { /* ignore and fall through */ }
      try {
        const layer = (Array.isArray(frameLayers) && frameLayers[currentFrame] && frameLayers[currentFrame][currentLayer]) ? frameLayers[currentFrame][currentLayer] : null;
        const maskSlot = layer ? getExtendMaskFor(currentFrame, currentLayer, layer.canvas.width, layer.canvas.height) : null;
        extendLassoFromExistingRaster(ctx, points, maskSlot);
      } catch (_e2) { /* ignore */ }
    }
    
    function cutoutApplyExtendLasso(ctx, points) {
      try {
        const idx = (typeof selectedCutoutClipIndex === 'number' && selectedCutoutClipIndex >= 0) ? selectedCutoutClipIndex : (typeof getActiveCutoutClipIndexAt === 'function' ? getActiveCutoutClipIndexAt(cutoutCurrentTime) : -1);
        const clip = (idx >= 0 && Array.isArray(cutoutClips)) ? cutoutClips[idx] : null;
        const objects = (clip && Array.isArray(clip.objects)) ? clip.objects : [];
        const maskSlot = clip ? getCutoutExtendMaskFor(idx, clip.canvas.width, clip.canvas.height) : null;
        const ok = extendLassoWithObjects(ctx, points, objects, maskSlot);
        if (ok) return;
      } catch (_e) { /* ignore and fall through */ }
      try {
        const idx = (typeof selectedCutoutClipIndex === 'number' && selectedCutoutClipIndex >= 0) ? selectedCutoutClipIndex : (typeof getActiveCutoutClipIndexAt === 'function' ? getActiveCutoutClipIndexAt(cutoutCurrentTime) : -1);
        const clip = (idx >= 0 && Array.isArray(cutoutClips)) ? cutoutClips[idx] : null;
        const maskSlot = clip ? getCutoutExtendMaskFor(idx, clip.canvas.width, clip.canvas.height) : null;
        extendLassoFromExistingRaster(ctx, points, maskSlot);
      } catch (_e2) { /* ignore */ }
    }
    
    function renderCutoutClips() {
      const track = document.getElementById('cutout-ruler-area');
      const clipsContainer = document.getElementById('cutout-timeline-clips');
      if (!track || !clipsContainer) return;
      const rect = track.getBoundingClientRect();
      const pixelsPerSecond = 60;
      clipsContainer.innerHTML = '';
      for (let idx = 0; idx < cutoutClips.length; idx++) {
        const clip = cutoutClips[idx];
        const startLeft = Math.max(0, Math.min(rect.width, (clip.start / cutoutDuration) * rect.width));
        const clipWidth = Math.max(6, Math.min(rect.width - startLeft, (clip.end - clip.start) * pixelsPerSecond));
        const el = document.createElement('div');
        el.style.position = 'absolute';
        el.style.left = `${startLeft}px`;
        el.style.width = `${clipWidth}px`;
        el.style.top = '0';
        el.style.bottom = '0';
        el.style.border = selectedCutoutClipIndex === idx ? '1px solid #6366f1' : '1px solid #2a2a2a';
        el.style.borderRadius = '2px';
        el.style.overflow = 'hidden';
        el.style.background = '#111';
        el.style.pointerEvents = 'auto';
        el.style.userSelect = 'none';
        el.addEventListener('mousedown', (e) => {
          e.stopPropagation();
          selectedCutoutClipIndex = idx;
          renderCutoutClips();
          startCutoutClipDrag(e, idx);
        });
        // Effects icons bar inside clip
        const iconsBar = document.createElement('div');
        iconsBar.style.position = 'absolute';
        iconsBar.style.left = '4px';
        iconsBar.style.top = '2px';
        iconsBar.style.display = 'flex';
        iconsBar.style.gap = '4px';
        iconsBar.style.alignItems = 'center';
        iconsBar.style.zIndex = '3';
        const effects = Array.isArray(clip.effects) ? clip.effects : [];
        const mkIcon = (id) => {
          const wrap = document.createElement('div');
          wrap.title = id;
          wrap.style.width = '14px';
          wrap.style.height = '14px';
          wrap.style.opacity = '0.9';
          wrap.style.color = '#9ca3af';
          wrap.style.display = 'flex';
          wrap.style.alignItems = 'center';
          wrap.style.justifyContent = 'center';
          wrap.style.border = '1px solid #2a2a2a';
          wrap.style.borderRadius = '3px';
          wrap.style.cursor = 'pointer';
          // Selection highlight for effect marker
          if (selectedCutoutEffectClipIndex === idx && selectedCutoutEffectId === id) {
            wrap.style.border = '1px solid #fde68a';
            wrap.style.boxShadow = '0 0 6px rgba(251,191,36,0.6)';
          }
          let svg = '';
          if (id === 'oldTV') {
            svg = '<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="6" width="18" height="12" rx="2"/><path d="M7 18v2M17 18v2"/></svg>';
          } else if (id === 'snow') {
            svg = '<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2v20M4 6l16 12M20 6L4 18"/></svg>';
          } else if (id === 'rain') {
            svg = '<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M6 4v4M12 4v6M18 4v5"/><path d="M5 20l2-3M11 20l2-3M17 20l2-3"/></svg>';
          } else if (id === 'oldFilm') {
            svg = '<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="4" y="3" width="4" height="18" rx="1"/><rect x="12" y="3" width="8" height="18" rx="1"/><path d="M6 7h0M6 12h0M6 17h0"/></svg>';
          } else if (id === 'analogHorror') {
            svg = '<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="5" width="18" height="14" rx="2"/><path d="M6 9h6M15 12h4M7 14h3"/></svg>';
          } else {
            svg = '<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="4"/></svg>';
          }
          wrap.innerHTML = svg;
          wrap.addEventListener('mousedown', (e) => {
            e.stopPropagation();
            selectedCutoutEffectClipIndex = idx;
            selectedCutoutEffectId = id;
            renderCutoutClips();
          });
          return wrap;
        };
        effects.forEach(id => iconsBar.appendChild(mkIcon(id)));
        el.appendChild(iconsBar);
        // left and right resize handles
        const leftRib = document.createElement('div');
        leftRib.style.position = 'absolute';
        leftRib.style.left = '-3px';
        leftRib.style.top = '0';
        leftRib.style.bottom = '0';
        leftRib.style.width = '6px';
        leftRib.style.cursor = 'ew-resize';
        leftRib.style.background = 'transparent';
        leftRib.addEventListener('mousedown', (e) => startCutoutClipResize(e, idx, 'left'));
        const rightRib = document.createElement('div');
        rightRib.style.position = 'absolute';
        rightRib.style.right = '-3px';
        rightRib.style.top = '0';
        rightRib.style.bottom = '0';
        rightRib.style.width = '6px';
        rightRib.style.cursor = 'ew-resize';
        rightRib.style.background = 'transparent';
        rightRib.addEventListener('mousedown', (e) => startCutoutClipResize(e, idx, 'right'));
        // thumbnail
        const img = document.createElement('img');
        try {
          if (clip.canvas) {
            img.src = clip.canvas.toDataURL('image/png');
          } else if (clip.dataUrl) {
            img.src = clip.dataUrl;
          }
        } catch (e) {
          if (clip.dataUrl) img.src = clip.dataUrl;
        }
        img.style.width = '100%';
        img.style.height = '100%';
        img.style.objectFit = 'cover';
        img.style.opacity = '0.9';
        img.style.zIndex = '1';
        // Allow clicking icons above the thumbnail
        img.style.pointerEvents = 'none';
        img.draggable = false;
        img.style.userSelect = 'none';
        el.appendChild(img);
        // draw object color circles at bottom-right; clickable to select key mode
        if (Array.isArray(clip.objects) && clip.objects.length) {
          const dots = document.createElement('div');
          dots.style.position = 'absolute';
          dots.style.right = '3px';
          dots.style.bottom = '3px';
          dots.style.display = 'flex';
          dots.style.gap = '3px';
          dots.style.pointerEvents = 'auto';
          const setTransformKeyColor = (color) => {
            const ids = ['cutout-pos-key','cutout-zoom-key','cutout-rot-key','cutout-opa-key'];
            ids.forEach(id => {
              const e = document.getElementById(id);
              if (e) { e.style.background = color; e.style.border = '1px solid #3b3b3b'; }
            });
          };
          clip.objects.forEach((o) => {
            const c = document.createElement('div');
            c.style.width = '8px'; c.style.height = '8px';
            c.style.borderRadius = '50%';
            c.style.background = o.color || '#6366f1';
            c.style.border = '1px solid #111';
            c.style.boxShadow = '0 0 2px rgba(0,0,0,0.5)';
            c.style.cursor = 'pointer';
            c.addEventListener('mousedown', (ev) => {
              ev.stopPropagation();
              // Select this clip (visual highlight) and bind its keys to this object without changing time or canvas state
              selectedCutoutClipIndex = idx;
              cutoutActiveObject = o;
              cutoutPropertyKeys = o.keys || (o.keys = { position: [], zoom: [], rotation: [], opacity: [] });
              // Clear any pending selection override so timeline reflects the chosen object's keys/color
              cutoutPendingSelection = false;
              cutoutPendingKeys = null;
              cutoutPendingColor = null;
              setTransformKeyColor(o.color || '#6366f1');
              drawCutoutTimeline();
              // Refresh row key highlights and preview to match selected object's keys
              if (typeof updateRowKeyActiveStates === 'function') updateRowKeyActiveStates();
              // Do not apply transforms or redraw preview here to avoid mutating other objects on click
              renderCutoutObjectsList && renderCutoutObjectsList();
            });
            dots.appendChild(c);
          });
          el.appendChild(dots);
        }
        el.appendChild(leftRib);
        el.appendChild(rightRib);
        clipsContainer.appendChild(el);
      }
      // Render transitions after clips
      const pxPerSec = 60;
      const rect2 = track.getBoundingClientRect();
      (Array.isArray(cutoutTransitions) ? cutoutTransitions : []).forEach((tr) => {
        const left = Math.max(0, Math.min(rect2.width, (tr.start / cutoutDuration) * rect2.width));
        const width = Math.max(6, Math.min(rect2.width - left, (tr.end - tr.start) * pxPerSec));
        const tEl = document.createElement('div');
        tEl.style.position = 'absolute';
        tEl.style.left = `${left}px`;
        tEl.style.width = `${width}px`;
        // Slim miniature height fixed near the top
        tEl.style.top = '2px';
        tEl.style.height = '16px';
        tEl.style.border = '1px solid #f59e0b';
        tEl.style.borderRadius = '2px';
        tEl.style.background = 'linear-gradient(90deg, rgba(245,158,11,0.25), rgba(245,158,11,0.1))';
        tEl.style.pointerEvents = 'auto';
        tEl.title = tr.type;
        if (typeof selectedCutoutTransitionId === 'string' && selectedCutoutTransitionId === tr.id) {
          tEl.style.border = '1px solid #fde68a';
          tEl.style.boxShadow = '0 0 6px rgba(251,191,36,0.6)';
        }
        // icon
        const icon = document.createElement('div');
        icon.style.position = 'absolute';
        icon.style.left = '50%';
        icon.style.top = '50%';
        icon.style.transform = 'translate(-50%, -50%)';
        icon.style.width = '14px';
        icon.style.height = '14px';
        icon.style.color = '#fbbf24';
        let svg = '';
        switch (tr.type) {
          case 'brightness-flash':
            svg = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="4"/></svg>'; break;
          case 'additive-resolve':
            svg = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="9" cy="12" r="5"/><circle cx="15" cy="12" r="5"/></svg>'; break;
          case 'dip-to-color':
            svg = '<svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor"><rect x="6" y="6" width="12" height="12" rx="2"/></svg>'; break;
          case 'blur-dissolve':
            svg = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 12c4-4 10 4 18-4"/></svg>'; break;
          case 'zoom-in-crash':
            svg = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="8" y="8" width="8" height="8"/></svg>'; break;
          case 'vignette-transition':
            svg = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="6"/></svg>'; break;
        }
        icon.innerHTML = svg;
        tEl.appendChild(icon);
        // resize handles
        const l = document.createElement('div'); const r = document.createElement('div');
        [l, r].forEach(h => { h.style.position = 'absolute'; h.style.top = '0'; h.style.bottom = '0'; h.style.width = '6px'; h.style.background = 'transparent'; h.style.cursor = 'ew-resize'; });
        l.style.left = '-3px'; r.style.right = '-3px';
        const beginResize = (e, side) => {
          e.stopPropagation();
          selectedCutoutTransitionId = tr.id;
          const startX = e.clientX;
          const origStart = tr.start; const origEnd = tr.end;
          const onMove = (ev) => {
            const dx = ev.clientX - startX;
            const dt = dx / pxPerSec;
            if (side === 'left') tr.start = Math.max(0, Math.min(origEnd - 0.1, origStart + dt));
            else tr.end = Math.min(cutoutDuration, Math.max(origStart + 0.1, origEnd + dt));
            renderCutoutClips();
          };
          const onUp = () => { window.removeEventListener('mousemove', onMove); window.removeEventListener('mouseup', onUp); };
          window.addEventListener('mousemove', onMove);
          window.addEventListener('mouseup', onUp);
        };
        l.addEventListener('mousedown', (e) => beginResize(e, 'left'));
        r.addEventListener('mousedown', (e) => beginResize(e, 'right'));
        tEl.appendChild(l); tEl.appendChild(r);
        // select on mouse down
        tEl.addEventListener('mousedown', (e) => { e.stopPropagation(); selectedCutoutTransitionId = tr.id; renderCutoutClips(); });
        clipsContainer.appendChild(tEl);
      });
      if (typeof renderCutoutObjectsList === 'function') renderCutoutObjectsList();
      if (typeof renderCutoutLayersPanel === 'function') renderCutoutLayersPanel();
    }
    
    function cutoutCreateClipSnapshot() {
      try {
        // Create offscreen canvas to store independent drawing for this clip
        const off = document.createElement('canvas');
        // Ensure proper dimensions - use cutoutCanvas if available, otherwise use viewport-based defaults
        let targetW = 1920, targetH = 1080;
        if (cutoutCanvas && cutoutCanvas.width > 0 && cutoutCanvas.height > 0) {
          targetW = cutoutCanvas.width;
          targetH = cutoutCanvas.height;
        } else if (typeof getTargetCanvasSizeForViewport === 'function' && typeof currentViewport !== 'undefined') {
          const target = getTargetCanvasSizeForViewport(currentViewport);
          targetW = target.width || 1920;
          targetH = target.height || 1080;
        } else if (canvases && canvases[0] && canvases[0].width > 0 && canvases[0].height > 0) {
          // Fallback to regular frame canvas dimensions
          targetW = canvases[0].width;
          targetH = canvases[0].height;
        }
        off.width = targetW;
        off.height = targetH;
        const offCtx = off.getContext('2d', { willReadFrequently: true });
        // Desired raw start and default duration (3s)
        let start = cutoutCurrentTime;
        const defaultEnd = Math.min(cutoutDuration, start + 3.0);
        // Compute non-overlapping start/end based on adjacent clips
        if (cutoutClips.length > 0) {
          saveState();
          // Sort by start time
          const sorted = [...cutoutClips].sort((a, b) => a.start - b.start);
          // Find next clip (first with start > candidate start)
          let nextStart = cutoutDuration;
          for (let i = 0; i < sorted.length; i++) {
            if (sorted[i].start > start) { nextStart = sorted[i].start; break; }
          }
          // Find previous end (max end where end <= candidate start, or if inside a clip, use that clip's end)
          let prevEnd = 0;
          for (let i = 0; i < sorted.length; i++) {
            const c = sorted[i];
            if (c.end <= start && c.end > prevEnd) prevEnd = c.end;
            if (c.start <= start && start < c.end) { prevEnd = c.end; }
          }
          // Clamp start to after previous end if needed
          if (start < prevEnd) start = prevEnd;
          // End cannot pass nextStart, and cannot exceed defaultEnd
          const end = Math.max(start, Math.min(defaultEnd, nextStart));
          // If there's no room, do nothing
          if (end - start < 1 / 60) return;
          cutoutClips.push({ start, end, canvas: off, ctx: offCtx });
          cutoutDrawingClipIndex = cutoutClips.length - 1;
          selectedCutoutClipIndex = cutoutDrawingClipIndex;
        } else {
          saveState();
          cutoutClips.push({ start, end: defaultEnd, canvas: off, ctx: offCtx });
          cutoutDrawingClipIndex = cutoutClips.length - 1;
          selectedCutoutClipIndex = cutoutDrawingClipIndex;
        }
        renderCutoutClips();
        saveState();
      } catch (e) {
        // ignore snapshot failures
      }
    }
    
    function cutoutToolAllowed() {
      // allow brush, pencil, eraser, magic tools and lasso variants, plus fill tools, color picker, and bones
      return currentTool === 'brush' || currentTool === 'pencil' || currentTool === 'eraser' ||
             currentTool === 'inbetween' || currentTool === 'mirror' || currentTool === 'detail' ||
             currentTool === 'lasso' || currentTool === 'select-lasso' || currentTool === 'extend-lasso' ||
             currentTool === 'fill' || currentTool === 'inner-fill' || currentTool === 'color-picker' ||
             currentTool === 'bones';
    }
    
    function cutoutCanvasCoords(e) {
      const rect = cutoutCanvas.getBoundingClientRect();
      const scaleX = cutoutCanvas.width / rect.width;
      const scaleY = cutoutCanvas.height / rect.height;
      return { x: (e.clientX - rect.left) * scaleX, y: (e.clientY - rect.top) * scaleY };
    }
    
    // --- Point-accurate zoom anchoring (Cut Out + Regular) ---
    // Returns exact percentage position within container for point-accurate zoom
    function getPointOrigin(rect, clientX, clientY) {
      // Calculate exact mouse position as percentage within container
      const relX = clientX - rect.left;
      const relY = clientY - rect.top;
      // Clamp to container bounds (0-100%)
      const percentX = Math.max(0, Math.min(100, (relX / rect.width) * 100));
      const percentY = Math.max(0, Math.min(100, (relY / rect.height) * 100));
      return { x: percentX, y: percentY };
    }
    
    // Legacy function kept for any remaining uses
    function getQuadrantFromPoint(rect, clientX, clientY) {
      // First detect central mini-rectangle
      const centerWRatio = 0.36; // ~36% of container width
      const centerHRatio = 0.36; // ~36% of container height
      const cW = rect.width * centerWRatio;
      const cH = rect.height * centerHRatio;
      const cL = rect.left + (rect.width - cW) / 2;
      const cT = rect.top + (rect.height - cH) / 2;
      if (clientX >= cL && clientX <= cL + cW && clientY >= cT && clientY <= cT + cH) {
        return 'center';
      }
      // Otherwise map to 4 quadrants
      const midX = rect.left + rect.width / 2;
      const midY = rect.top + rect.height / 2;
      const left = clientX < midX;
      const top = clientY < midY;
      if (top && left) return 'tl';
      if (top && !left) return 'tr';
      if (!top && left) return 'bl';
      return 'br';
    }
    
    // Convert point origin object to CSS string
    function pointOriginToCss(origin) {
      if (!origin || typeof origin !== 'object') return 'center center';
      return `${origin.x}% ${origin.y}%`;
    }
    function oppositeCorner(corner) {
      switch (corner) {
        case 'tl': return 'br';
        case 'tr': return 'bl';
        case 'bl': return 'tr';
        case 'br': return 'tl';
        default: return null;
      }
    }
    function anchorToCssOrigin(corner) {
      switch (corner) {
        case 'tl': return 'top left';
        case 'tr': return 'top right';
        case 'bl': return 'bottom left';
        case 'br': return 'bottom right';
        case 'center': return 'center center';
        default: return 'center center';
      }
    }
    let cutoutZoomAnchorCorner = null; // 'tl'|'tr'|'bl'|'br' or null (legacy)
    let cutoutZoomOriginPoint = null; // { x: %, y: % } for point-accurate zoom
    // Overlay: central zoom detection rectangle
    function ensureZoomCenterOverlay(container) {
      if (!container) return;
      if (getComputedStyle(container).position === 'static') {
        container.style.position = 'relative';
      }
      let ov = container.querySelector('.zoom-center-overlay');
      if (!ov) {
        ov = document.createElement('div');
        ov.className = 'zoom-center-overlay';
        ov.style.position = 'absolute';
        ov.style.left = '50%';
        ov.style.top = '50%';
        ov.style.transform = 'translate(-50%, -50%)';
        ov.style.width = '36%';
        ov.style.height = '36%';
        ov.style.border = 'none';
        ov.style.borderRadius = '4px';
        ov.style.pointerEvents = 'none';
        ov.style.zIndex = '5';
        ov.style.boxShadow = 'none';
        container.appendChild(ov);
      }
    }
    function ensureZoomCenterOverlays() {
      try {
        document.querySelectorAll('.canvas-container').forEach((c) => ensureZoomCenterOverlay(c));
        const cut = document.getElementById('cutout-canvas-container');
        if (cut) ensureZoomCenterOverlay(cut);
      } catch (_e) {}
    }
    
    function applyCutoutZoomTransforms() {
      if (!cutoutCanvas) return;
      // Point-accurate zoom: use exact origin point, fallback to center
      const t = `scale(${cutoutZoomLevel})`;
      const origin = cutoutZoomOriginPoint ? pointOriginToCss(cutoutZoomOriginPoint) : 'center center';
      ensureZoomCenterOverlay(cutoutCanvas.parentElement);
      cutoutCanvas.style.transformOrigin = origin;
      cutoutCanvas.style.transform = t;
      if (cutoutMoveOverlayCanvas) {
        cutoutMoveOverlayCanvas.style.transformOrigin = origin;
        cutoutMoveOverlayCanvas.style.transform = t;
      }
      if (typeof lassoOverlayCanvas !== 'undefined' && lassoOverlayCanvas) {
        lassoOverlayCanvas.style.transformOrigin = origin;
        lassoOverlayCanvas.style.transform = t;
      }
      if (typeof cutoutBonesOverlayCanvas !== 'undefined' && cutoutBonesOverlayCanvas) {
        cutoutBonesOverlayCanvas.style.transformOrigin = origin;
        cutoutBonesOverlayCanvas.style.transform = t;
      }
    }
    
    // Picture Board helpers
    let cutoutBoardSelectedCell = null;
    function cutoutBoardSelectCell(cell) {
      // Clear previous selection
      try {
        if (cutoutBoardSelectedCell && cutoutBoardSelectedCell !== cell) {
          cutoutBoardSelectedCell.style.border = '1px solid #2a2a2a';
          cutoutBoardSelectedCell.style.boxShadow = '';
        }
      } catch (_e) {}
      cutoutBoardSelectedCell = cell;
      if (cutoutBoardSelectedCell) {
        cutoutBoardSelectedCell.style.border = '1px solid #6366f1';
        cutoutBoardSelectedCell.style.boxShadow = '0 0 6px rgba(99,102,241,0.6)';
      }
    }
    function cutoutBoardEnsurePlaceholder() {
      const body = document.getElementById('cutout-board-body');
      const grid = document.getElementById('cutout-board-grid');
      if (!body || !grid) return;
      const hasCells = grid.children && grid.children.length > 0;
      if (!hasCells && !document.getElementById('cutout-board-placeholder')) {
        const ph = document.createElement('div');
        ph.id = 'cutout-board-placeholder';
        ph.style.position = 'absolute';
        ph.style.inset = '0';
        ph.style.display = 'flex';
        ph.style.alignItems = 'center';
        ph.style.justifyContent = 'center';
        ph.style.color = '#9ca3af';
        ph.style.fontSize = '12px';
        ph.style.pointerEvents = 'none';
        ph.textContent = 'Drag images here';
        body.appendChild(ph);
      }
    }
    function cutoutBoardOnKeyDown(e) {
      const key = e.key || '';
      if (key !== 'Delete' && key !== 'Backspace') return;
      if (!isCutOutMode) return;
      if (!cutoutBoardSelectedCell) return;
      try {
        const parent = cutoutBoardSelectedCell.parentElement;
        cutoutBoardSelectedCell.remove();
        cutoutBoardSelectedCell = null;
        cutoutBoardEnsurePlaceholder();
        e.preventDefault();
        e.stopPropagation();
      } catch (_e) {}
    }
    function ensureCutoutBoardDragGhost() {
      let ghost = document.getElementById('cutout-board-drag-ghost');
      if (!ghost) {
        ghost = document.createElement('div');
        ghost.id = 'cutout-board-drag-ghost';
        ghost.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="9"></circle><path d="M12 8v8M8 12h8"></path></svg>';
        document.body.appendChild(ghost);
      }
      return ghost;
    }
    function handleCutoutBoardFiles(files) {
      if (!files || !files.length) return;
      for (let i = 0; i < files.length; i++) {
        const f = files[i];
        if (!f.type || !f.type.startsWith('image/')) continue;
        const reader = new FileReader();
        reader.onload = () => cutoutBoardAddImage(reader.result);
        reader.readAsDataURL(f);
      }
    }
    function maybeDropMobileBoardImage(ev, src) {
      const canvasContainer = document.getElementById('cutout-canvas-container');
      if (!canvasContainer || !cutoutCanvas) return;
      const rect = canvasContainer.getBoundingClientRect();
      const within = ev.clientX >= rect.left && ev.clientX <= rect.right && ev.clientY >= rect.top && ev.clientY <= rect.bottom;
      if (!within) return;
      const coords = cutoutCanvasCoords(ev);
      cutoutPlaceImageFromSrcAt(src, coords.x, coords.y);
    }
    function attachCutoutMobileDrag(cell, src) {
      cell.addEventListener('pointerdown', (e) => {
        if (!isPhoneViewport()) return;
        if (!cutoutCanvas) return;
        e.preventDefault();
        const ghost = ensureCutoutBoardDragGhost();
        const updateGhost = (ev) => {
          ghost.style.display = 'flex';
          ghost.style.transform = `translate(${ev.clientX - 17}px, ${ev.clientY - 17}px)`;
        };
        const endDrag = (ev) => {
          ghost.style.display = 'none';
          window.removeEventListener('pointermove', updateGhost);
          window.removeEventListener('pointerup', endDrag);
          window.removeEventListener('pointercancel', endDrag);
          maybeDropMobileBoardImage(ev, src);
        };
        updateGhost(e);
        window.addEventListener('pointermove', updateGhost);
        window.addEventListener('pointerup', endDrag, { once: true });
        window.addEventListener('pointercancel', endDrag, { once: true });
      });
    }
    function cutoutBoardAddImage(src) {
      const grid = document.getElementById('cutout-board-grid');
      if (!grid) return;
      // Remove placeholder once first image is added
      const ph = document.getElementById('cutout-board-placeholder');
      if (ph) ph.remove();
      const cell = document.createElement('div');
      cell.style.width = '44px';
      cell.style.height = '44px';
      cell.style.borderRadius = '6px';
      cell.style.overflow = 'hidden';
      cell.style.border = '1px solid #2a2a2a';
      cell.style.background = '#0f0f0f';
      cell.style.cursor = 'grab';
      cell.draggable = true;
      cell.addEventListener('click', (e) => {
        e.stopPropagation();
        cutoutBoardSelectCell(cell);
      });
      const img = document.createElement('img');
      img.src = src;
      img.style.width = '100%';
      img.style.height = '100%';
      img.style.objectFit = 'cover';
      cell.appendChild(img);
      cell.addEventListener('dragstart', (e) => {
        e.dataTransfer.setData('text/plain', src);
        e.dataTransfer.effectAllowed = 'copy';
      });
      attachCutoutMobileDrag(cell, src);
      grid.appendChild(cell);
    }
    function cutoutPlaceImageFromSrcAt(src, canvasX, canvasY) {
      const img = new Image();
      img.onload = () => {
        // Create a committed object immediately so it appears in Objects/Layers on first drop
        // Compute placement so the image is centered at the drop point
        const drawW = img.naturalWidth;
        const drawH = img.naturalHeight;
        const x = Math.max(0, Math.round(canvasX - drawW / 2));
        const y = Math.max(0, Math.round(canvasY - drawH / 2));
        // Ensure a clip exists at the current time
        let activeIdx = (typeof selectedCutoutClipIndex === 'number' && selectedCutoutClipIndex >= 0)
          ? selectedCutoutClipIndex
          : getActiveCutoutClipIndexAt(cutoutCurrentTime);
        if (activeIdx < 0) {
          try { cutoutCreateClipSnapshot(); } catch (_e) {}
          activeIdx = cutoutClips.length - 1;
          selectedCutoutClipIndex = activeIdx;
        }
        const clip = cutoutClips[activeIdx];
        if (!Array.isArray(clip.objects)) clip.objects = [];
        // Create object with ID, color, default keys and sizing
        const objId = (++cutoutObjectCounter);
        const color = cutoutObjectPalette[clip.objects.length % cutoutObjectPalette.length];
        const newObj = {
          id: objId,
          name: `Image ${objId}`,
          color,
          src,
          img,
          layerIndex: Number.isFinite(cutoutActiveLayerIndex) ? cutoutActiveLayerIndex : 0,
          x,
          y,
          scale: 1,
          scaleX: 1,
          scaleY: 1,
          rotation: 0,
          opacity: 1,
          drawW,
          drawH,
          keys: { position: [], zoom: [], rotation: [], opacity: [] },
          isImage: true
        };
        try { saveState(); } catch (_e) {}
        clip.objects.push(newObj);
        cutoutActiveObject = newObj;
        cutoutSelectedObject = newObj;
        // Bind timeline keys to this object's keys immediately
        cutoutPropertyKeys = newObj.keys;
        // Seed initial keys at the start of the clip so icons show color at frame start
        const t0 = Number.isFinite(clip.start) ? clip.start : 0;
        newObj.keys.position.push({ time: t0, x: newObj.x, y: newObj.y });
        newObj.keys.zoom.push({ time: t0, sx: newObj.scaleX, sy: newObj.scaleY });
        newObj.keys.rotation.push({ time: t0, deg: 0 });
        newObj.keys.opacity.push({ time: t0, value: newObj.opacity });
        // Keep arrays sorted
        newObj.keys.position.sort((a, b) => a.time - b.time);
        newObj.keys.zoom.sort((a, b) => a.time - b.time);
        newObj.keys.rotation.sort((a, b) => a.time - b.time);
        newObj.keys.opacity.sort((a, b) => a.time - b.time);
        // Begin selection overlay with this object and update displays
        cutoutBeginSelectionOverlay();
        updateCutoutPositionDisplay(newObj.x, newObj.y);
        updateCutoutZoomDisplay(newObj.scaleX || 1, newObj.scaleY || 1);
        updateCutoutRotationDisplay(0);
        updateCutoutOpacityDisplay(1);
        // If recorder is armed, seed initial keys now
        if (cutoutRecorderArmed) {
          const t = cutoutCurrentTime || 0;
          addOrUpdatePropKeyAt('position', t, { x: newObj.x, y: newObj.y });
          addOrUpdatePropKeyAt('zoom', t, { sx: newObj.scaleX, sy: newObj.scaleY });
          addOrUpdatePropKeyAt('rotation', t, { deg: 0 });
          addOrUpdatePropKeyAt('opacity', t, { value: newObj.opacity });
          drawCutoutTimeline();
          updateRowKeyActiveStates();
        }
        // Reflect immediately in UI
        if (typeof renderCutoutObjectsList === 'function') renderCutoutObjectsList();
        if (typeof renderCutoutLayersPanel === 'function') renderCutoutLayersPanel();
        drawCutoutTimeline();
        updateRowKeyActiveStates();
        renderCutoutPreviewForTime();
        try { saveState(); } catch (_e) {}
        // Automatically switch to Select/Move so position nodes are shown like regular mode
        setTool('select');
      };
      img.src = src;
    }
    function cutoutHandleWheelZoom(e) {
      const delta = e.deltaY > 0 ? -0.1 : 0.1;
      // Do not allow zooming out beyond the initial scale (1.0)
      const oldScale = cutoutZoomLevel;
      const newScale = Math.max(1.0, Math.min(3.0, cutoutZoomLevel + delta));
      if (newScale === oldScale) return;
      
      const container = cutoutCanvas ? cutoutCanvas.parentElement : null;
      if (!container) return;
      const rect = container.getBoundingClientRect();
      
      // Point-accurate zoom: always update origin to current mouse position for smooth zoom-to-point
      // When zooming in from 1.0, set the initial origin
      // When already zoomed, interpolate towards new point for smooth re-targeting
      if (newScale > 1.0) {
        const newPoint = getPointOrigin(rect, e.clientX, e.clientY);
        if (oldScale <= 1.0 + 1e-9) {
          // Starting fresh zoom - use exact mouse position
          cutoutZoomOriginPoint = newPoint;
        } else if (cutoutZoomOriginPoint) {
          // Already zoomed - smoothly interpolate origin towards new point
          // The closer to min zoom, the more we shift towards new point
          const t = Math.min(1, (3.0 - oldScale) / 2.0) * 0.3; // Subtle shift
          cutoutZoomOriginPoint = {
            x: cutoutZoomOriginPoint.x + (newPoint.x - cutoutZoomOriginPoint.x) * t,
            y: cutoutZoomOriginPoint.y + (newPoint.y - cutoutZoomOriginPoint.y) * t
          };
        } else {
          cutoutZoomOriginPoint = newPoint;
        }
      } else {
        // Zoomed back to 1.0 - reset origin for next zoom
        cutoutZoomOriginPoint = null;
      }
      
      // Keep pan at zero (no drift)
      cutoutPanX = 0;
      cutoutPanY = 0;
      cutoutZoomLevel = newScale;
      applyCutoutZoomTransforms();
    }
    
    function toggleCutoutRecording() {
      const btn = document.getElementById('cutout-rec-btn');
      if (!cutoutRecorderIsPlaying) {
        // Start recording playback (timer runs, no keying while playing)
        cutoutRecorderIsPlaying = true;
        cutoutRecorderArmed = false;
        cutoutRecordStartTime = cutoutCurrentTime;
        cutoutRecordStartTs = performance.now();
        if (btn) { btn.style.background = '#ef4444'; btn.style.boxShadow = '0 0 8px rgba(239,68,68,0.7)'; }
        const step = (ts) => {
          if (!cutoutRecorderIsPlaying) return;
          const elapsed = (ts - cutoutRecordStartTs) / 1000;
          let t = cutoutRecordStartTime + elapsed;
          const dur = Math.max(0.1, cutoutDuration);
          t = ((t % dur) + dur) % dur;
          cutoutCurrentTime = t;
          updateCutoutScrubber();
          cutoutRecordRAF = requestAnimationFrame(step);
        };
        cutoutRecordRAF = requestAnimationFrame(step);
      } else {
        // Pause recording (armed for keying)
        cutoutRecorderIsPlaying = false;
        cutoutRecorderArmed = true;
        if (btn) { btn.style.background = '#6b7280'; btn.style.boxShadow = '0 0 6px rgba(0,0,0,0.35)'; }
        if (cutoutRecordRAF) { cancelAnimationFrame(cutoutRecordRAF); cutoutRecordRAF = null; }
      }
    }
    function updateRecorderTimeDisplay() {
      const el = document.getElementById('cutout-rec-time');
      if (!el) return;
      el.textContent = formatCutoutTime(cutoutCurrentTime);
    }

    // --- Scroll button behavior switching (Regular vs Cut Out mode) ---
    function getScrollBtnArrowSvg() {
      return '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><path d="M12 5v14m0 0l-7-7m7 7l7-7" stroke-linecap="round" stroke-linejoin="round"/></svg>';
    }
    function getScrollBtnPlaySvg() {
      // Centered play triangle, scaled up ~1.5x for visibility
      return '<svg width="31" height="31" viewBox="0 0 24 24" preserveAspectRatio="xMidYMid meet" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><polygon points="7,5 17,12 7,19" /></svg>';
    }
    function getScrollBtnPauseSvg() {
      // Scaled up pause icon to match play size
      return '<svg width="31" height="31" viewBox="0 0 24 24" preserveAspectRatio="xMidYMid meet" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="4" width="16" height="16" /></svg>';
    }
    function updateScrollButtonIconForCutout() {
      const btn = document.querySelector('.scroll-to-timeline-btn');
      if (!btn || btn.dataset.mode !== 'cutout') return;
      btn.innerHTML = cutoutIsPlaying ? getScrollBtnPauseSvg() : getScrollBtnPlaySvg();
    }
    function toggleCutoutPlayFromScrollBtn() {
      if (!isCutOutMode) return;
      if (cutoutIsPlaying) cutoutPausePlayback();
      else cutoutPlayForward();
      updateScrollButtonIconForCutout();
    }
    function setScrollButtonModeCutout(enable) {
      const btn = document.querySelector('.scroll-to-timeline-btn');
      if (!btn) return;
      if (enable) {
        btn.dataset.mode = 'cutout';
        btn.title = 'Play / Pause';
        btn.onclick = toggleCutoutPlayFromScrollBtn;
        updateScrollButtonIconForCutout();
        // Ensure mini preview is hidden/disabled while in Cut Out mode
        const mini = document.getElementById('mini-preview');
        if (mini) mini.classList.remove('show');
      } else {
        btn.dataset.mode = '';
        btn.title = 'Scroll to Timeline';
        btn.onclick = scrollToTimeline;
        btn.innerHTML = getScrollBtnArrowSvg();
      }
    }
    function beginRecTimeDrag(e) {
      e.preventDefault();
      e.stopPropagation();
      isDraggingRecTime = true;
      recDragStartX = e.clientX;
      recDragStartTime = cutoutCurrentTime;
      window.addEventListener('mousemove', onRecTimeDragMove);
      window.addEventListener('mouseup', endRecTimeDrag, { once: true });
    }
    function onRecTimeDragMove(e) {
      if (!isDraggingRecTime) return;
      const dx = e.clientX - recDragStartX;
      // 60px per second scrub sensitivity
      const secondsDelta = dx / 60;
      const dur = Math.max(0.1, cutoutDuration);
      let t = recDragStartTime + secondsDelta;
      t = Math.max(0, Math.min(dur, t));
      cutoutCurrentTime = t;
      updateCutoutScrubber();
    }
    function endRecTimeDrag() {
      isDraggingRecTime = false;
      window.removeEventListener('mousemove', onRecTimeDragMove);
    }
    
    // Create/select a Background object from the entire base drawing canvas for the active clip.
    // Background objects are exempt from future lasso-merges.
    function cutoutSelectAllBaseAsBackground() {
      const idx = getActiveCutoutClipIndexAt(cutoutCurrentTime);
      if (idx < 0) return;
      const clip = cutoutClips[idx];
      if (!clip || !clip.canvas || !clip.ctx) return;
      const baseCanvas = clip.canvas;
      const baseCtx = clip.ctx;
      // Check if base canvas has any content
      try {
        const imgData = baseCtx.getImageData(0, 0, baseCanvas.width, baseCanvas.height).data;
        let hasContent = false;
        for (let i = 3; i < imgData.length; i += 16) { // sample alpha every 4th pixel
          if (imgData[i] > 0) { hasContent = true; break; }
        }
        if (!hasContent) {
          // Nothing to select; just clear any stale overlay
          try { cutoutCancelSelectionOverlay(); } catch (_e) {}
          return;
        }
      } catch (_e) {
        // If read fails, proceed optimistically
      }
      // Clone base canvas into an object
      const cloned = document.createElement('canvas');
      cloned.width = baseCanvas.width;
      cloned.height = baseCanvas.height;
      const cctx = cloned.getContext('2d');
      cctx.drawImage(baseCanvas, 0, 0);
      const dataUrl = cloned.toDataURL('image/png');
      try { saveState(); } catch (_e) {}
      // Clear base canvas so drawings are now represented by the object
      baseCtx.clearRect(0, 0, baseCanvas.width, baseCanvas.height);
      if (!Array.isArray(clip.objects)) clip.objects = [];
      const objId = (++cutoutObjectCounter);
      const color = cutoutObjectPalette[clip.objects.length % cutoutObjectPalette.length];
      const newObj = {
        id: objId,
        name: 'Background',
        color,
        src: dataUrl,
        img: cloned,                  // Canvas is valid for drawImage
        isBackground: true,           // Exempt from lasso-merge
        layerIndex: 0,                // Layer 1 (above images in Layer 2)
        x: 0,
        y: 0,
        scale: 1,
        scaleX: 1,
        scaleY: 1,
        rotation: 0,
        opacity: 1,
        drawW: cloned.width,
        drawH: cloned.height,
        keys: { position: [], zoom: [], rotation: [], opacity: [] }
      };
      clip.objects.push(newObj);
      cutoutActiveObject = newObj;
      cutoutSelectedObject = newObj;
      cutoutPropertyKeys = newObj.keys;
      // Seed initial keys at the start of the clip so icons show color at frame start
      const t0 = Number.isFinite(clip.start) ? clip.start : 0;
      newObj.keys.position.push({ time: t0, x: newObj.x, y: newObj.y });
      newObj.keys.zoom.push({ time: t0, sx: newObj.scaleX, sy: newObj.scaleY });
      newObj.keys.rotation.push({ time: t0, deg: 0 });
      newObj.keys.opacity.push({ time: t0, value: newObj.opacity });
      newObj.keys.position.sort((a, b) => a.time - b.time);
      newObj.keys.zoom.sort((a, b) => a.time - b.time);
      newObj.keys.rotation.sort((a, b) => a.time - b.time);
      newObj.keys.opacity.sort((a, b) => a.time - b.time);
      cutoutBeginSelectionOverlay();
      updateCutoutPositionDisplay(newObj.x, newObj.y);
      updateCutoutZoomDisplay(newObj.scaleX || 1, newObj.scaleY || 1);
      updateCutoutRotationDisplay(0);
      updateCutoutOpacityDisplay(1);
      renderCutoutPreviewForTime();
      if (typeof renderCutoutObjectsList === 'function') renderCutoutObjectsList();
      if (typeof renderCutoutLayersPanel === 'function') renderCutoutLayersPanel();
      drawCutoutTimeline();
      updateRowKeyActiveStates();
    }
    
    function cutoutActiveTarget() {
      const idx = selectedCutoutClipIndex >= 0 ? selectedCutoutClipIndex : getActiveCutoutClipIndexAt(cutoutCurrentTime);
      const clip = idx >= 0 ? cutoutClips[idx] : null;
      return {
        canvas: clip ? clip.canvas : cutoutCanvas,
        ctx: clip ? clip.ctx : cutoutCtx,
        clip
      };
    }

    function ensureCutoutFillLayer(target) {
      if (!target || !target.canvas) return null;
      const baseCanvas = target.canvas;
      if (target.clip) {
        const c = target.clip;
        if (!c.fillCanvas || c.fillCanvas.width !== baseCanvas.width || c.fillCanvas.height !== baseCanvas.height) {
          const fc = document.createElement('canvas');
          fc.width = baseCanvas.width;
          fc.height = baseCanvas.height;
          c.fillCanvas = fc;
          c.fillCtx = fc.getContext('2d');
          c.fillCtx.clearRect(0, 0, fc.width, fc.height);
        }
        return { canvas: c.fillCanvas, ctx: c.fillCtx };
      }
      if (!cutoutFillCanvas || cutoutFillCanvas.width !== baseCanvas.width || cutoutFillCanvas.height !== baseCanvas.height) {
        cutoutFillCanvas = document.createElement('canvas');
        cutoutFillCanvas.width = baseCanvas.width;
        cutoutFillCanvas.height = baseCanvas.height;
        cutoutFillCtx = cutoutFillCanvas.getContext('2d');
        cutoutFillCtx.clearRect(0, 0, cutoutFillCanvas.width, cutoutFillCanvas.height);
      }
      return { canvas: cutoutFillCanvas, ctx: cutoutFillCtx };
    }
    function cutoutFloodFillAt(x, y) {
      const target = cutoutActiveTarget();
      const fillLayer = ensureCutoutFillLayer(target);
      if (!fillLayer || !fillLayer.ctx || !fillLayer.canvas) return;
      const ctx = fillLayer.ctx;
      const canvas = fillLayer.canvas;
      saveState();
      ctx.save();
      ctx.fillStyle = currentColor;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.restore();
      renderCutoutPreviewForTime();
      saveState();
    }
    function cutoutInnerFillAt(x, y) {
      const target = cutoutActiveTarget();
      const ctx = target.ctx;
      const canvas = target.canvas;
      if (!ctx || !canvas) return;
      saveState();
      // Read pixels and perform similar innerFill as main mode
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      const width = canvas.width, height = canvas.height;
      const sx = Math.floor(x), sy = Math.floor(y);
      if (sx < 0 || sx >= width || sy < 0 || sy >= height) return;
      const startIndex = (sy * width + sx) * 4;
      const startR = data[startIndex], startG = data[startIndex + 1], startB = data[startIndex + 2], startA = data[startIndex + 3];
      const fillColor = hexToRgb(currentColor);
      const stack = [{ x: sx, y: sy }];
      const visited = new Set();
      const tol = 30;
      function match(ix, iy) {
        const i = (iy * width + ix) * 4;
        const r = data[i], g = data[i + 1], b = data[i + 2], a = data[i + 3];
        if (a === 0 && startA === 0) return true;
        if (a === 0 || startA === 0) return false;
        return Math.abs(r - startR) <= tol && Math.abs(g - startG) <= tol && Math.abs(b - startB) <= tol && Math.abs(a - startA) <= tol;
      }
      while (stack.length) {
        const cur = stack.pop();
        const key = `${cur.x},${cur.y}`;
        if (visited.has(key)) continue;
        if (cur.x < 0 || cur.x >= width || cur.y < 0 || cur.y >= height) continue;
        if (!match(cur.x, cur.y)) continue;
        visited.add(key);
        stack.push({ x: cur.x + 1, y: cur.y });
        stack.push({ x: cur.x - 1, y: cur.y });
        stack.push({ x: cur.x, y: cur.y + 1 });
        stack.push({ x: cur.x, y: cur.y - 1 });
        stack.push({ x: cur.x + 1, y: cur.y + 1 });
        stack.push({ x: cur.x - 1, y: cur.y + 1 });
        stack.push({ x: cur.x + 1, y: cur.y - 1 });
        stack.push({ x: cur.x - 1, y: cur.y - 1 });
      }
      // Modify a new buffer
      const newData = new Uint8ClampedArray(data);
      for (const key of visited) {
        const [px, py] = key.split(',').map(Number);
        const i = (py * width + px) * 4;
        newData[i] = fillColor.r;
        newData[i + 1] = fillColor.g;
        newData[i + 2] = fillColor.b;
        newData[i + 3] = 255;
      }
      const newImageData = new ImageData(newData, width, height);
      ctx.putImageData(newImageData, 0, 0);
      renderCutoutPreviewForTime();
      saveState();
    }
    function cutoutPickColorAt(x, y) {
      // Sample from the composited preview so images and drawings are included
      if (cutoutCtx && cutoutCanvas) {
        // Ensure preview is up to date before sampling
        try { renderCutoutPreviewForTime(); } catch (_e) {}
        const img = cutoutCtx.getImageData(Math.floor(x), Math.floor(y), 1, 1).data;
        const hex = rgbToHex(img[0], img[1], img[2]);
        currentColor = hex;
        const colorInput = document.getElementById('color-picker');
        if (colorInput) colorInput.value = hex;
        return;
      }
      // Fallback: sample from the active clip canvas
      const target = cutoutActiveTarget();
      const ctx = target.ctx;
      const canvas = target.canvas;
      if (!ctx || !canvas) return;
      const img = ctx.getImageData(Math.floor(x), Math.floor(y), 1, 1).data;
      const hex = rgbToHex(img[0], img[1], img[2]);
      currentColor = hex;
      const colorInput = document.getElementById('color-picker');
      if (colorInput) colorInput.value = hex;
    }
    
    function cutoutStartDraw(e) {
      // If Select/Move tool is active, allow click-to-select objects (like regular mode)
      if (currentTool === 'select') {
        const { x, y } = cutoutCanvasCoords(e);
        const idx = getActiveCutoutClipIndexAt(cutoutCurrentTime);
        if (idx >= 0) {
          const clip = cutoutClips[idx];
          let objects = Array.isArray(clip && clip.objects) ? clip.objects.slice() : [];
          // Selection hit priority:
          // - Lower layerIndex numbers are above higher numbers (layer 1 above layer 2)
          // - Within the same layerIndex, higher id (newer object) is above lower id
          objects.sort((a, b) => {
            const ai = Number.isFinite(a && a.layerIndex) ? a.layerIndex : Number.POSITIVE_INFINITY;
            const bi = Number.isFinite(b && b.layerIndex) ? b.layerIndex : Number.POSITIVE_INFINITY;
            if (ai !== bi) return ai - bi; // smaller index on top
            const aid = (a && a.id != null) ? a.id : -Infinity;
            const bid = (b && b.id != null) ? b.id : -Infinity;
            return bid - aid; // higher id on top
          });
          for (let i = 0; i < objects.length; i++) {
            const obj = objects[i];
            if (isPointInsideSelectedObject(obj, x, y)) {
              cutoutActiveObject = obj;
              cutoutSelectedObject = obj;
              cutoutPropertyKeys = obj.keys || (obj.keys = { position: [], zoom: [], rotation: [], opacity: [] });
              cutoutBeginSelectionOverlay();
              updateCutoutPositionDisplay(obj.x, obj.y);
              updateCutoutZoomDisplay(obj.scaleX || 1, obj.scaleY || 1);
              const deg = ((obj.rotation || 0) * 180) / Math.PI;
              updateCutoutRotationDisplay(deg);
              updateCutoutOpacityDisplay((typeof obj.opacity === 'number') ? obj.opacity : 1);
              return;
            }
          }
          // Empty space: create/select a Background object from all current drawings (base canvas)
          try {
            cutoutSelectAllBaseAsBackground();
          } catch (_e) {
            // If background creation fails, clear any stale overlay
            try { cutoutCancelSelectionOverlay(); } catch (__e) {}
          }
        }
        return;
      }
      // Bones tool: handle separately to avoid creating snapshots/clips
      if (currentTool === 'bones') {
        const { x, y } = cutoutCanvasCoords(e);
        lastCutoutX = x;
        lastCutoutY = y;
        // First: try to grab an existing cutout bone handle
        const handle = getCutoutBoneHandleAtPoint(x, y);
        if (handle) {
          isCutoutDrawing = true;
          try { saveState(); } catch (_e) {}
          cutoutSelectedBoneIndex = handle.boneIndex;
          
          // Handle rotation via the dedicated rotation handle
          if (handle.handle === 'rotation') {
            const b = cutoutBones[handle.boneIndex];
            if (b && b.objectRef) {
              cutoutIsRotatingBone = true;
              cutoutBoneDrag = handle;
              cutoutIsDraggingBoneHandle = true;
              // Calculate initial angle from bone start to mouse
              const startAngle = Math.atan2(y - b.startY, x - b.startX);
              // Store initial state for connected parent bone if this bone's END is connected to a START
              let parentInitialData = null;
              if (b.attachedAt === 'end' && b.parentAttach === 'start' && b.parentBoneIndex != null) {
                const parentBone = cutoutBones[b.parentBoneIndex];
                if (parentBone && parentBone.objectRef) {
                  parentInitialData = {
                    rotation: parentBone.objectRef.rotation || 0,
                    x: parentBone.objectRef.x,
                    y: parentBone.objectRef.y,
                    boneStartX: parentBone.startX,
                    boneStartY: parentBone.startY,
                    boneEndX: parentBone.endX,
                    boneEndY: parentBone.endY
                  };
                }
              }
              cutoutBoneRotationData = {
                boneIndex: handle.boneIndex,
                startAngle: startAngle,
                initialObjRotation: b.objectRef.rotation || 0,
                // Store bone's initial angle for rotating the bone itself too
                initialBoneAngle: Math.atan2(b.endY - b.startY, b.endX - b.startX),
                // Store initial end position for restoring connection
                initialEndX: b.endX,
                initialEndY: b.endY,
                // Store parent's initial state for tree branch rotation
                parentInitial: parentInitialData
              };
            }
            ensureCutoutBonesOverlay();
            return;
          }
          
          cutoutBoneDrag = handle;
          cutoutIsDraggingBoneHandle = true;
          // If rotating from end handle, capture pinned local offset so start node stays pinned during rotation
          try {
            if (handle.handle === 'end') {
              const b = cutoutBones[handle.boneIndex];
              if (b && b.objectRef) {
                const obj = b.objectRef;
                const baseW = (obj && obj.drawW != null) ? obj.drawW : ((obj && obj.img && (obj.img.naturalWidth || obj.img.width || obj.img.videoWidth)) || 0);
                const baseH = (obj && obj.drawH != null) ? obj.drawH : ((obj && obj.img && (obj.img.naturalHeight || obj.img.height || obj.img.videoHeight)) || 0);
                const effScaleX = (typeof obj.scaleX === 'number' ? obj.scaleX : 1);
                const effScaleY = (typeof obj.scaleY === 'number' ? obj.scaleY : 1);
                const w = baseW * (obj.scale || 1) * effScaleX;
                const h = baseH * (obj.scale || 1) * effScaleY;
                const centerX = obj.x + w / 2;
                const centerY = obj.y + h / 2;
                const rot = obj.rotation || 0;
                const dx = b.startX - centerX;
                const dy = b.startY - centerY;
                const cos = Math.cos(rot), sin = Math.sin(rot);
                // Convert world delta into object's local (unrotated) space
                b.pinnedLocalX = dx * cos + dy * sin;
                b.pinnedLocalY = -dx * sin + dy * cos;
              }
            }
          } catch (_e) {}
          ensureCutoutBonesOverlay();
          return;
        }
        // Otherwise, only start a lasso to define a new bone if drawing is armed
        if (cutoutBonesDrawArmed) {
          isCutoutDrawing = true;
          try { saveState(); } catch (_e) {}
          cutoutBoneLassoPoints = [[x, y]];
          cutoutIsBoneLassoActive = true;
          const container = document.getElementById('cutout-canvas-container');
          if (lassoOverlayCanvas) {
            lassoOverlayCanvas.remove();
          }
          lassoOverlayCanvas = document.createElement('canvas');
          lassoOverlayCanvas.width = cutoutCanvas.width;
          lassoOverlayCanvas.height = cutoutCanvas.height;
          lassoOverlayCanvas.style.position = 'absolute';
          lassoOverlayCanvas.style.top = '0';
          lassoOverlayCanvas.style.left = '0';
          lassoOverlayCanvas.style.width = '100%';
          lassoOverlayCanvas.style.height = '100%';
          lassoOverlayCanvas.style.pointerEvents = 'none';
          lassoOverlayCanvas.style.zIndex = '9';
          lassoOverlayCtx = lassoOverlayCanvas.getContext('2d');
          if (container) {
            const computed = window.getComputedStyle(container);
            if (computed.position === 'static') container.style.position = 'relative';
            container.appendChild(lassoOverlayCanvas);
          }
          if (typeof applyCutoutZoomTransforms === 'function') applyCutoutZoomTransforms();
          return;
        }
        
        // Not armed and not on a bone handle: check if clicking on an object to drag it
        const activeClipForDrag = getActiveCutoutClipIndex();
        if (activeClipForDrag >= 0) {
          // Find if point is inside any object that has a bone attached
          for (let bi = 0; bi < cutoutBones.length; bi++) {
            const bone = cutoutBones[bi];
            if (!bone || bone.clipIndex !== activeClipForDrag || !bone.objectRef) continue;
            const obj = bone.objectRef;
            if (!obj || !obj.img) continue;
            const baseW = (obj.drawW != null) ? obj.drawW : ((obj.img.naturalWidth || obj.img.width) || 0);
            const baseH = (obj.drawH != null) ? obj.drawH : ((obj.img.naturalHeight || obj.img.height) || 0);
            const effScaleX = (typeof obj.scaleX === 'number' ? obj.scaleX : 1);
            const effScaleY = (typeof obj.scaleY === 'number' ? obj.scaleY : 1);
            const objW = baseW * (obj.scale || 1) * effScaleX;
            const objH = baseH * (obj.scale || 1) * effScaleY;
            // Simple AABB hit test (ignoring rotation for click detection)
            if (x >= obj.x && x <= obj.x + objW && y >= obj.y && y <= obj.y + objH) {
              // Start dragging this object
              isCutoutDrawing = true;
              try { saveState(); } catch (_e) {}
              cutoutBonesModeObjDrag = {
                boneIndex: bi,
                offsetX: x - obj.x,
                offsetY: y - obj.y
              };
              ensureCutoutBonesOverlay();
              return;
            }
          }
        }
        
        // Not armed: keep bones visible/movable, but do not start a new lasso
        ensureCutoutBonesOverlay();
        drawCutoutBonesOverlay();
        return;
      }
      if (!cutoutToolAllowed()) return;
      // If within an existing clip, continue drawing into that clip; otherwise create a new one
      const activeIdx = getActiveCutoutClipIndexAt(cutoutCurrentTime);
      if (activeIdx >= 0) {
        cutoutDrawingClipIndex = activeIdx;
        selectedCutoutClipIndex = activeIdx;
        renderCutoutClips();
      } else {
        cutoutCreateClipSnapshot();
      }
      isCutoutDrawing = true;
      const { x, y } = cutoutCanvasCoords(e);
      lastCutoutX = x;
      lastCutoutY = y;
      // Snapshot for undo before painting strokes
      if (currentTool === 'pencil' || currentTool === 'brush' || currentTool === 'eraser') {
        saveState();
      }
      // Handle single-click tools first
      if (currentTool === 'color-picker') {
        cutoutPickColorAt(x, y);
        isCutoutDrawing = false;
        return;
      }
      if (currentTool === 'fill') {
        cutoutFloodFillAt(x, y);
        isCutoutDrawing = false;
        return;
      }
      if (currentTool === 'inner-fill') {
        cutoutInnerFillAt(x, y);
        isCutoutDrawing = false;
        return;
      }
      // If a magic lasso tool is active, begin lasso overlay specific to cutout canvas
      if (currentTool === 'inbetween' || currentTool === 'detail' || currentTool === 'lasso' || currentTool === 'select-lasso' || currentTool === 'extend-lasso') {
        magicLassoMode = currentTool;
        magicLassoPoints = [[x, y]];
        isMagicLassoActive = true;
        const container = document.getElementById('cutout-canvas-container');
        if (lassoOverlayCanvas) {
          lassoOverlayCanvas.remove();
        }
        lassoOverlayCanvas = document.createElement('canvas');
        lassoOverlayCanvas.width = cutoutCanvas.width;
        lassoOverlayCanvas.height = cutoutCanvas.height;
        lassoOverlayCanvas.style.position = 'absolute';
        lassoOverlayCanvas.style.top = '0';
        lassoOverlayCanvas.style.left = '0';
        lassoOverlayCanvas.style.width = '100%';
        lassoOverlayCanvas.style.height = '100%';
        lassoOverlayCanvas.style.pointerEvents = 'none';
        lassoOverlayCanvas.style.zIndex = '9';
        lassoOverlayCtx = lassoOverlayCanvas.getContext('2d');
        if (container) {
          const computed = window.getComputedStyle(container);
          if (computed.position === 'static') container.style.position = 'relative';
          container.appendChild(lassoOverlayCanvas);
        }
        // Ensure overlay follows current zoom/pan immediately
        if (typeof applyCutoutZoomTransforms === 'function') applyCutoutZoomTransforms();
      }
      // initial dot
      cutoutCtx.save();
      const target = cutoutClips[cutoutDrawingClipIndex];
      const tctx = target ? target.ctx : cutoutCtx;
      if (currentTool === 'pencil') {
        tctx.globalAlpha = brushOpacity;
        tctx.fillStyle = currentColor;
        tctx.beginPath();
        tctx.arc(x, y, Math.max(1, (brushSize / 2)), 0, Math.PI * 2);
        tctx.fill();
      } else if (currentTool === 'brush') {
        tctx.globalAlpha = brushOpacity;
        tctx.strokeStyle = currentColor;
        if (typeof drawWithBrushType === 'function') {
          drawWithBrushType(tctx, x, y, x, y);
        } else {
          tctx.beginPath();
          tctx.arc(x, y, Math.max(1, brushSize / 2), 0, Math.PI * 2);
          tctx.fillStyle = currentColor;
          tctx.fill();
        }
      } else if (currentTool === 'eraser') {
        tctx.globalCompositeOperation = 'destination-out';
        tctx.beginPath();
        tctx.arc(x, y, Math.max(1, brushSize / 2), 0, Math.PI * 2);
        tctx.fill();
        tctx.globalCompositeOperation = 'source-over';
      }
      cutoutCtx.restore();
      // Refresh preview from time-linked clip (throttled to once per frame)
      scheduleCutoutPreviewForTime();
    }
    
    function cutoutDraw(e) {
      if (!isCutoutDrawing || !cutoutToolAllowed()) return;
      const { x, y } = cutoutCanvasCoords(e);
      cutoutCtx.save();
      const target = cutoutClips[cutoutDrawingClipIndex];
      const tctx = target ? target.ctx : cutoutCtx;
      // Bones: handle dragging or lasso drawing
      if (currentTool === 'bones' && cutoutIsDraggingBoneHandle && cutoutBoneDrag) {
        // Handle rotation via the dedicated rotation handle
        if (cutoutIsRotatingBone && cutoutBoneRotationData) {
          const b = cutoutBones[cutoutBoneRotationData.boneIndex];
          if (b && b.objectRef) {
            const obj = b.objectRef;
            // Calculate current angle from bone start to mouse
            const currentAngle = Math.atan2(y - b.startY, x - b.startX);
            const angleDelta = currentAngle - cutoutBoneRotationData.startAngle;
            
            // Update object rotation (bone start is the anchor point)
            obj.rotation = cutoutBoneRotationData.initialObjRotation + angleDelta;
            
            // Rotate the bone end around bone start
            const boneLength = b.restLength || Math.hypot(b.endX - b.startX, b.endY - b.startY);
            const newBoneAngle = cutoutBoneRotationData.initialBoneAngle + angleDelta;
            b.endX = b.startX + Math.cos(newBoneAngle) * boneLength;
            b.endY = b.startY + Math.sin(newBoneAngle) * boneLength;
            
            // Keep the object positioned so bone start stays at the same world position
            // Calculate where bone start would be on the object at its current rotation
            const baseW = (obj && obj.drawW != null) ? obj.drawW : ((obj && obj.img && (obj.img.naturalWidth || obj.img.width || obj.img.videoWidth)) || 0);
            const baseH = (obj && obj.drawH != null) ? obj.drawH : ((obj && obj.img && (obj.img.naturalHeight || obj.img.height || obj.img.videoHeight)) || 0);
            const effScaleX = (typeof obj.scaleX === 'number' ? obj.scaleX : 1);
            const effScaleY = (typeof obj.scaleY === 'number' ? obj.scaleY : 1);
            const w = baseW * (obj.scale || 1) * effScaleX;
            const h = baseH * (obj.scale || 1) * effScaleY;
            
            // Use bone's pinnedLocal if available, otherwise compute from center
            let px = (typeof b.pinnedLocalX === 'number') ? b.pinnedLocalX : 0;
            let py = (typeof b.pinnedLocalY === 'number') ? b.pinnedLocalY : 0;
            if (typeof b.pinnedLocalX !== 'number') {
              // Initialize pinnedLocal from current bone position relative to object center
              const objCenterX = obj.x + w / 2;
              const objCenterY = obj.y + h / 2;
              const dx0 = b.startX - objCenterX;
              const dy0 = b.startY - objCenterY;
              const rot0 = cutoutBoneRotationData.initialObjRotation;
              const cos0 = Math.cos(rot0), sin0 = Math.sin(rot0);
              px = b.pinnedLocalX = dx0 * cos0 + dy0 * sin0;
              py = b.pinnedLocalY = -dx0 * sin0 + dy0 * cos0;
            }
            
            // Compute new object position to keep bone start pinned at world position
            const rot = obj.rotation;
            const cos = Math.cos(rot), sin = Math.sin(rot);
            const rx = px * cos - py * sin;
            const ry = px * sin + py * cos;
            const centerX = b.startX - rx;
            const centerY = b.startY - ry;
            obj.x = centerX - w / 2;
            obj.y = centerY - h / 2;
            // When recording, buffer position/rotation keys at current time so bone-driven edits keyframe transforms
            if (cutoutRecorderArmed) {
              if (!cutoutPendingDragKeys) cutoutPendingDragKeys = { position: null, rotation: null, zoom: null, opacity: null };
              cutoutPendingDragKeys.position = { time: cutoutCurrentTime, x: obj.x, y: obj.y };
              cutoutPendingDragKeys.rotation = { time: cutoutCurrentTime, deg: (obj.rotation || 0) * 180 / Math.PI };
            }
            
            // Clamp bone endpoints to canvas
            try {
              const cw = cutoutCanvas ? cutoutCanvas.width : 0;
              const ch = cutoutCanvas ? cutoutCanvas.height : 0;
              if (cw && ch) {
                b.endX = Math.max(0, Math.min(cw, b.endX));
                b.endY = Math.max(0, Math.min(ch, b.endY));
              }
            } catch (_e) {}
            
            // If this bone's END is connected to another bone's START,
            // then rotating this bone's START should also rotate the connected parent bone and its object
            // The START of the bone whose END made the connection is the anchor for the tree branch
            const parentInit = cutoutBoneRotationData.parentInitial;
            if (parentInit && b.attachedAt === 'end' && b.parentAttach === 'start' && b.parentBoneIndex != null) {
              const activeClipRot = getActiveCutoutClipIndex();
              const parentBone = cutoutBones[b.parentBoneIndex];
              if (parentBone && parentBone.clipIndex === activeClipRot && parentBone.objectRef) {
                const parentObj = parentBone.objectRef;
                const pivotX = b.startX;
                const pivotY = b.startY;
                const cosA = Math.cos(angleDelta), sinA = Math.sin(angleDelta);
                
                // Rotate parent bone endpoints from INITIAL positions around this bone's START (the anchor)
                const dxPS = parentInit.boneStartX - pivotX;
                const dyPS = parentInit.boneStartY - pivotY;
                parentBone.startX = pivotX + dxPS * cosA - dyPS * sinA;
                parentBone.startY = pivotY + dxPS * sinA + dyPS * cosA;
                
                const dxPE = parentInit.boneEndX - pivotX;
                const dyPE = parentInit.boneEndY - pivotY;
                parentBone.endX = pivotX + dxPE * cosA - dyPE * sinA;
                parentBone.endY = pivotY + dxPE * sinA + dyPE * cosA;
                
                // Keep the connection: this bone's END stays at parent's START
                b.endX = parentBone.startX;
                b.endY = parentBone.startY;
                
                // Rotate parent object around the pivot (this bone's START) from INITIAL position
                const baseWP = (parentObj.drawW != null) ? parentObj.drawW : ((parentObj.img && (parentObj.img.naturalWidth || parentObj.img.width)) || 0);
                const baseHP = (parentObj.drawH != null) ? parentObj.drawH : ((parentObj.img && (parentObj.img.naturalHeight || parentObj.img.height)) || 0);
                const effScaleXP = (typeof parentObj.scaleX === 'number' ? parentObj.scaleX : 1);
                const effScaleYP = (typeof parentObj.scaleY === 'number' ? parentObj.scaleY : 1);
                const wP = baseWP * (parentObj.scale || 1) * effScaleXP;
                const hP = baseHP * (parentObj.scale || 1) * effScaleYP;
                
                // Use initial center position
                const initialParentCenterX = parentInit.x + wP / 2;
                const initialParentCenterY = parentInit.y + hP / 2;
                
                // Rotate initial parent center around pivot
                const dxPC = initialParentCenterX - pivotX;
                const dyPC = initialParentCenterY - pivotY;
                const newParentCenterX = pivotX + dxPC * cosA - dyPC * sinA;
                const newParentCenterY = pivotY + dxPC * sinA + dyPC * cosA;
                parentObj.x = newParentCenterX - wP / 2;
                parentObj.y = newParentCenterY - hP / 2;
                
                // Set parent's rotation absolutely from initial + delta (not incrementally)
                parentObj.rotation = parentInit.rotation + angleDelta;
                
                // Update parent bone's local coordinates
                const parentObjCenterX2 = parentObj.x + wP / 2;
                const parentObjCenterY2 = parentObj.y + hP / 2;
                const rotP = parentObj.rotation || 0;
                const cosP = Math.cos(rotP), sinP = Math.sin(rotP);
                const dxPSL = parentBone.startX - parentObjCenterX2;
                const dyPSL = parentBone.startY - parentObjCenterY2;
                parentBone.pinnedLocalX = dxPSL * cosP + dyPSL * sinP;
                parentBone.pinnedLocalY = -dxPSL * sinP + dyPSL * cosP;
                const dxPEL = parentBone.endX - parentObjCenterX2;
                const dyPEL = parentBone.endY - parentObjCenterY2;
                parentBone.endLocalX = dxPEL * cosP + dyPEL * sinP;
                parentBone.endLocalY = -dxPEL * sinP + dyPEL * cosP;
                
                // Update this bone's end local coordinates
                const objCenterX2 = obj.x + w / 2;
                const objCenterY2 = obj.y + h / 2;
                const rotB = obj.rotation || 0;
                const cosB = Math.cos(rotB), sinB = Math.sin(rotB);
                const dxBE = b.endX - objCenterX2;
                const dyBE = b.endY - objCenterY2;
                b.endLocalX = dxBE * cosB + dyBE * sinB;
                b.endLocalY = -dxBE * sinB + dyBE * cosB;
              }
            }
          }
          scheduleDrawCutoutBonesOverlay();
          scheduleCutoutPreviewForTime();
          lastCutoutX = x; lastCutoutY = y;
          cutoutCtx.restore();
          return;
        }
        
        const b = cutoutBones[cutoutBoneDrag.boneIndex];
        if (b) {
          const isHandleAttachedToParent = (b.attachedAt === cutoutBoneDrag.handle);
          let hasChildrenOnHandle = false;
          const activeClip = getActiveCutoutClipIndex();
          for (let i = 0; i < cutoutBones.length; i++) {
            const c = cutoutBones[i];
            if (!c || c.clipIndex !== activeClip) continue;
            if (c.parentBoneIndex === cutoutBoneDrag.boneIndex && c.parentAttach === cutoutBoneDrag.handle) { hasChildrenOnHandle = true; break; }
          }
          const isJointDrag = isHandleAttachedToParent || hasChildrenOnHandle;
          if (isJointDrag) {
            if (cutoutBoneDrag.handle === 'start') {
              // Translate entire connected component within active clip (no rotation) â€” do not move attached objects
              const activeClipIdx = getActiveCutoutClipIndex();
              const queue = [cutoutBoneDrag.boneIndex];
              const visited = new Set();
              while (queue.length) {
                const idx = queue.shift();
                if (visited.has(idx)) continue;
                visited.add(idx);
                const n = cutoutBones[idx];
                if (!n || n.clipIndex !== activeClipIdx) continue;
                n.startX += (x - lastCutoutX); n.startY += (y - lastCutoutY);
                n.endX += (x - lastCutoutX); n.endY += (y - lastCutoutY);
                
                // Clamp both endpoints to object bounds
                const obj = n.objectRef;
                if (obj) {
                  const baseW = (obj.drawW != null) ? obj.drawW : ((obj.img && (obj.img.naturalWidth || obj.img.width)) || 0);
                  const baseH = (obj.drawH != null) ? obj.drawH : ((obj.img && (obj.img.naturalHeight || obj.img.height)) || 0);
                  const effScaleX = (typeof obj.scaleX === 'number' ? obj.scaleX : 1);
                  const effScaleY = (typeof obj.scaleY === 'number' ? obj.scaleY : 1);
                  const objW = baseW * (obj.scale || 1) * effScaleX;
                  const objH = baseH * (obj.scale || 1) * effScaleY;
                  const objLeft = obj.x;
                  const objTop = obj.y;
                  const objRight = objLeft + objW;
                  const objBottom = objTop + objH;
                  n.startX = Math.max(objLeft, Math.min(objRight, n.startX));
                  n.startY = Math.max(objTop, Math.min(objBottom, n.startY));
                  n.endX = Math.max(objLeft, Math.min(objRight, n.endX));
                  n.endY = Math.max(objTop, Math.min(objBottom, n.endY));
                  
                  // Update pinned local position (bone anchor in local space)
                  const objCenterX = objLeft + objW / 2;
                  const objCenterY = objTop + objH / 2;
                  const rot = obj.rotation || 0;
                  const anchorDx = n.startX - objCenterX;
                  const anchorDy = n.startY - objCenterY;
                  const cos = Math.cos(rot), sin = Math.sin(rot);
                  n.pinnedLocalX = anchorDx * cos + anchorDy * sin;
                  n.pinnedLocalY = -anchorDx * sin + anchorDy * cos;
                }
                
                // enqueue parent and children
                if (n.parentBoneIndex != null) queue.push(n.parentBoneIndex);
                for (let i = 0; i < cutoutBones.length; i++) {
                  const c = cutoutBones[i];
                  if (!c || c.clipIndex !== activeClipIdx) continue;
                  if (c.parentBoneIndex === idx) queue.push(i);
                }
              }
            } else {
              // End handle: rotate around start (no scaling)
              moveCutoutJointWithParentRotation(cutoutBoneDrag.boneIndex, cutoutBoneDrag.handle, x, y);
            }
          } else {
            if (cutoutBoneDrag.handle === 'start') {
              // Move start endpoint - acts as anchor point, so object moves with it
              const dx = x - lastCutoutX, dy = y - lastCutoutY;
              b.startX += dx; b.startY += dy;
              
              // Get object bounds for constraining
              const obj = b.objectRef;
              if (obj) {
                const baseW = (obj.drawW != null) ? obj.drawW : ((obj.img && (obj.img.naturalWidth || obj.img.width)) || 0);
                const baseH = (obj.drawH != null) ? obj.drawH : ((obj.img && (obj.img.naturalHeight || obj.img.height)) || 0);
                const effScaleX = (typeof obj.scaleX === 'number' ? obj.scaleX : 1);
                const effScaleY = (typeof obj.scaleY === 'number' ? obj.scaleY : 1);
                const objW = baseW * (obj.scale || 1) * effScaleX;
                const objH = baseH * (obj.scale || 1) * effScaleY;
                
                // Clamp start to object bounds
                const objLeft = obj.x;
                const objTop = obj.y;
                const objRight = objLeft + objW;
                const objBottom = objTop + objH;
                b.startX = Math.max(objLeft, Math.min(objRight, b.startX));
                b.startY = Math.max(objTop, Math.min(objBottom, b.startY));
                
                // Update pinned local position (bone anchor in local space)
                const objCenterX = objLeft + objW / 2;
                const objCenterY = objTop + objH / 2;
                const rot = obj.rotation || 0;
                const anchorDx = b.startX - objCenterX;
                const anchorDy = b.startY - objCenterY;
                const cos = Math.cos(rot), sin = Math.sin(rot);
                b.pinnedLocalX = anchorDx * cos + anchorDy * sin;
                b.pinnedLocalY = -anchorDx * sin + anchorDy * cos;
              }
            } else {
              // End-handle drag: axial vs perpendicular behavior
              const mvx = x - lastCutoutX, mvy = y - lastCutoutY;
              let ax = b.endX - b.startX, ay = b.endY - b.startY;
              let alen = Math.hypot(ax, ay);
              if (alen < 1e-6) { ax = (x - b.startX); ay = (y - b.startY); alen = Math.hypot(ax, ay) || 1; }
              const ux = ax / alen, uy = ay / alen;
              const ds = mvx * ux + mvy * uy;      // along axis
              const dp = -mvx * uy + mvy * ux;     // perpendicular
              
              // Get object bounds for constraining
              const obj = b.objectRef;
              let objLeft = 0, objTop = 0, objRight = cutoutCanvas ? cutoutCanvas.width : 0, objBottom = cutoutCanvas ? cutoutCanvas.height : 0;
              if (obj) {
                const baseW = (obj.drawW != null) ? obj.drawW : ((obj.img && (obj.img.naturalWidth || obj.img.width)) || 0);
                const baseH = (obj.drawH != null) ? obj.drawH : ((obj.img && (obj.img.naturalHeight || obj.img.height)) || 0);
                const effScaleX = (typeof obj.scaleX === 'number' ? obj.scaleX : 1);
                const effScaleY = (typeof obj.scaleY === 'number' ? obj.scaleY : 1);
                const objW = baseW * (obj.scale || 1) * effScaleX;
                const objH = baseH * (obj.scale || 1) * effScaleY;
                objLeft = obj.x;
                objTop = obj.y;
                objRight = objLeft + objW;
                objBottom = objTop + objH;
              }
              
              if (Math.abs(ds) >= Math.abs(dp)) {
                // Adjust length along axis (no rotation, do not move object)
                b.endX += ux * ds;
                b.endY += uy * ds;
                b.restLength = Math.hypot(b.endX - b.startX, b.endY - b.startY);
                // Clamp end to object bounds
                b.endX = Math.max(objLeft, Math.min(objRight, b.endX));
                b.endY = Math.max(objTop, Math.min(objBottom, b.endY));
              } else {
                // Rotate with fixed length around start
                const L = Math.max(0.0001, b.restLength || Math.hypot(b.endX - b.startX, b.endY - b.startY));
                const vx = x - b.startX, vy = y - b.startY;
                const len = Math.hypot(vx, vy) || 1;
                b.endX = b.startX + (vx / len) * L;
                b.endY = b.startY + (vy / len) * L;
                // Clamp end to object bounds
                b.endX = Math.max(objLeft, Math.min(objRight, b.endX));
                b.endY = Math.max(objTop, Math.min(objBottom, b.endY));
              }
              
              // Update end local position for memory across mode switches
              if (obj) {
                const objCenterX2 = objLeft + (objRight - objLeft) / 2;
                const objCenterY2 = objTop + (objBottom - objTop) / 2;
                const rot2 = obj.rotation || 0;
                const dxEnd = b.endX - objCenterX2;
                const dyEnd = b.endY - objCenterY2;
                const cos2 = Math.cos(rot2), sin2 = Math.sin(rot2);
                b.endLocalX = dxEnd * cos2 + dyEnd * sin2;
                b.endLocalY = -dxEnd * sin2 + dyEnd * cos2;
              }
            }
          }
          // Throttle overlay redraw and preview recomposition to once per animation frame
          scheduleDrawCutoutBonesOverlay();
          scheduleCutoutPreviewForTime();
        }
        lastCutoutX = x; lastCutoutY = y;
        cutoutCtx.restore();
        return;
      } else if (currentTool === 'bones' && cutoutBonesModeObjDrag) {
        // Handle object dragging in bones mode (when not on a bone node)
        const bone = cutoutBones[cutoutBonesModeObjDrag.boneIndex];
        if (bone && bone.objectRef) {
          const obj = bone.objectRef;
          const dx = x - cutoutBonesModeObjDrag.offsetX - obj.x;
          const dy = y - cutoutBonesModeObjDrag.offsetY - obj.y;
          obj.x += dx;
          obj.y += dy;
          // Move both bone endpoints with the object
          bone.startX += dx;
          bone.startY += dy;
          bone.endX += dx;
          bone.endY += dy;
          // Clamp to canvas bounds
          try {
            const cw = cutoutCanvas ? cutoutCanvas.width : 0;
            const ch = cutoutCanvas ? cutoutCanvas.height : 0;
            if (cw && ch) {
              bone.startX = Math.max(0, Math.min(cw, bone.startX));
              bone.startY = Math.max(0, Math.min(ch, bone.startY));
              bone.endX = Math.max(0, Math.min(cw, bone.endX));
              bone.endY = Math.max(0, Math.min(ch, bone.endY));
            }
          } catch (_e) {}
          scheduleDrawCutoutBonesOverlay();
          scheduleCutoutPreviewForTime();
        }
        lastCutoutX = x; lastCutoutY = y;
        cutoutCtx.restore();
        return;
      } else if (currentTool === 'bones' && cutoutIsBoneLassoActive) {
        cutoutBoneLassoPoints.push([x, y]);
        if (lassoOverlayCtx && lassoOverlayCanvas) {
          const w = lassoOverlayCanvas.width;
          const h = lassoOverlayCanvas.height;
          lassoOverlayCtx.clearRect(0, 0, w, h);
          lassoOverlayCtx.strokeStyle = '#ffffff';
          lassoOverlayCtx.lineWidth = 2;
          lassoOverlayCtx.setLineDash([8, 4]);
          lassoOverlayCtx.beginPath();
          lassoOverlayCtx.moveTo(cutoutBoneLassoPoints[0][0], cutoutBoneLassoPoints[0][1]);
          for (let i = 1; i < cutoutBoneLassoPoints.length; i++) {
            lassoOverlayCtx.lineTo(cutoutBoneLassoPoints[i][0], cutoutBoneLassoPoints[i][1]);
          }
          lassoOverlayCtx.stroke();
          lassoOverlayCtx.setLineDash([]);
        }
        cutoutCtx.restore();
        lastCutoutX = x;
        lastCutoutY = y;
        return;
      }
      // Magic lasso drawing in cutout canvas
      if ((currentTool === 'inbetween' || currentTool === 'detail' || currentTool === 'lasso' || currentTool === 'select-lasso' || currentTool === 'extend-lasso') && isMagicLassoActive) {
        magicLassoPoints.push([x, y]);
        if (lassoOverlayCtx && lassoOverlayCanvas) {
          const w = lassoOverlayCanvas.width;
          const h = lassoOverlayCanvas.height;
          lassoOverlayCtx.clearRect(0, 0, w, h);
          // Use similar styling as main magic lasso
          lassoOverlayCtx.strokeStyle = (currentTool === 'lasso') ? '#ffffff' : (currentTool === 'select-lasso' ? '#ffffff' : 'rgba(16,185,129,0.95)'); // classic/selection/magic
          lassoOverlayCtx.lineWidth = 2;
          lassoOverlayCtx.setLineDash([8, 4]);
          lassoOverlayCtx.beginPath();
          lassoOverlayCtx.moveTo(magicLassoPoints[0][0], magicLassoPoints[0][1]);
          for (let i = 1; i < magicLassoPoints.length; i++) {
            lassoOverlayCtx.lineTo(magicLassoPoints[i][0], magicLassoPoints[i][1]);
          }
          lassoOverlayCtx.stroke();
          lassoOverlayCtx.setLineDash([]);
        }
        cutoutCtx.restore();
        lastCutoutX = x;
        lastCutoutY = y;
        return;
      }
      if (currentTool === 'pencil') {
        tctx.globalAlpha = brushOpacity;
        tctx.strokeStyle = currentColor;
        tctx.lineWidth = Math.max(1, brushSize / 2);
        tctx.lineCap = 'round';
        tctx.lineJoin = 'round';
        tctx.beginPath();
        tctx.moveTo(lastCutoutX, lastCutoutY);
        tctx.lineTo(x, y);
        tctx.stroke();
      } else if (currentTool === 'brush') {
        tctx.globalAlpha = brushOpacity;
        tctx.strokeStyle = currentColor;
        if (typeof drawWithBrushType === 'function') {
          drawWithBrushType(tctx, lastCutoutX, lastCutoutY, x, y);
        } else {
          tctx.beginPath();
          tctx.moveTo(lastCutoutX, lastCutoutY);
          tctx.lineTo(x, y);
          tctx.stroke();
        }
      } else if (currentTool === 'eraser') {
        tctx.globalCompositeOperation = 'destination-out';
        tctx.lineWidth = brushSize;
        tctx.lineCap = 'round';
        tctx.lineJoin = 'round';
        tctx.beginPath();
        tctx.moveTo(lastCutoutX, lastCutoutY);
        tctx.lineTo(x, y);
        tctx.stroke();
        tctx.globalCompositeOperation = 'source-over';
      }
      cutoutCtx.restore();
      lastCutoutX = x;
      lastCutoutY = y;
      scheduleCutoutPreviewForTime();
    }
    
    function cutoutStopDraw() {
      if (!isCutoutDrawing) return;
      isCutoutDrawing = false;
      // No additional snapshot at stop to avoid duplicate clips
      cutoutDrawingClipIndex = -1;
      // End-of-stroke snapshot for undo/redo parity with main mode
      if (currentTool === 'pencil' || currentTool === 'brush' || currentTool === 'eraser') {
        saveState();
      }
      // Bones: finalize drag or lasso creation
      if (currentTool === 'bones') {
        if (cutoutIsDraggingBoneHandle) {
          try { saveState(); } catch (_e) {}
          
          // Reset bone rotation state if we were rotating
          if (cutoutIsRotatingBone) {
            cutoutIsRotatingBone = false;
            cutoutBoneRotationData = null;
            cutoutIsDraggingBoneHandle = false;
            cutoutBoneDrag = null;
            ensureCutoutBonesOverlay();
            drawCutoutBonesOverlay();
            renderCutoutPreviewForTime();
            return;
          }
          
          if (cutoutBoneDrag) {
            const draggedIndex = cutoutBoneDrag.boneIndex;
            const draggedBone = cutoutBones[draggedIndex];
            const activeClip = getActiveCutoutClipIndex();
            if (draggedBone && draggedBone.clipIndex === activeClip && cutoutBoneDrag.handle !== 'rotation') {
              const hx = cutoutBoneDrag.handle === 'start' ? draggedBone.startX : draggedBone.endX;
              const hy = cutoutBoneDrag.handle === 'start' ? draggedBone.startY : draggedBone.endY;
              // Only END nodes can connect to START nodes
              const target = getCutoutBoneHandleNearForConnection(hx, hy, draggedIndex, cutoutBoneDrag.handle);
              if (target && cutoutBoneDrag.handle === 'end' && target.handle === 'start') {
                const parent = cutoutBones[target.boneIndex];
                if (parent && parent.clipIndex === activeClip) {
                  draggedBone.parentBoneIndex = target.boneIndex;
                  draggedBone.attachedAt = 'end'; // Child's END is attached
                  draggedBone.parentAttach = 'start'; // To parent's START
                  const px = parent.startX;
                  const py = parent.startY;
                  draggedBone.endX = px;
                  draggedBone.endY = py;
                  enforceCutoutBoneConnections();
                }
              }
            }
          }
          cutoutIsDraggingBoneHandle = false;
          cutoutBoneDrag = null;
          ensureCutoutBonesOverlay();
          drawCutoutBonesOverlay();
          renderCutoutPreviewForTime();
        } else if (cutoutBonesModeObjDrag) {
          // End object dragging in bones mode
          cutoutBonesModeObjDrag = null;
          ensureCutoutBonesOverlay();
          drawCutoutBonesOverlay();
          renderCutoutPreviewForTime();
        } else if (cutoutIsBoneLassoActive) {
          cutoutCreateSelectionFromPolygonForBones().then((res) => {
            if (res && res.obj) {
              const { cx, cy, angle, minProj, maxProj, vx, vy } = computePrincipalAxis(cutoutBoneLassoPoints);
              let startX = cx + vx * minProj;
              let startY = cy + vy * minProj;
              let endX   = cx + vx * maxProj;
              let endY   = cy + vy * maxProj;
              const initialScale = res.obj.scale || 1;
              const initialAngle = Math.atan2(endY - startY, endX - startX);
              const activeClip = getActiveCutoutClipIndex();
              
              // Store original pivot before bone mode
              const objId = res.obj.id;
              if (objId != null && !preBonePivotStorage[objId]) {
                preBonePivotStorage[objId] = {
                  pivotLocalX: (typeof res.obj.pivotLocalX === 'number') ? res.obj.pivotLocalX : undefined,
                  pivotLocalY: (typeof res.obj.pivotLocalY === 'number') ? res.obj.pivotLocalY : undefined
                };
              }
              
              // Get object bounds for constraining bone endpoints
              const baseW = (res.obj.drawW != null) ? res.obj.drawW : ((res.obj.img && (res.obj.img.naturalWidth || res.obj.img.width)) || 0);
              const baseH = (res.obj.drawH != null) ? res.obj.drawH : ((res.obj.img && (res.obj.img.naturalHeight || res.obj.img.height)) || 0);
              const effScaleX = (typeof res.obj.scaleX === 'number' ? res.obj.scaleX : 1);
              const effScaleY = (typeof res.obj.scaleY === 'number' ? res.obj.scaleY : 1);
              const objW = baseW * (res.obj.scale || 1) * effScaleX;
              const objH = baseH * (res.obj.scale || 1) * effScaleY;
              const objLeft = res.obj.x;
              const objTop = res.obj.y;
              const objRight = objLeft + objW;
              const objBottom = objTop + objH;
              
              // Clamp bone endpoints to object bounds (selection box area)
              startX = Math.max(objLeft, Math.min(objRight, startX));
              startY = Math.max(objTop, Math.min(objBottom, startY));
              endX = Math.max(objLeft, Math.min(objRight, endX));
              endY = Math.max(objTop, Math.min(objBottom, endY));
              
              const restLength = Math.hypot(endX - startX, endY - startY);
              
              // Calculate bone anchor in object's local space (unrotated)
              // This is used as the pinned point when rotating via bone
              const objCenterX = objLeft + objW / 2;
              const objCenterY = objTop + objH / 2;
              const rot = res.obj.rotation || 0;
              const cos = Math.cos(rot), sin = Math.sin(rot);
              
              // Start node local position (anchor point)
              const dxStart = startX - objCenterX;
              const dyStart = startY - objCenterY;
              const pinnedLocalX = dxStart * cos + dyStart * sin;
              const pinnedLocalY = -dxStart * sin + dyStart * cos;
              
              // End node local position (tracked for memory across mode switches)
              const dxEnd = endX - objCenterX;
              const dyEnd = endY - objCenterY;
              const endLocalX = dxEnd * cos + dyEnd * sin;
              const endLocalY = -dxEnd * sin + dyEnd * cos;
              
              cutoutBones.push({
                clipIndex: activeClip,
                objectRef: res.obj,
                startX, startY, endX, endY,
                restLength,
                initialScale,
                restAngle: initialAngle,
                prevAngle: initialAngle,
                imageRotationOffset: (res.obj.rotation || 0) - initialAngle,
                pinnedLocalX,
                pinnedLocalY,
                endLocalX,
                endLocalY
              });
              
              // Synchronize object position with bone formula to prevent mismatch
              // This ensures stored position equals what renderCutoutPreviewForTime computes
              // The formula: objectCenter = boneStart - rotatedPinnedLocal, then x = center - width/2
              const syncRot = res.obj.rotation || 0;
              const syncCos = Math.cos(syncRot), syncSin = Math.sin(syncRot);
              const syncRx = pinnedLocalX * syncCos - pinnedLocalY * syncSin;
              const syncRy = pinnedLocalX * syncSin + pinnedLocalY * syncCos;
              const syncCenterX = startX - syncRx;
              const syncCenterY = startY - syncRy;
              res.obj.x = syncCenterX - objW / 2;
              res.obj.y = syncCenterY - objH / 2;
              
              try { saveState(); } catch (_e) {}
              ensureCutoutBonesOverlay();
              drawCutoutBonesOverlay();
              renderCutoutPreviewForTime();
            }
          }).finally(() => {
            if (lassoOverlayCanvas) {
              lassoOverlayCanvas.remove();
              lassoOverlayCanvas = null;
              lassoOverlayCtx = null;
            }
            cutoutIsBoneLassoActive = false;
            cutoutBoneLassoPoints = [];
            // Auto-disarm drawing after creating a bone; bones remain visible/movable
            cutoutBonesDrawArmed = false;
            // Remove active state from bones button to show drawing is disarmed
            const bonesBtn = document.getElementById('bones-btn');
            if (bonesBtn) {
              bonesBtn.classList.remove('active');
            }
          });
        }
      }
      // End cutout lasso overlay if active and apply functionality
      if (isMagicLassoActive && (currentTool === 'inbetween' || currentTool === 'detail' || currentTool === 'lasso' || currentTool === 'select-lasso' || currentTool === 'extend-lasso')) {
        // Apply effect to current clip canvas if available
        const target = cutoutClips[selectedCutoutClipIndex >= 0 ? selectedCutoutClipIndex : cutoutDrawingClipIndex];
        const tctx = target ? target.ctx : null;
        if (tctx && magicLassoPoints.length >= 3) {
          // Snapshot before applying lasso effect so undo is per-lasso
          try { saveState(); } catch (_e) {}
          if (currentTool === 'lasso') {
            cutoutApplyEraserLasso(tctx, magicLassoPoints);
          } else if (currentTool === 'detail') {
            cutoutApplyDetailLasso(tctx, magicLassoPoints);
          } else if (currentTool === 'select-lasso') {
            // Create selection object with handles in cutout mode
            cutoutCreateSelectionFromPolygon();
            // Keep current tool visual state; selection will remain active
          } else if (currentTool === 'inbetween') {
            // Simple tween-esque duplicate fade within selection
            cutoutApplyInbetweenLasso(tctx, magicLassoPoints);
          } else if (currentTool === 'extend-lasso') {
            cutoutApplyExtendLasso(tctx, magicLassoPoints);
          }
          // Snapshot after effect for redo parity
          try { saveState(); } catch (_e) {}
        }
        if (lassoOverlayCanvas) {
          lassoOverlayCanvas.remove();
          lassoOverlayCanvas = null;
          lassoOverlayCtx = null;
        }
        isMagicLassoActive = false;
        magicLassoPoints = [];
        magicLassoMode = null;
      }
      renderCutoutClips();
      renderCutoutPreviewForTime();
    }
    
    function onCutoutKeyDown(e) {
      if (e.key !== 'Delete' && e.key !== 'Backspace') return;
      // Bones tool: if a bone endpoint was selected, delete only the bone (not the object)
      if (isCutOutMode && currentTool === 'bones' && typeof cutoutSelectedBoneIndex === 'number' && cutoutSelectedBoneIndex >= 0) {
        e.preventDefault();
        e.stopPropagation();
        deleteCutoutBoneAtIndex(cutoutSelectedBoneIndex);
        return;
      }
      // If a transition is selected, let the transitions handler delete it, and skip clip deletion
      try {
        if (typeof selectedCutoutTransitionId === 'string' && selectedCutoutTransitionId) {
          return;
        }
      } catch (_e) {}
      // If timeline property keys are selected or exist at current time, delete ONLY keys (not objects)
      try {
        const epsilon = 1 / 60;
        const tNow = Math.max(0, Math.min(cutoutDuration, cutoutCurrentTime || 0));
        const deleteSelectedKeyGroup = () => {
          if (!dragPropKey || !Array.isArray(dragPropKey.group) || dragPropKey.group.length === 0) return false;
          let removed = false;
          const byRefRemove = (arr, ref) => {
            if (!Array.isArray(arr) || !ref) return false;
            const idx = arr.indexOf(ref);
            if (idx >= 0) { arr.splice(idx, 1); return true; }
            return false;
          };
          for (const entry of dragPropKey.group) {
            if (!entry || !entry.prop || !entry.keyRef) continue;
            const arr = cutoutPropertyKeys && cutoutPropertyKeys[entry.prop];
            if (byRefRemove(arr, entry.keyRef)) removed = true;
          }
          if (removed) {
            drawCutoutTimeline(); updateRowKeyActiveStates(); applyCutoutKeyframedTransformsAtTime(); saveState();
          }
          // Clear selection context
          dragPropKey.group = [];
          isDraggingPropKey = false;
          return removed;
        };
        const deleteKeysAtNow = () => {
          if (!cutoutPropertyKeys) return false;
          let removed = false;
          ['position','zoom','rotation','opacity'].forEach((p) => {
            const arr = Array.isArray(cutoutPropertyKeys[p]) ? cutoutPropertyKeys[p] : null;
            if (!arr || !arr.length) return;
            for (let i = arr.length - 1; i >= 0; i--) {
              if (Math.abs(arr[i].time - tNow) <= epsilon) { arr.splice(i, 1); removed = true; }
            }
          });
          if (removed) {
            drawCutoutTimeline(); updateRowKeyActiveStates(); applyCutoutKeyframedTransformsAtTime(); saveState();
          }
          return removed;
        };
        // Priority: if there is a selected key group, delete it; else delete keys at current time
        const removedKeys = deleteSelectedKeyGroup() || deleteKeysAtNow();
        if (removedKeys) {
          e.preventDefault(); e.stopPropagation();
          return;
        }
      } catch (_e) {}
      // If a clip effect icon is selected, delete only that effect from its clip
      if (typeof selectedCutoutEffectClipIndex === 'number' && selectedCutoutEffectClipIndex >= 0 && selectedCutoutEffectId) {
        const cidx = selectedCutoutEffectClipIndex;
        const eid = selectedCutoutEffectId;
        const clip = cutoutClips[cidx];
        if (clip && Array.isArray(clip.effects)) {
          const i = clip.effects.indexOf(eid);
          if (i >= 0) {
            try { saveState(); } catch (_e) {}
            clip.effects.splice(i, 1);
            selectedCutoutEffectClipIndex = -1;
            selectedCutoutEffectId = '';
            renderCutoutClips();
            if (typeof applyCutoutClipEffects === 'function') applyCutoutClipEffects(clip);
            renderCutoutPreviewForTime();
            try { e.preventDefault(); e.stopPropagation(); } catch (_e) {}
            return;
          }
        }
      }
      // Work out active clip
      let idx = (typeof selectedCutoutClipIndex === 'number' && selectedCutoutClipIndex >= 0)
        ? selectedCutoutClipIndex
        : getActiveCutoutClipIndexAt(cutoutCurrentTime);
      if (idx < 0) return;
      const clip = cutoutClips[idx];
      if (!clip) return;
      e.preventDefault();
      e.stopPropagation();
      // If an object is selected, delete only that object (not the whole clip)
      if (cutoutSelectedObject) {
        try { saveState(); } catch (_e) {}
        if (Array.isArray(clip.objects) && clip.objects.length) {
          const targetId = cutoutSelectedObject.id;
          const existingIdx = (targetId != null)
            ? clip.objects.findIndex(o => o && o.id === targetId)
            : clip.objects.findIndex(o => o === cutoutSelectedObject);
          if (existingIdx >= 0) {
            clip.objects.splice(existingIdx, 1);
          }
        }
        // Tear down selection overlay and refresh UI
        try { cutoutCancelSelectionOverlay(); } catch (_e) {}
        cutoutActiveObject = null;
        cutoutSelectedObject = null;
        renderCutoutPreviewForTime();
        renderCutoutClips();
        if (typeof renderCutoutObjectsList === 'function') renderCutoutObjectsList();
        if (typeof renderCutoutLayersPanel === 'function') renderCutoutLayersPanel();
        try { saveState(); } catch (_e) {}
        return;
      }
      // No object selected: fallback to previous behavior (delete clip)
      try { saveState(); } catch (_e) {}
      cutoutClips.splice(idx, 1);
      // Reset selection index since the list changed
      selectedCutoutClipIndex = -1;
      renderCutoutClips();
      renderCutoutPreviewForTime();
      try { saveState(); } catch (_e) {}
    }
    
    function startCutoutClipResize(e, index, side) {
      e.stopPropagation();
      isResizingCutoutClip = true;
      resizeCutoutClipIndex = index;
      resizeCutoutClipSide = side;
      resizeCutoutStartX = e.clientX;
      resizeCutoutOrigStart = cutoutClips[index].start;
      resizeCutoutOrigEnd = cutoutClips[index].end;
      document.body.style.userSelect = 'none';
      window.addEventListener('mousemove', onCutoutClipResizeMove);
      window.addEventListener('mouseup', endCutoutClipResize, { once: true });
      saveState();
    }
    
    function onCutoutClipResizeMove(e) {
      if (!isResizingCutoutClip) return;
      const track = document.getElementById('cutout-ruler-area');
      if (!track) return;
      const rect = track.getBoundingClientRect();
      const pixelsPerSecond = 60;
      const dx = e.clientX - resizeCutoutStartX;
      let newStart = resizeCutoutOrigStart;
      let newEnd = resizeCutoutOrigEnd;
      if (resizeCutoutClipSide === 'left') {
        newStart = resizeCutoutOrigStart + (dx / pixelsPerSecond);
      } else {
        newEnd = resizeCutoutOrigEnd + (dx / pixelsPerSecond);
      }
      // Clamp within [0, cutoutDuration]
      newStart = Math.max(0, Math.min(newStart, cutoutDuration));
      newEnd = Math.max(0, Math.min(newEnd, cutoutDuration));
      // Enforce min duration 1 frame
      if (newEnd - newStart < 1 / 60) {
        if (resizeCutoutClipSide === 'left') newStart = newEnd - 1 / 60;
        else newEnd = newStart + 1 / 60;
      }
      // Prevent overlaps with neighbors
      const sorted = [...cutoutClips].map((c, i) => ({ ...c, i })).sort((a, b) => a.start - b.start);
      const pos = sorted.findIndex(c => c.i === resizeCutoutClipIndex);
      const prev = pos > 0 ? sorted[pos - 1] : null;
      const next = pos < sorted.length - 1 ? sorted[pos + 1] : null;
      if (resizeCutoutClipSide === 'left' && prev) {
        newStart = Math.max(newStart, prev.end);
      }
      if (resizeCutoutClipSide === 'right' && next) {
        newEnd = Math.min(newEnd, next.start);
      }
      // Apply
      const clip = cutoutClips[resizeCutoutClipIndex];
      clip.start = Math.min(newStart, newEnd - 1 / 60);
      clip.end = Math.max(newEnd, clip.start + 1 / 60);
      renderCutoutClips();
    }
    
    function endCutoutClipResize() {
      if (!isResizingCutoutClip) return;
      isResizingCutoutClip = false;
      document.body.style.userSelect = '';
      window.removeEventListener('mousemove', onCutoutClipResizeMove);
      renderCutoutPreviewForTime();
      saveState();
    }
    
    function startCutoutClipDrag(e, index) {
      isDraggingCutoutClip = true;
      dragCutoutClipIndex = index;
      dragCutoutStartMouseX = e.clientX;
      dragCutoutOrigStart = cutoutClips[index].start;
      dragCutoutOrigEnd = cutoutClips[index].end;
      document.body.style.userSelect = 'none';
      window.addEventListener('mousemove', onCutoutClipDragMove);
      window.addEventListener('mouseup', endCutoutClipDrag, { once: true });
      saveState();
    }
    
    function onCutoutClipDragMove(e) {
      if (!isDraggingCutoutClip) return;
      const track = document.getElementById('cutout-ruler-area');
      if (!track) return;
      const pixelsPerSecond = 60;
      const dx = e.clientX - dragCutoutStartMouseX;
      let delta = dx / pixelsPerSecond;
      // Propose new start/end
      let newStart = dragCutoutOrigStart + delta;
      let newEnd = dragCutoutOrigEnd + delta;
      // Clamp to bounds
      const duration = dragCutoutOrigEnd - dragCutoutOrigStart;
      if (newStart < 0) { newStart = 0; newEnd = duration; }
      if (newEnd > cutoutDuration) { newEnd = cutoutDuration; newStart = cutoutDuration - duration; }
      // Prevent overlaps with neighbors
      const sorted = [...cutoutClips].map((c, i) => ({ ...c, i })).sort((a, b) => a.start - b.start);
      const pos = sorted.findIndex(c => c.i === dragCutoutClipIndex);
      const prev = pos > 0 ? sorted[pos - 1] : null;
      const next = pos < sorted.length - 1 ? sorted[pos + 1] : null;
      if (prev && newStart < prev.end) {
        const shift = prev.end - newStart;
        newStart += shift;
        newEnd += shift;
      }
      if (next && newEnd > next.start) {
        const shift = newEnd - next.start;
        newStart -= shift;
        newEnd -= shift;
      }
      // Apply
      const clip = cutoutClips[dragCutoutClipIndex];
      clip.start = Math.max(0, Math.min(newStart, cutoutDuration - 1 / 60));
      clip.end = Math.max(clip.start + 1 / 60, Math.min(newEnd, cutoutDuration));
      renderCutoutClips();
    }
    
    function endCutoutClipDrag() {
      if (!isDraggingCutoutClip) return;
      isDraggingCutoutClip = false;
      document.body.style.userSelect = '';
      window.removeEventListener('mousemove', onCutoutClipDragMove);
      renderCutoutPreviewForTime();
      saveState();
    }
    let lassoOverlayCanvas = null;
    let lassoOverlayCtx = null;
    // Move/Select overlay state
    let moveOverlayCanvas = null;
    let moveOverlayCtx = null;
    let dragBaseCanvas = null;
    let dragBaseCtx = null;
    let isDraggingImage = false;
    let isResizingImage = false;
    let resizeCorner = '';
    let resizeAnchorX = 0;
    let resizeAnchorY = 0;
    let resizeStartX = 0;
    let resizeStartY = 0;
    let resizeStartScale = 1;
    let resizeStartWidth = 0;
    let resizeStartHeight = 0;
    let resizeStartPosX = 0;
    let resizeStartPosY = 0;
    let isRotatingImage = false;
    let isDraggingPivot = false;
    let activeTransformHandle = null;
    let rotationCenterX = 0;
    let rotationCenterY = 0;
    let rotationStartAngle = 0;
    let rotationCurrentAngle = 0;
    const HANDLE_SIZE = 40; // visual size in canvas pixels (larger for easier grab)
    const HANDLE_HIT_EXTRA = 16; // extra hit area beyond visual box
    const ROTATION_HANDLE_OFFSET = 60; // distance beyond edge for rotation node
    // requestAnimationFrame throttling for drag rendering
    let dragRafScheduled = false;
    let dragRafX = 0;
    let dragRafY = 0;
    /* Changed initial viewport to phone */
    let currentViewport = 'phone';
    /* Added zoom levels array for each frame */
    const zoomLevels = [1, 1, 1, 1, 1, 1];
    // Throttled compose flag
    let composeRafScheduled = false;
    
    function getTargetCanvasSizeForViewport(mode) {
      // High-resolution internal canvas sizes for crisp rendering
      if (mode === 'desktop') {
        return { width: 1920, height: 1080 };
      }
      return { width: 1080, height: 1920 }; // phone (9:16)
    }
    // Image selection state
    let selectedImageObject = null;
    let imageDragOffsetX = 0;
    let imageDragOffsetY = 0;
    
    // Timeline drag functionality
    let isDraggingRib = false;
    let dragFrameIndex = -1;
    let dragSide = '';
    let dragStartX = 0;
    let dragStartDuration = 0;

    const layerColors = ['#6366f1', '#ec4899', '#10b981', '#f59e0b', '#8b5cf6', '#ef4444', '#06b6d4', '#84cc16'];
    

    for (let i = 0; i < 6; i++) {
      const layerCanvas = document.createElement('canvas');
      const initSize = getTargetCanvasSizeForViewport(currentViewport);
      layerCanvas.width = initSize.width;
      layerCanvas.height = initSize.height;
      const layerCtx = layerCanvas.getContext('2d', { willReadFrequently: true });
      
      // Enable high-quality image smoothing
      layerCtx.imageSmoothingEnabled = true;
      layerCtx.imageSmoothingQuality = 'high';
      
      frameLayers[i].push({
        canvas: layerCanvas,
        ctx: layerCtx,
        visible: true,
        name: 'Layer 1',
        opacity: 1,
        color: layerColors[0],
        images: []
      });
    }

    // Checkerboard background utilities
    function __ensureCheckerTile() {
      if (window.__checkerTile && window.__checkerTile instanceof HTMLCanvasElement) return window.__checkerTile;
      const tile = document.createElement('canvas');
      const size = 64; // tile size in px (larger for less dense pattern)
      const half = size / 2;
      tile.width = size;
      tile.height = size;
      const tctx = tile.getContext('2d');
      const light = '#a3a3a3';
      const dark = '#666666';
      // Top-left and bottom-right light
      tctx.fillStyle = light;
      tctx.fillRect(0, 0, half, half);
      tctx.fillRect(half, half, half, half);
      // Top-right and bottom-left dark
      tctx.fillStyle = dark;
      tctx.fillRect(half, 0, half, half);
      tctx.fillRect(0, half, half, half);
      window.__checkerTile = tile;
      return tile;
    }
    function fillCheckerboard(ctx, width, height) {
      const tile = __ensureCheckerTile();
      const pattern = ctx.createPattern(tile, 'repeat');
      ctx.save();
      ctx.fillStyle = pattern;
      ctx.fillRect(0, 0, width, height);
      ctx.restore();
    }

    // Initialize canvases
    for (let i = 0; i < 6; i++) {
      const canvas = document.getElementById(`canvas-${i}`);
      const initSize2 = getTargetCanvasSizeForViewport(currentViewport);
      canvas.width = initSize2.width;
      canvas.height = initSize2.height;
      const ctx = canvas.getContext('2d', { willReadFrequently: true });
      
      // Enable high-quality image smoothing
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      fillCheckerboard(ctx, canvas.width, canvas.height);
      canvases.push(canvas);
      contexts.push(ctx);

      const onionCanvas = document.getElementById(`onion-${i}`);
      onionCanvas.width = initSize2.width;
      onionCanvas.height = initSize2.height;
      const onionCtx = onionCanvas.getContext('2d');
      
      // Enable high-quality image smoothing
      onionCtx.imageSmoothingEnabled = true;
      onionCtx.imageSmoothingQuality = 'high';
      
      onionCanvases.push(onionCanvas);
      onionContexts.push(onionCtx);

      const thumbCanvas = document.getElementById(`thumb-${i}`);
      const thumbCtx = thumbCanvas.getContext('2d');
      fillCheckerboard(thumbCtx, thumbCanvas.width, thumbCanvas.height);
      thumbCanvases.push(thumbCanvas);
      thumbContexts.push(thumbCtx);

      canvas.addEventListener('mousedown', (e) => {
        const frameIndex = canvases.indexOf(e.target);
        if (frameIndex !== currentFrame) {
          // Switch frame instantly
          currentFrame = frameIndex;
          document.querySelectorAll('.canvas-container').forEach((el, i) => {
            el.classList.toggle('active', i === frameIndex);
          });
          document.querySelectorAll('.timeline-frame').forEach((el, i) => {
            el.classList.toggle('active', i === frameIndex);
          });
          document.getElementById('current-frame-info').textContent = frameIndex + 1;
          
          // Continue drawing seamlessly on the new frame
          if (isDrawing) {
            // Update coordinates for the new frame
            const coords = getCanvasCoordinates(canvases[frameIndex], e.clientX, e.clientY);
            lastX = coords.x;
            lastY = coords.y;
            // Draw a dot at the new position to maintain continuity
            const layer = frameLayers[frameIndex][currentLayer];
            const ctx = layer.ctx;
            ctx.globalAlpha = brushOpacity;
            ctx.strokeStyle = currentColor;
            
            if (currentTool === 'pencil') {
              ctx.lineWidth = Math.max(1, brushSize / 2);
              ctx.lineCap = 'round';
              ctx.lineJoin = 'round';
              ctx.beginPath();
              ctx.arc(lastX, lastY, ctx.lineWidth / 2, 0, Math.PI * 2);
              ctx.fill();
            } else if (currentTool === 'brush') {
              drawWithBrushType(ctx, lastX, lastY, lastX, lastY);
            } else if (currentTool === 'eraser') {
              ctx.globalCompositeOperation = 'destination-out';
              ctx.lineWidth = brushSize;
              ctx.lineCap = 'round';
              ctx.lineJoin = 'round';
              ctx.beginPath();
              ctx.arc(lastX, lastY, brushSize / 2, 0, Math.PI * 2);
              ctx.fill();
              ctx.globalCompositeOperation = 'source-over';
            }
            
            ctx.globalAlpha = 1;
          } else {
            startDrawing(e);
          }
        } else {
          startDrawing(e);
        }
      });
      // Don't add individual mousemove listeners - use global handler
      canvas.addEventListener('mouseup', stopDrawing);
      canvas.addEventListener('mouseleave', stopDrawing);
      
      canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        const touch = e.touches[0];
        const mouseEvent = new MouseEvent('mousedown', {
          clientX: touch.clientX,
          clientY: touch.clientY
        });
        canvas.dispatchEvent(mouseEvent);
      });
      
      canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        const touch = e.touches[0];
        const mouseEvent = new MouseEvent('mousemove', {
          clientX: touch.clientX,
          clientY: touch.clientY
        });
        // Dispatch to global handler
        document.dispatchEvent(mouseEvent);
      });
      
      canvas.addEventListener('touchend', (e) => {
        e.preventDefault();
        const mouseEvent = new MouseEvent('mouseup', {});
        canvas.dispatchEvent(mouseEvent);
      });
      
      /* Added wheel event listener for zoom functionality */
      canvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        const frameIndex = canvases.indexOf(e.target);
        handleZoom(e, frameIndex);
      });

      // Enable drag & drop image import on the frame container
      const container = document.getElementById(`frame-container-${i}`);
      if (container) {
        container.addEventListener('dragover', (e) => {
          e.preventDefault();
        });
        container.addEventListener('dragenter', (e) => {
          e.preventDefault();
        });
        container.addEventListener('dragleave', (e) => {
          e.preventDefault();
        });
        container.addEventListener('drop', (e) => {
          e.preventDefault();
          const files = e.dataTransfer && e.dataTransfer.files ? e.dataTransfer.files : null;
          if (files && files.length) {
            handleDroppedFiles(files, i, e.clientX, e.clientY);
          }
        });
      }
    }

    // Preview canvas
    const previewCanvas = document.getElementById('preview-canvas');
    /* Reduced initial preview canvas dimensions to smaller phone size */
    const initPreviewSize = getTargetCanvasSizeForViewport(currentViewport);
    previewCanvas.width = initPreviewSize.width;
    previewCanvas.height = initPreviewSize.height;
    const previewCtx = previewCanvas.getContext('2d');
    previewCtx.fillStyle = '#1a1a1a';
    previewCtx.fillRect(0, 0, previewCanvas.width, previewCanvas.height);
    
    // Set initial preview container aspect ratio
    const previewContainer = document.getElementById('preview-container');
    if (previewContainer) {
      previewContainer.style.setProperty('--canvas-aspect-ratio', '9 / 16');
    }

    // Transparent content overlay canvas so effects target only the drawing
    let previewContentCanvas = null;
    let contentCtx = null;
    function ensurePreviewContentOverlay() {
      const cutoutHost = document.getElementById('cutout-canvas-container');
      const host = (typeof isCutOutMode !== 'undefined' && isCutOutMode && cutoutHost) ? cutoutHost : previewContainer;
      if (!host) return;
      // Desired id and base size depend on mode
      const desiredId = (typeof isCutOutMode !== 'undefined' && isCutOutMode) ? 'cutout-content-canvas' : 'preview-content-canvas';
      let existing = document.getElementById(desiredId);
      if (!existing) {
        existing = document.createElement('canvas');
        existing.id = desiredId;
        existing.style.position = 'absolute';
        existing.style.left = '0';
        existing.style.top = '0';
        existing.style.width = '100%';
        existing.style.height = '100%';
        existing.style.pointerEvents = 'none';
        existing.style.zIndex = '1';
        host.appendChild(existing);
      } else if (existing.parentElement !== host) {
        host.appendChild(existing);
      }
      // Point the shared refs at the active overlay canvas
      previewContentCanvas = existing;
      contentCtx = previewContentCanvas.getContext('2d');
      // Match backing resolution to the active base canvas
      if (typeof isCutOutMode !== 'undefined' && isCutOutMode && typeof cutoutCanvas !== 'undefined' && cutoutCanvas) {
        previewContentCanvas.width = cutoutCanvas.width;
        previewContentCanvas.height = cutoutCanvas.height;
      } else {
        previewContentCanvas.width = previewCanvas.width;
        previewContentCanvas.height = previewCanvas.height;
      }
    }
    ensurePreviewContentOverlay();

    // Miniature realtime preview loop
    (function initMiniPreview() {
      const miniCanvas = document.getElementById('mini-preview-canvas');
      if (!miniCanvas) return;
      const miniCtx = miniCanvas.getContext('2d', { willReadFrequently: true });

      function refreshMini() {
        const miniContainer = document.getElementById('mini-preview');
        const isPhone = currentViewport === 'phone';
        const ar = isPhone ? '9 / 16' : '16 / 9';
        if (miniContainer) miniContainer.style.setProperty('--mini-aspect-ratio', ar);
        // Size: keep the longer side small (96px)
        if (miniContainer) {
          if (isPhone) {
            miniContainer.style.setProperty('--mini-height', '96px');
            miniContainer.style.removeProperty('--mini-width');
          } else {
            miniContainer.style.setProperty('--mini-width', '96px');
            miniContainer.style.removeProperty('--mini-height');
          }
        }
        // Internal resolution: match on-screen size times devicePixelRatio for sharpness
        const applyDprSize = () => {
          const rect = miniCanvas.getBoundingClientRect();
          const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
          const w = Math.max(1, Math.round(rect.width * dpr));
          const h = Math.max(1, Math.round(rect.height * dpr));
          if (miniCanvas.width !== w || miniCanvas.height !== h) {
            miniCanvas.width = w;
            miniCanvas.height = h;
          }
        };
        // Wait a frame to ensure CSS size applied, then set internal size
        requestAnimationFrame(applyDprSize);
      }
      refreshMini();
      // Expose for viewport changes
      window.refreshMiniPreviewSizing = refreshMini;

      let miniIndex = 0;
      let tickAccumulator = 0;
      let lastTs = 0;

      function drawMiniFrame(index) {
        // High quality sampling
        miniCtx.imageSmoothingEnabled = true;
        miniCtx.imageSmoothingQuality = 'high';
        // Background
        miniCtx.clearRect(0, 0, miniCanvas.width, miniCanvas.height);
        miniCtx.fillStyle = '#1a1a1a';
        miniCtx.fillRect(0, 0, miniCanvas.width, miniCanvas.height);

        // Prefer drawing from pre-composed canvas for highest quality
        if (Array.isArray(canvases)) {
          const src = canvases[Math.max(0, Math.min(canvases.length - 1, index|0))];
          if (src) {
            miniCtx.drawImage(src, 0, 0, miniCanvas.width, miniCanvas.height);
            return;
          }
        }
        // Fallback: dynamically compose layers for this virtual index
        const layers = typeof getLayersArrayForIndex === 'function' ? getLayersArrayForIndex(index) : [];
        const baseCanvas = canvases[index];
        const sx = baseCanvas ? (miniCanvas.width / baseCanvas.width) : 1;
        const sy = baseCanvas ? (miniCanvas.height / baseCanvas.height) : 1;
        layers.forEach(layer => {
          if (!layer || !layer.visible) return;
          miniCtx.save();
          miniCtx.globalAlpha = layer.opacity;
          miniCtx.drawImage(layer.canvas, 0, 0, miniCanvas.width, miniCanvas.height);
          if (Array.isArray(layer.images)) {
            for (const obj of layer.images) {
              drawRotatedImage(miniCtx, obj, sx, sy);
            }
          }
          miniCtx.restore();
        });
      }

      function step(ts) {
        if (!lastTs) lastTs = ts;
        const dt = ts - lastTs;
        lastTs = ts;
        drawMiniFrame(miniIndex);

        // Advance timeline using global fps and per-frame durations
        const ticks = (typeof fps === 'number' && fps > 0 ? fps : 12) * (dt / 1000);
        tickAccumulator += ticks;
        let frameDur = typeof getDurationForIndex === 'function' ? getDurationForIndex(miniIndex) : 1;
        while (tickAccumulator >= frameDur) {
          tickAccumulator -= frameDur;
          const total = typeof getActiveClipTotalFrames === 'function' ? getActiveClipTotalFrames() : 6;
          miniIndex = (miniIndex + 1) % total;
          frameDur = typeof getDurationForIndex === 'function' ? getDurationForIndex(miniIndex) : 1;
        }
        requestAnimationFrame(step);
      }
      requestAnimationFrame(step);
    })();

    // Hover interactions to reveal mini preview when hovering scroll button
    (function initMiniPreviewHover() {
      const scrollBtn = document.querySelector('.scroll-to-timeline-btn');
      const miniContainer = document.getElementById('mini-preview');
      if (!scrollBtn || !miniContainer) return;
      let hideTimer = null;
      const showMini = () => {
        // Disable mini preview while in Cut Out mode
        if (typeof isCutOutMode !== 'undefined' && isCutOutMode) return;
        if (hideTimer) { clearTimeout(hideTimer); hideTimer = null; }
        miniContainer.classList.add('show');
        if (typeof refreshMiniPreviewSizing === 'function') refreshMiniPreviewSizing();
      };
      const hideMini = () => {
        hideTimer = setTimeout(() => {
          miniContainer.classList.remove('show');
        }, 60);
      };
      scrollBtn.addEventListener('mouseenter', showMini);
      scrollBtn.addEventListener('mouseleave', hideMini);
      // Keep visible if user moves from button to the mini preview
      miniContainer.addEventListener('mouseenter', showMini);
      miniContainer.addEventListener('mouseleave', hideMini);
    })();

    // Magic Effects: Heat Haze (displacement) setup
    const effectSettings = {
      cameraShake: { amplitude: 2.0, rotation: 0.4, speed: 1.0 },
      heatHaze: { scale: 20, speed: 1.6, baseX: 0.02, baseY: 0.03 },
      glowPulse: { intensity: 1.0, speed: 1.0 },
      flicker: { minOpacity: 0.7, maxOpacity: 1.0, pulseChance: 0.06, speed: 1.0 },
      scanlines: { opacity: 0.35, speed: 1.0, pitch: 3 },
      vignette: { inner: 0.5, strength: 0.55 },
      colorGrade: { type: '', sharpen: 'medium' },
      // Cut Out friendly overlays
      snow: { density: 0.9, size: 2.0, speed: 1.6, wind: 0.0 },
      rain: { density: 0.7, length: 14, speed: 1.3, angle: 15, opacity: 0.6 },
      grain: { intensity: 0.18, speed: 1.0, chroma: false },
      oldFilm: { dust: 0.9, scratches: 0.7, jitter: 0.6, sepia: 0.2, vignette: 0.45 },
      analogHorror: { intensity: 0.5, dashDensity: 0.35, glitchRate: 0.08, speed: 1.0 }
    };
    let heatHazeEnabled = false;
    let heatHazeSvg = null;
    let heatHazeNoise = null;
    let heatHazeDisp = null;
    let heatHazeAnimId = null;

    function ensureHeatHazeFilter() {
      if (heatHazeSvg) return;
      const svgNS = 'http://www.w3.org/2000/svg';
      const svg = document.createElementNS(svgNS, 'svg');
      svg.setAttribute('aria-hidden', 'true');
      svg.style.position = 'absolute';
      svg.style.width = '0';
      svg.style.height = '0';
      svg.style.overflow = 'hidden';
      const defs = document.createElementNS(svgNS, 'defs');
      const filter = document.createElementNS(svgNS, 'filter');
      filter.setAttribute('id', 'heatHazeFilter');
      filter.setAttribute('x', '-20%');
      filter.setAttribute('y', '-20%');
      filter.setAttribute('width', '140%');
      filter.setAttribute('height', '140%');
      const turbulence = document.createElementNS(svgNS, 'feTurbulence');
      turbulence.setAttribute('id', 'heatHazeNoise');
      turbulence.setAttribute('type', 'fractalNoise');
      turbulence.setAttribute('baseFrequency', '0.01 0.02');
      turbulence.setAttribute('numOctaves', '2');
      turbulence.setAttribute('seed', '2');
      turbulence.setAttribute('stitchTiles', 'stitch');
      const disp = document.createElementNS(svgNS, 'feDisplacementMap');
      disp.setAttribute('in', 'SourceGraphic');
      disp.setAttribute('in2', 'heatHazeNoise');
      disp.setAttribute('scale', '12');
      disp.setAttribute('xChannelSelector', 'R');
      disp.setAttribute('yChannelSelector', 'G');
      filter.appendChild(turbulence);
      filter.appendChild(disp);
      defs.appendChild(filter);
      svg.appendChild(defs);
      document.body.appendChild(svg);
      heatHazeSvg = svg;
      heatHazeNoise = turbulence;
      heatHazeDisp = disp;
    }

    // Color grade filter defs (sharpen)
    let colorGradeSvg = null;
    function ensureColorGradeFilters() {
      if (colorGradeSvg) return;
      const svgNS = 'http://www.w3.org/2000/svg';
      const svg = document.createElementNS(svgNS, 'svg');
      svg.setAttribute('aria-hidden', 'true');
      svg.style.position = 'absolute';
      svg.style.width = '0';
      svg.style.height = '0';
      svg.style.overflow = 'hidden';

      const defs = document.createElementNS(svgNS, 'defs');

      const mkSharpen = (id, centerWeight) => {
        const filter = document.createElementNS(svgNS, 'filter');
        filter.setAttribute('id', id);
        const cm = document.createElementNS(svgNS, 'feConvolveMatrix');
        cm.setAttribute('order', '3');
        cm.setAttribute('kernelMatrix', `0 -1 0 -1 ${centerWeight} -1 0 -1 0`);
        cm.setAttribute('preserveAlpha', 'true');
        filter.appendChild(cm);
        defs.appendChild(filter);
      };
      mkSharpen('sharpenLight', 5);
      mkSharpen('sharpenMedium', 6);
      mkSharpen('sharpenStrong', 7);

      svg.appendChild(defs);
      document.body.appendChild(svg);
      colorGradeSvg = svg;
    }

    function animateHeatHaze() {
      if (!heatHazeEnabled) {
        heatHazeAnimId = null;
        return;
      }
      const t = performance.now() * effectSettings.heatHaze.speed;
      // Subtle wobble in noise and scale for heat-like shimmer
      const bfX = effectSettings.heatHaze.baseX + Math.sin(t * 0.0013) * 0.004;
      const bfY = effectSettings.heatHaze.baseY + Math.cos(t * 0.0011) * 0.005;
      const scale = effectSettings.heatHaze.scale + Math.sin(t * 0.0017) * 2;
      if (heatHazeNoise) heatHazeNoise.setAttribute('baseFrequency', `${bfX.toFixed(4)} ${bfY.toFixed(4)}`);
      if (heatHazeDisp) heatHazeDisp.setAttribute('scale', scale.toFixed(1));
      heatHazeAnimId = requestAnimationFrame(animateHeatHaze);
    }

    function enableHeatHazeEffect() {
      ensureHeatHazeFilter();
      heatHazeEnabled = true;
      // Apply to content overlay only
      ensurePreviewContentOverlay();
      applyCombinedContentFilters();
      if (!heatHazeAnimId) heatHazeAnimId = requestAnimationFrame(animateHeatHaze);
    }

    // Shared overlay and CSS for other effects
    let effectsOverlayDiv = null;
    let effectsCSSInjected = false;

    function ensureEffectsCSS() {
      if (effectsCSSInjected) return;
      const style = document.createElement('style');
      style.textContent = `
        @keyframes scanlinesMove {
          0% { background-position: 0 0; }
          100% { background-position: 0 2px; }
        }
        #scanlines-overlay { 
          position: absolute; inset: 0; pointer-events: none; opacity: 0.35; 
          background: repeating-linear-gradient(
            to bottom,
            rgba(255,255,255,0.12) 0px,
            rgba(255,255,255,0.12) 1px,
            rgba(0,0,0,0.0) 3px
          );
          mix-blend-mode: multiply;
          animation: scanlinesMove 0.35s linear infinite;
        }
        #vignette-overlay {
          position: absolute; inset: 0; pointer-events: none; 
          background: radial-gradient(circle at 50% 50%, rgba(0,0,0,0.0) 50%, rgba(0,0,0,0.55) 100%);
        }
      `;
      document.head.appendChild(style);
      effectsCSSInjected = true;
    }

    function ensureEffectsOverlayDiv() {
      const cutoutHost = document.getElementById('cutout-canvas-container');
      const host = (typeof isCutOutMode !== 'undefined' && isCutOutMode && cutoutHost) ? cutoutHost : previewContainer;
      if (!host) return;
      const desiredId = (typeof isCutOutMode !== 'undefined' && isCutOutMode) ? 'cutout-effects-overlay' : 'preview-effects-overlay';
      let overlay = document.getElementById(desiredId);
      if (!overlay) {
        overlay = document.createElement('div');
        overlay.id = desiredId;
        overlay.style.position = 'absolute';
        overlay.style.left = '0';
        overlay.style.top = '0';
        overlay.style.right = '0';
        overlay.style.bottom = '0';
        overlay.style.pointerEvents = 'none';
        overlay.style.zIndex = '2';
        host.appendChild(overlay);
      } else if (overlay.parentElement !== host) {
        host.appendChild(overlay);
      }
      effectsOverlayDiv = overlay;
    }

    function ensureColorGradeOverlay() {
      ensureEffectsOverlayDiv();
      let overlay = document.getElementById('color-grade-overlay');
      if (!overlay) {
        overlay = document.createElement('div');
        overlay.id = 'color-grade-overlay';
        overlay.style.position = 'absolute';
        overlay.style.left = '0';
        overlay.style.top = '0';
        overlay.style.right = '0';
        overlay.style.bottom = '0';
        overlay.style.pointerEvents = 'none';
        overlay.style.zIndex = '0';
        effectsOverlayDiv.appendChild(overlay);
      }
      return overlay;
    }

    // Camera Shake (applies transform to the content overlay)
    let cameraShakeEnabled = false;
    let cameraShakeAnimId = null;
    let cameraShakeTime = 0;
    function enableCameraShakeEffect() {
      ensurePreviewContentOverlay();
      cameraShakeEnabled = true;
      if (!cameraShakeAnimId) cameraShakeAnimId = requestAnimationFrame(animateCameraShake);
    }
    function animateCameraShake() {
      if (!cameraShakeEnabled) { cameraShakeAnimId = null; return; }
      cameraShakeTime += 0.016 * effectSettings.cameraShake.speed;
      const amp = effectSettings.cameraShake.amplitude;
      const rotAmp = effectSettings.cameraShake.rotation;
      const dx = Math.sin(cameraShakeTime * 17.1) * amp + Math.cos(cameraShakeTime * 11.3) * (amp * 0.5);
      const dy = Math.cos(cameraShakeTime * 13.7) * amp + Math.sin(cameraShakeTime * 19.9) * (amp * 0.5);
      const rot = Math.sin(cameraShakeTime * 7.3) * rotAmp;
      previewContentCanvas.style.transformOrigin = '50% 50%';
      previewContentCanvas.style.transform = `translate(${dx.toFixed(2)}px, ${dy.toFixed(2)}px) rotate(${rot.toFixed(2)}deg)`;
      cameraShakeAnimId = requestAnimationFrame(animateCameraShake);
    }

    // Flicker (applies opacity changes to the content overlay)
    let flickerEnabled = false;
    let flickerAnimId = null;
    let flickerTime = 0;
    function enableFlickerEffect() {
      ensurePreviewContentOverlay();
      flickerEnabled = true;
      if (!flickerAnimId) flickerAnimId = requestAnimationFrame(animateFlicker);
    }
    function animateFlicker() {
      if (!flickerEnabled) { flickerAnimId = null; return; }
      flickerTime += 0.016 * effectSettings.flicker.speed;
      const minO = effectSettings.flicker.minOpacity;
      const maxO = effectSettings.flicker.maxOpacity;
      const base = 0.92 + Math.sin(flickerTime * 31.0) * 0.04 + Math.cos(flickerTime * 17.0) * 0.03;
      const pulse = (Math.random() < effectSettings.flicker.pulseChance) ? (0.75 + Math.random() * 0.15) : 1.0;
      const op = Math.min(maxO, Math.max(minO, base * pulse));
      previewContentCanvas.style.opacity = op.toFixed(2);
      flickerAnimId = requestAnimationFrame(animateFlicker);
    }

    function getGlowFilterPart() {
      if (!glowPulseEnabled) return '';
      const k = effectSettings.glowPulse.intensity;
      const amp = (8 + Math.sin(glowPulseT * 1.4) * 6) * k;
      const a1 = 0.55 + (Math.sin(glowPulseT) * 0.25) * k;
      const a2 = 0.25 + (Math.cos(glowPulseT * 0.8) * 0.2) * k;
      return `drop-shadow(0 0 ${amp.toFixed(1)}px rgba(59,130,246,${a1.toFixed(2)})) drop-shadow(0 0 ${(amp*1.6).toFixed(1)}px rgba(14,165,233,${a2.toFixed(2)}))`;
    }

    // Hover preview state
    let filterPreviewPart = '';
    let previewSavedTransform = '';
    let hoverOverlayDiv = null;
    function ensureHoverOverlay() {
      if (!previewContainer) return null;
      if (hoverOverlayDiv) return hoverOverlayDiv;
      const div = document.createElement('div');
      div.id = 'hover-preview-overlay';
      div.style.position = 'absolute';
      div.style.left = '0';
      div.style.top = '0';
      div.style.right = '0';
      div.style.bottom = '0';
      div.style.pointerEvents = 'none';
      previewContainer.appendChild(div);
      hoverOverlayDiv = div;
      return hoverOverlayDiv;
    }

    function applyCombinedContentFilters() {
      if (!previewContentCanvas) return;
      const parts = [];
      if (heatHazeEnabled) parts.push('url(#heatHazeFilter)');
      if (effectSettings.colorGrade && effectSettings.colorGrade.type) {
        ensureColorGradeFilters();
        const sharpId = effectSettings.colorGrade.sharpen === 'strong' ? 'sharpenStrong' : effectSettings.colorGrade.sharpen === 'light' ? 'sharpenLight' : 'sharpenMedium';
        parts.push(`url(#${sharpId})`);
      }
      const colorPart = (function getColorGradeFilterPart() {
        const id = effectSettings.colorGrade && effectSettings.colorGrade.type ? effectSettings.colorGrade.type : '';
        switch (id) {
          case 'color-cinematic':
            return 'sepia(0.25) saturate(1.35) hue-rotate(325deg) contrast(1.12) brightness(1.03)';
          case 'color-sepia':
            return 'sepia(0.85) contrast(1.08) saturate(0.85) brightness(1.02)';
          case 'color-noir':
            return 'grayscale(1) contrast(1.28) brightness(0.88)';
          case 'color-vibrant':
            return 'saturate(1.5) contrast(1.12)';
          case 'color-vintage':
            return 'sepia(0.35) saturate(0.85) contrast(0.92) brightness(1.04)';
          default:
            return '';
        }
      })();
      if (colorPart) parts.push(colorPart);
      const glowPart = getGlowFilterPart();
      if (glowPart) parts.push(glowPart);
      if (filterPreviewPart) parts.push(filterPreviewPart);
      previewContentCanvas.style.filter = parts.join(' ');
    }

    function setEffectHoverPreview(id, t) {
      // t in [0,1]
      const clamped = Math.max(0, Math.min(1, isNaN(t) ? 0.5 : t));
      // Clear defaults
      filterPreviewPart = '';
      if (hoverOverlayDiv) { hoverOverlayDiv.style.background = ''; hoverOverlayDiv.style.mixBlendMode = ''; hoverOverlayDiv.style.opacity = ''; }
      if (previewContentCanvas && typeof previewSavedTransform === 'string' && !previewContentCanvas.style.transform) {
        previewSavedTransform = previewContentCanvas.style.transform || '';
      }
      // Dispatch by effect id
      if (id === 'heatHaze') {
        ensureHeatHazeFilter();
        // Animate noise/scale per cursor
        const baseX = 0.005 + clamped * 0.02;
        const baseY = 0.008 + clamped * 0.02;
        const scale = 4 + clamped * 20;
        if (typeof heatHazeNoise !== 'undefined' && heatHazeNoise) heatHazeNoise.setAttribute('baseFrequency', `${baseX.toFixed(3)} ${baseY.toFixed(3)}`);
        if (typeof heatHazeDisp !== 'undefined' && heatHazeDisp) heatHazeDisp.setAttribute('scale', scale.toFixed(1));
        filterPreviewPart = 'url(#heatHazeFilter)';
      } else if (id === 'glowPulse') {
        const k = effectSettings.glowPulse.intensity;
        const phi = clamped * Math.PI * 2;
        const amp = (8 + (Math.sin(phi * 1.4) * 6)) * k;
        const a1 = 0.55 + (Math.sin(phi) * 0.25) * k;
        const a2 = 0.25 + (Math.cos(phi * 0.8) * 0.2) * k;
        filterPreviewPart = `drop-shadow(0 0 ${amp.toFixed(1)}px rgba(59,130,246,${a1.toFixed(2)})) drop-shadow(0 0 ${(amp*1.6).toFixed(1)}px rgba(14,165,233,${a2.toFixed(2)}))`;
      } else if (id === 'scanlines') {
        const hov = ensureHoverOverlay();
        if (hov) {
          const pitch = 2 + Math.round(clamped * 6);
          const opacity = 0.15 + clamped * 0.4;
          hov.style.background = `repeating-linear-gradient(to bottom, rgba(255,255,255,0.12) 0px, rgba(255,255,255,0.12) 1px, rgba(0,0,0,0.0) ${pitch}px)`;
          hov.style.mixBlendMode = 'multiply';
          hov.style.opacity = String(opacity);
        }
      } else if (id === 'vignette') {
        const hov = ensureHoverOverlay();
        if (hov) {
          const inner = 0.3 + clamped * 0.5; // 0.3..0.8
          const strength = 0.2 + clamped * 0.7; // 0.2..0.9
          hov.style.background = `radial-gradient(circle at 50% 50%, rgba(0,0,0,0.0) ${Math.round(inner*100)}%, rgba(0,0,0,${strength.toFixed(2)}) 100%)`;
        }
      } else if (id === 'cameraShake') {
        if (previewContentCanvas) {
          const amp = 1 + clamped * 4;
          const dx = (clamped * 2 - 1) * amp;
          const dy = (1 - clamped * 2) * amp;
          const rot = (clamped - 0.5) * 1.2;
          previewContentCanvas.style.transform = `translate(${dx.toFixed(1)}px, ${dy.toFixed(1)}px) rotate(${rot.toFixed(2)}deg)`;
        }
      } else if (id === 'flicker') {
        const hov = ensureHoverOverlay();
        if (hov) {
          const dim = 0.05 + clamped * 0.25;
          hov.style.background = `rgba(0,0,0,${dim.toFixed(2)})`;
        }
      } else if (id && id.startsWith('color-')) {
        ensureColorGradeFilters();
        const sharpId = 'sharpenMedium';
        const colorPart = (function() {
          switch (id) {
            case 'color-cinematic': return 'sepia(0.25) saturate(1.35) hue-rotate(325deg) contrast(1.12) brightness(1.03)';
            case 'color-sepia': return 'sepia(0.85) contrast(1.08) saturate(0.85) brightness(1.02)';
            case 'color-noir': return 'grayscale(1) contrast(1.28) brightness(0.88)';
            case 'color-vibrant': return 'saturate(1.5) contrast(1.12)';
            case 'color-vintage': return 'sepia(0.35) saturate(0.85) contrast(0.92) brightness(1.04)';
            default: return '';
          }
        })();
        filterPreviewPart = `url(#${sharpId}) ${colorPart}`.trim();
        const hov = ensureHoverOverlay();
        if (hov) {
          hov.style.mixBlendMode = 'multiply';
          if (id === 'color-cinematic') hov.style.background = 'radial-gradient(120% 180% at 50% 120%, rgba(0,0,0,0.35) 0%, rgba(0,0,0,0) 60%), linear-gradient(0deg, rgba(18,14,8,0.25), rgba(18,14,8,0.25))';
          if (id === 'color-sepia') hov.style.background = 'radial-gradient(120% 180% at 50% 120%, rgba(47,35,22,0.25) 0%, rgba(0,0,0,0) 60%)';
          if (id === 'color-noir') hov.style.background = 'radial-gradient(120% 180% at 50% 120%, rgba(0,0,0,0.45) 0%, rgba(0,0,0,0) 60%)';
          if (id === 'color-vibrant') hov.style.background = 'radial-gradient(120% 180% at 50% 120%, rgba(0,0,0,0.28) 0%, rgba(0,0,0,0) 60%)';
          if (id === 'color-vintage') hov.style.background = 'radial-gradient(120% 180% at 50% 120%, rgba(34,20,10,0.28) 0%, rgba(0,0,0,0) 60%)';
        }
      }
      applyCombinedContentFilters();
    }

    let glowPulseEnabled = false;
    let glowPulseAnimId = null;
    let glowPulseT = 0;
    function enableGlowPulseEffect() {
      ensureEffectsCSS();
      ensurePreviewContentOverlay();
      glowPulseEnabled = true;
      if (!glowPulseAnimId) glowPulseAnimId = requestAnimationFrame(animateGlowPulse);
      applyCombinedContentFilters();
    }

    function animateGlowPulse() {
      if (!glowPulseEnabled) { glowPulseAnimId = null; return; }
      glowPulseT = (glowPulseT + 0.016 * effectSettings.glowPulse.speed) % (Math.PI * 2);
      applyCombinedContentFilters();
      glowPulseAnimId = requestAnimationFrame(animateGlowPulse);
    }

    function enableColorGradeEffect(id) {
      ensurePreviewContentOverlay();
      ensureColorGradeFilters();
      if (!effectSettings.colorGrade) effectSettings.colorGrade = { type: '', sharpen: 'medium' };
      effectSettings.colorGrade.type = id;
      // Configure sharpen level and overlay for each look
      const overlay = ensureColorGradeOverlay();
      overlay.style.mixBlendMode = 'multiply';
      overlay.style.opacity = '1';
      switch (id) {
        case 'color-cinematic':
          effectSettings.colorGrade.sharpen = 'strong';
          overlay.style.background = 'radial-gradient(120% 180% at 50% 120%, rgba(0,0,0,0.35) 0%, rgba(0,0,0,0) 60%),\
                                     linear-gradient(0deg, rgba(18,14,8,0.25), rgba(18,14,8,0.25))';
          break;
        case 'color-sepia':
          effectSettings.colorGrade.sharpen = 'light';
          overlay.style.background = 'radial-gradient(120% 180% at 50% 120%, rgba(47,35,22,0.25) 0%, rgba(0,0,0,0) 60%)';
          break;
        case 'color-noir':
          effectSettings.colorGrade.sharpen = 'strong';
          overlay.style.background = 'radial-gradient(120% 180% at 50% 120%, rgba(0,0,0,0.45) 0%, rgba(0,0,0,0) 60%)';
          break;
        case 'color-vibrant':
          effectSettings.colorGrade.sharpen = 'medium';
          overlay.style.background = 'radial-gradient(120% 180% at 50% 120%, rgba(0,0,0,0.28) 0%, rgba(0,0,0,0) 60%)';
          break;
        case 'color-vintage':
          effectSettings.colorGrade.sharpen = 'light';
          overlay.style.background = 'radial-gradient(120% 180% at 50% 120%, rgba(34,20,10,0.28) 0%, rgba(0,0,0,0) 60%)';
          break;
      }
      applyCombinedContentFilters();
    }

    // --- Cut Out friendly overlays: Snow, Rain, and Old TV bundle ---
    // Grain overlay (animated noise)
    let grainEnabled = false;
    let grainAnimId = null;
    let grainCanvas = null;
    let grainCtx = null;
    function ensureGrainOverlay() {
      ensureEffectsOverlayDiv();
      ensurePreviewContentOverlay();
      if (!effectsOverlayDiv) return;
      if (!grainCanvas) {
        grainCanvas = document.createElement('canvas');
        grainCanvas.id = 'grain-overlay';
        grainCanvas.style.position = 'absolute';
        grainCanvas.style.left = '0';
        grainCanvas.style.top = '0';
        grainCanvas.style.width = '100%';
        grainCanvas.style.height = '100%';
        grainCanvas.style.pointerEvents = 'none';
        // Blend to sit as film grain
        grainCanvas.style.mixBlendMode = 'overlay';
        effectsOverlayDiv.appendChild(grainCanvas);
      }
      if (previewContentCanvas && grainCanvas) {
        grainCanvas.width = previewContentCanvas.width;
        grainCanvas.height = previewContentCanvas.height;
      }
      grainCtx = grainCanvas.getContext('2d');
    }
    function drawGrainFrame() {
      if (!grainEnabled || !grainCtx || !grainCanvas) { grainAnimId = null; return; }
      const intensity = Math.max(0, Math.min(1, effectSettings.grain.intensity));
      // Render low-res noise tile and scale for performance
      const tileSize = 144;
      const off = document.createElement('canvas');
      off.width = tileSize;
      off.height = tileSize;
      const octx = off.getContext('2d', { willReadFrequently: true });
      const imgData = octx.createImageData(tileSize, tileSize);
      const data = imgData.data;
      const chroma = !!effectSettings.grain.chroma;
      for (let i = 0; i < tileSize * tileSize; i++) {
        const base = Math.random(); // 0..1
        // Alternate heavier/light frames slightly by toggling range
        const alt = (Math.random() < 0.5) ? base : (base * 0.7 + 0.3);
        const v = Math.floor(alt * 255);
        const a = Math.floor(intensity * (90 + Math.random() * 60)); // 90..150
        const di = i * 4;
        if (chroma) {
          // subtle channel variance
          data[di] = Math.min(255, v + (Math.random() * 24 - 12));
          data[di + 1] = Math.min(255, v + (Math.random() * 24 - 12));
          data[di + 2] = Math.min(255, v + (Math.random() * 24 - 12));
        } else {
          data[di] = v;
          data[di + 1] = v;
          data[di + 2] = v;
        }
        data[di + 3] = a;
      }
      octx.putImageData(imgData, 0, 0);
      grainCtx.clearRect(0, 0, grainCanvas.width, grainCanvas.height);
      // Slight offset per frame to avoid static pattern
      const shiftX = (Math.random() * tileSize) | 0;
      const shiftY = (Math.random() * tileSize) | 0;
      // Draw tiled to fill
      const cols = Math.ceil(grainCanvas.width / tileSize) + 1;
      const rows = Math.ceil(grainCanvas.height / tileSize) + 1;
      for (let y = -1; y < rows; y++) {
        for (let x = -1; x < cols; x++) {
          grainCtx.drawImage(off, x * tileSize + shiftX, y * tileSize + shiftY);
        }
      }
      grainAnimId = requestAnimationFrame(drawGrainFrame);
    }
    function enableGrainEffect() {
      ensureGrainOverlay();
      grainEnabled = true;
      if (!grainAnimId) grainAnimId = requestAnimationFrame(drawGrainFrame);
    }
    function disableGrainEffect() {
      grainEnabled = false;
      if (grainAnimId) { cancelAnimationFrame(grainAnimId); grainAnimId = null; }
      if (grainCanvas && grainCtx) grainCtx.clearRect(0, 0, grainCanvas.width, grainCanvas.height);
    }
    function updateGrainOverlay() {
      if (!grainEnabled) return;
      ensureGrainOverlay();
    }
    
    // Old Film overlay (scratches, dust, jitter, sepia/vignette)
    let oldFilmEnabled = false;
    let oldFilmAnimId = null;
    let filmCanvas = null;
    let filmCtx = null;
    let filmTime = 0;
    function ensureFilmOverlay() {
      ensureEffectsOverlayDiv();
      ensurePreviewContentOverlay();
      if (!effectsOverlayDiv) return;
      if (!filmCanvas) {
        filmCanvas = document.createElement('canvas');
        filmCanvas.id = 'film-overlay';
        filmCanvas.style.position = 'absolute';
        filmCanvas.style.left = '0';
        filmCanvas.style.top = '0';
        filmCanvas.style.width = '100%';
        filmCanvas.style.height = '100%';
        filmCanvas.style.pointerEvents = 'none';
        filmCanvas.style.zIndex = '2';
        // Blend scratches and dust additively but not too harsh
        filmCanvas.style.mixBlendMode = 'screen';
        effectsOverlayDiv.appendChild(filmCanvas);
      }
      if (previewContentCanvas && filmCanvas) {
        filmCanvas.width = previewContentCanvas.width;
        filmCanvas.height = previewContentCanvas.height;
      }
      filmCtx = filmCanvas.getContext('2d');
    }
    function drawFilmFrame() {
      if (!oldFilmEnabled || !filmCtx || !filmCanvas) { oldFilmAnimId = null; return; }
      // Slow down overall motion
      filmTime += 0.006;
      const { dust, scratches, jitter } = effectSettings.oldFilm;
      // Clear fully to keep background transparent (no black wash)
      filmCtx.clearRect(0, 0, filmCanvas.width, filmCanvas.height);
      // Dust specks
      const dustCount = Math.round((filmCanvas.width * filmCanvas.height) / 140000 * Math.max(0, dust));
      for (let i = 0; i < dustCount; i++) {
        const x = Math.random() * filmCanvas.width;
        let y = Math.random() * filmCanvas.height;
        // slight downward drift
        y = (y + filmTime * (8 + Math.random() * 16)) % filmCanvas.height;
        const r = 0.5 + Math.random() * 2.0;
        const shade = 180 + Math.floor(Math.random() * 70); // warm off-white
        const a = 0.25 + Math.random() * 0.3;
        filmCtx.fillStyle = `rgba(${shade},${shade-10},${shade-20},${a.toFixed(2)})`;
        filmCtx.beginPath();
        filmCtx.arc(x, y, r, 0, Math.PI * 2);
        filmCtx.fill();
      }
      // Vertical scratches (thin lines)
      const scratchCount = Math.round((filmCanvas.width / 420) * Math.max(0, scratches)); // fewer lines
      filmCtx.strokeStyle = 'rgba(220,220,220,0.28)';
      filmCtx.lineWidth = 0.5;
      for (let i = 0; i < scratchCount; i++) {
        const x = Math.random() * filmCanvas.width;
        const y1 = 0;
        const y2 = filmCanvas.height;
        // small waviness
        filmCtx.beginPath();
        filmCtx.moveTo(x, y1);
        const segments = 6;
        for (let s = 1; s <= segments; s++) {
          const yy = (y2 / segments) * s;
          const xx = x + Math.sin((filmTime * 5) + s * 0.7 + Math.random()) * 0.9;
          filmCtx.lineTo(xx, yy);
        }
        filmCtx.stroke();
      }
      // Occasional blotch or hair (elliptical smudge)
      if (Math.random() < 0.02 * Math.max(0, dust)) {
        const cx = Math.random() * filmCanvas.width;
        const cy = Math.random() * filmCanvas.height;
        const rx = 6 + Math.random() * 16;
        const ry = 3 + Math.random() * 10;
        const g = filmCtx.createRadialGradient(cx, cy, 0, cx, cy, Math.max(rx, ry) * 1.1);
        g.addColorStop(0, 'rgba(240,230,200,0.28)');
        g.addColorStop(1, 'rgba(240,230,200,0.0)');
        filmCtx.fillStyle = g;
        filmCtx.beginPath();
        filmCtx.ellipse(cx, cy, rx, ry, Math.random() * Math.PI, 0, Math.PI * 2);
        filmCtx.fill();
      }
      // Gate weave jitter (subtle translate/rotate)
      if (previewContentCanvas) {
        const j = Math.max(0, Math.min(1.0, jitter));
        const dx = (Math.sin(filmTime * 1.0) * 0.5 + (Math.random() - 0.5) * 0.3) * (0.6 + j * 0.6);
        const dy = (Math.cos(filmTime * 0.8) * 0.5 + (Math.random() - 0.5) * 0.3) * (0.6 + j * 0.6);
        const rot = (Math.sin(filmTime * 0.5) * 0.25 + (Math.random() - 0.5) * 0.12) * j;
        previewContentCanvas.style.transformOrigin = '50% 50%';
        // Preserve any existing transform (e.g., from other effects) by appending
        const base = previewContentCanvas.style.transform || '';
        const extra = ` translate(${dx.toFixed(2)}px, ${dy.toFixed(2)}px) rotate(${rot.toFixed(2)}deg)`;
        if (!base.includes('translate') && !base.includes('rotate')) {
          previewContentCanvas.style.transform = base + extra;
        } else {
          previewContentCanvas.style.transform = base + extra;
        }
      }
      oldFilmAnimId = requestAnimationFrame(drawFilmFrame);
    }
    function enableOldFilmEffect() {
      ensureFilmOverlay();
      enableGrainEffect();
      enableVignetteEffect();
      enableColorGradeEffect('color-sepia');
      // Map vignette strength from setting
      effectSettings.vignette.strength = Math.max(0, Math.min(0.9, effectSettings.oldFilm.vignette));
      updateVignetteOverlayStyles();
      oldFilmEnabled = true;
      if (!oldFilmAnimId) oldFilmAnimId = requestAnimationFrame(drawFilmFrame);
    }
    function disableOldFilmEffect() {
      oldFilmEnabled = false;
      if (oldFilmAnimId) { cancelAnimationFrame(oldFilmAnimId); oldFilmAnimId = null; }
      if (filmCanvas && filmCtx) filmCtx.clearRect(0, 0, filmCanvas.width, filmCanvas.height);
      // Do not force-remove vignette or color grade; they may be used by other effects.
    }
    function updateOldFilmOverlay() {
      if (!oldFilmEnabled) return;
      ensureFilmOverlay();
      // Update vignette strength live
      effectSettings.vignette.strength = Math.max(0, Math.min(0.9, effectSettings.oldFilm.vignette));
      updateVignetteOverlayStyles();
    }
    
    // Analog Horror overlay (static noise, white dashes, glitch bands)
    let analogHorrorEnabled = false;
    let analogAnimId = null;
    let analogCanvas = null;
    let analogCtx = null;
    let analogT = 0;
    let analogUpdateAcc = 0;
    function ensureAnalogOverlay() {
      ensureEffectsOverlayDiv();
      ensurePreviewContentOverlay();
      if (!effectsOverlayDiv) return;
      if (!analogCanvas) {
        analogCanvas = document.createElement('canvas');
        analogCanvas.id = 'analog-overlay';
        analogCanvas.style.position = 'absolute';
        analogCanvas.style.left = '0';
        analogCanvas.style.top = '0';
        analogCanvas.style.width = '100%';
        analogCanvas.style.height = '100%';
        analogCanvas.style.pointerEvents = 'none';
        // Keep luminous only; no black background
        analogCanvas.style.mixBlendMode = 'screen';
        effectsOverlayDiv.appendChild(analogCanvas);
      }
      if (previewContentCanvas && analogCanvas) {
        analogCanvas.width = previewContentCanvas.width;
        analogCanvas.height = previewContentCanvas.height;
      }
      analogCtx = analogCanvas.getContext('2d', { willReadFrequently: true });
    }
    function drawAnalogFrame() {
      if (!analogHorrorEnabled || !analogCtx || !analogCanvas) { analogAnimId = null; return; }
      const { intensity, dashDensity, glitchRate, speed } = effectSettings.analogHorror;
      const k = Math.max(0.05, Math.min(1, intensity));
      const sp = Math.max(0.2, speed);
      analogT += 0.016 * sp;
      analogUpdateAcc += 0.016 * sp;
      // Update visuals only every ~90ms (slower motion)
      if (analogUpdateAcc < 0.09) {
        analogAnimId = requestAnimationFrame(drawAnalogFrame);
        return;
      }
      analogUpdateAcc = 0;
      // Clear fully (transparent background)
      analogCtx.clearRect(0, 0, analogCanvas.width, analogCanvas.height);
      // Base static noise (sparse white specks)
      const step = 4; // draw a quarter-res grid
      analogCtx.fillStyle = 'rgba(255,255,255,0.0)';
      const dAlpha = 0.04 + k * 0.18;
      for (let y = 0; y < analogCanvas.height; y += step) {
        for (let x = 0; x < analogCanvas.width; x += step) {
          if (Math.random() < 0.12 * k) {
            const a = dAlpha * (0.7 + Math.random() * 0.6);
            analogCtx.fillStyle = `rgba(255,255,255,${a.toFixed(3)})`;
            analogCtx.fillRect(x, y, 1, 1);
          }
        }
      }
      // Short white dashes (slightly fewer)
      const dashCount = Math.round((analogCanvas.height / 22) * Math.max(0, dashDensity));
      analogCtx.fillStyle = 'rgba(255,255,255,0.75)';
      for (let i = 0; i < dashCount; i++) {
        const y = Math.floor(Math.random() * analogCanvas.height);
        const len = 8 + Math.floor(Math.random() * 36);
        const x = Math.floor(Math.random() * (analogCanvas.width - len));
        const h = 1 + (Math.random() < 0.15 ? 1 : 0);
        analogCtx.globalAlpha = 0.45 + Math.random() * 0.4;
        analogCtx.fillRect(x, y, len, h);
      }
      analogCtx.globalAlpha = 1;
      // Occasional horizontal glitch band (brighter noise strip)
      if (Math.random() < Math.max(0, glitchRate) * 0.6) {
        const bandY = Math.floor(Math.random() * analogCanvas.height);
        const bandH = Math.max(2, Math.floor(analogCanvas.height * 0.018));
        const a = 0.12 + k * 0.18;
        analogCtx.fillStyle = `rgba(255,255,255,${a.toFixed(3)})`;
        analogCtx.fillRect(0, bandY, analogCanvas.width, bandH);
        // add sparklies on the band
        analogCtx.globalAlpha = 0.5;
        for (let j = 0; j < 70; j++) {
          const bx = Math.random() * analogCanvas.width;
          const by = bandY + Math.random() * bandH;
          analogCtx.fillRect(bx, by, 1, 1);
        }
        analogCtx.globalAlpha = 1;
      }
      analogAnimId = requestAnimationFrame(drawAnalogFrame);
    }
    function enableAnalogHorrorEffect() {
      ensureAnalogOverlay();
      analogHorrorEnabled = true;
      if (!analogAnimId) analogAnimId = requestAnimationFrame(drawAnalogFrame);
    }
    function disableAnalogHorrorEffect() {
      analogHorrorEnabled = false;
      if (analogAnimId) { cancelAnimationFrame(analogAnimId); analogAnimId = null; }
      if (analogCanvas && analogCtx) analogCtx.clearRect(0, 0, analogCanvas.width, analogCanvas.height);
    }
    function updateAnalogOverlay() {
      if (!analogHorrorEnabled) return;
      ensureAnalogOverlay();
    }
    
    // Transition overlay utilities
    let transitionOverlayDiv = null;
    let transitionSavedTransform = '';
    function ensureTransitionOverlay() {
      ensureEffectsOverlayDiv();
      if (!effectsOverlayDiv) return null;
      if (!transitionOverlayDiv) {
        transitionOverlayDiv = document.createElement('div');
        transitionOverlayDiv.id = 'transition-overlay';
        transitionOverlayDiv.style.position = 'absolute';
        transitionOverlayDiv.style.left = '0';
        transitionOverlayDiv.style.top = '0';
        transitionOverlayDiv.style.right = '0';
        transitionOverlayDiv.style.bottom = '0';
        transitionOverlayDiv.style.pointerEvents = 'none';
        transitionOverlayDiv.style.opacity = '0';
        effectsOverlayDiv.appendChild(transitionOverlayDiv);
      }
      return transitionOverlayDiv;
    }
    function clearTransitionOverlay() {
      if (transitionOverlayDiv) { transitionOverlayDiv.style.background = ''; transitionOverlayDiv.style.opacity = '0'; transitionOverlayDiv.style.mixBlendMode = ''; }
      if (previewContentCanvas && typeof transitionSavedTransform === 'string') {
        previewContentCanvas.style.transform = transitionSavedTransform || '';
        previewContentCanvas.style.filter = '';
      }
    }
    function applyTransitionAtTime(t) {
      const active = (Array.isArray(cutoutTransitions) ? cutoutTransitions : []).find(tr => t >= tr.start && t <= tr.end);
      if (!active) { clearTransitionOverlay(); return; }
      const dur = Math.max(0.001, active.end - active.start);
      const p = Math.max(0, Math.min(1, (t - active.start) / dur));
      ensureTransitionOverlay();
      if (previewContentCanvas && typeof transitionSavedTransform === 'string' && !transitionSavedTransform) {
        transitionSavedTransform = previewContentCanvas.style.transform || '';
      }
      const easeInOut = (x) => (x < 0.5) ? (2*x*x) : (1 - Math.pow(-2*x + 2, 2)/2);
      const q = easeInOut(p);
      switch (active.type) {
        case 'brightness-flash': {
          const el = ensureTransitionOverlay();
          const a = Math.sin(q * Math.PI) * 0.6;
          el.style.background = '#ffffff';
          el.style.opacity = String(a);
          el.style.mixBlendMode = 'screen';
          break;
        }
        case 'additive-resolve': {
          const el = ensureTransitionOverlay();
          el.style.background = '#ffffff';
          el.style.opacity = String(0.25 * (1 - q));
          el.style.mixBlendMode = 'screen';
          break;
        }
        case 'dip-to-color': {
          const el = ensureTransitionOverlay();
          const a = (p < 0.5) ? (p * 2) : ((1 - p) * 2);
          el.style.background = '#000000';
          el.style.opacity = String(0.7 * a);
          el.style.mixBlendMode = 'normal';
          break;
        }
        case 'blur-dissolve': {
          if (previewContentCanvas) {
            const px = (1 - q) * 12;
            previewContentCanvas.style.filter = `blur(${px.toFixed(1)}px)`;
          }
          break;
        }
        case 'zoom-in-crash': {
          if (previewContentCanvas) {
            const s = 1 + q * 0.25;
            const base = transitionSavedTransform || '';
            previewContentCanvas.style.transform = `${base} scale(${s.toFixed(3)})`;
          }
          break;
        }
        case 'vignette-transition': {
          const el = ensureTransitionOverlay();
          const strength = 0.7 * (p < 0.5 ? (p * 2) : (1 - p) * 2);
          el.style.background = `radial-gradient(circle at 50% 50%, rgba(0,0,0,0.0) 55%, rgba(0,0,0,${strength.toFixed(2)}) 100%)`;
          el.style.opacity = '1';
          el.style.mixBlendMode = 'multiply';
          break;
        }
        default:
          clearTransitionOverlay();
      }
    }
    let snowEnabled = false;
    let snowAnimId = null;
    let snowParticles = [];
    let snowCanvas = null;
    let snowCtx = null;
    function ensureSnowOverlay() {
      ensureEffectsOverlayDiv();
      ensurePreviewContentOverlay();
      if (!effectsOverlayDiv) return;
      if (!snowCanvas) {
        snowCanvas = document.createElement('canvas');
        snowCanvas.id = 'snow-overlay';
        snowCanvas.style.position = 'absolute';
        snowCanvas.style.left = '0';
        snowCanvas.style.top = '0';
        snowCanvas.style.width = '100%';
        snowCanvas.style.height = '100%';
        snowCanvas.style.pointerEvents = 'none';
        effectsOverlayDiv.appendChild(snowCanvas);
      }
      // Match internal resolution to preview canvas
      if (previewContentCanvas && snowCanvas) {
        snowCanvas.width = previewContentCanvas.width;
        snowCanvas.height = previewContentCanvas.height;
      }
      snowCtx = snowCanvas.getContext('2d');
    }
    function createSnowParticles() {
      if (!snowCanvas) return;
      // Slightly denser baseline and scale by density
      const countBase = (snowCanvas.width * snowCanvas.height) / 9000;
      const count = Math.max(24, Math.round(countBase * effectSettings.snow.density * 1.3));
      snowParticles = [];
      for (let i = 0; i < count; i++) {
        // Size distribution: many small, some medium, a few large
        const u = Math.random();
        let baseR = 1.0;
        if (u < 0.65) {
          baseR = 0.6 + Math.random() * 1.4; // small ~0.6-2.0
        } else if (u < 0.95) {
          baseR = 1.8 + Math.random() * 2.0; // medium ~1.8-3.8
        } else {
          baseR = 3.5 + Math.random() * 3.5; // large ~3.5-7.0
        }
        const r = Math.max(0.6, baseR * Math.max(0.5, effectSettings.snow.size));
        // Per-particle tone: some pure white, some greyish
        const whitePick = Math.random() < 0.5;
        const shade = whitePick ? 255 : Math.round(180 + Math.random() * 55); // white or 180..235
        const alpha = whitePick ? (0.85 + Math.random() * 0.15) : (0.65 + Math.random() * 0.25);
        snowParticles.push({
          x: Math.random() * snowCanvas.width,
          y: Math.random() * snowCanvas.height,
          r,
          vx: effectSettings.snow.wind * (0.4 + Math.random() * 0.6),
          vy: (0.9 + Math.random() * 1.1) * (1.0 + r * 0.25) * effectSettings.snow.speed,
          wobble: Math.random() * Math.PI * 2,
          wobbleAmp: 0.6 + Math.random() * 1.1,
          shade,
          alpha
        });
      }
    }
    function drawSnow() {
      if (!snowEnabled || !snowCtx || !snowCanvas) { snowAnimId = null; return; }
      snowCtx.clearRect(0, 0, snowCanvas.width, snowCanvas.height);
      snowCtx.save();
      snowCtx.globalCompositeOperation = 'screen';
      for (const p of snowParticles) {
        p.wobble += 0.03 * effectSettings.snow.speed;
        p.x += p.vx + Math.sin(p.wobble) * p.wobbleAmp * 0.2;
        p.y += p.vy;
        if (p.x < -10) p.x = snowCanvas.width + 10;
        if (p.x > snowCanvas.width + 10) p.x = -10;
        if (p.y > snowCanvas.height + 10) {
          p.y = -10;
          p.x = Math.random() * snowCanvas.width;
        }
        const g = snowCtx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.r * 2.2);
        g.addColorStop(0, `rgba(${p.shade},${p.shade},${p.shade},${p.alpha.toFixed(2)})`);
        g.addColorStop(1, `rgba(${p.shade},${p.shade},${p.shade},0.0)`);
        snowCtx.fillStyle = g;
        snowCtx.beginPath();
        snowCtx.arc(p.x, p.y, p.r * 2.2, 0, Math.PI * 2);
        snowCtx.fill();
      }
      snowCtx.restore();
      snowAnimId = requestAnimationFrame(drawSnow);
    }
    function enableSnowEffect() {
      ensureSnowOverlay();
      snowEnabled = true;
      createSnowParticles();
      if (!snowAnimId) snowAnimId = requestAnimationFrame(drawSnow);
    }
    function disableSnowEffect() {
      snowEnabled = false;
      if (snowAnimId) { cancelAnimationFrame(snowAnimId); snowAnimId = null; }
      if (snowCanvas && snowCtx) snowCtx.clearRect(0, 0, snowCanvas.width, snowCanvas.height);
    }
    function updateSnowOverlay() {
      if (!snowEnabled) return;
      ensureSnowOverlay();
      createSnowParticles();
    }

    let rainEnabled = false;
    let rainAnimId = null;
    let rainDrops = [];
    let rainCanvas = null;
    let rainCtx = null;
    function ensureRainOverlay() {
      ensureEffectsOverlayDiv();
      ensurePreviewContentOverlay();
      if (!effectsOverlayDiv) return;
      if (!rainCanvas) {
        rainCanvas = document.createElement('canvas');
        rainCanvas.id = 'rain-overlay';
        rainCanvas.style.position = 'absolute';
        rainCanvas.style.left = '0';
        rainCanvas.style.top = '0';
        rainCanvas.style.width = '100%';
        rainCanvas.style.height = '100%';
        rainCanvas.style.pointerEvents = 'none';
        effectsOverlayDiv.appendChild(rainCanvas);
      }
      if (previewContentCanvas && rainCanvas) {
        rainCanvas.width = previewContentCanvas.width;
        rainCanvas.height = previewContentCanvas.height;
      }
      rainCtx = rainCanvas.getContext('2d');
    }
    function createRainDrops() {
      if (!rainCanvas) return;
      const countBase = (rainCanvas.width * rainCanvas.height) / 9000;
      const count = Math.max(20, Math.round(countBase * effectSettings.rain.density));
      const angleRad = (Math.max(-45, Math.min(45, effectSettings.rain.angle)) * Math.PI) / 180;
      const vx = Math.sin(angleRad);
      const vy = Math.cos(angleRad);
      const len = Math.max(6, effectSettings.rain.length);
      rainDrops = [];
      for (let i = 0; i < count; i++) {
        const sp = (1.2 + Math.random() * 1.6) * effectSettings.rain.speed;
        rainDrops.push({
          x: Math.random() * rainCanvas.width,
          y: Math.random() * rainCanvas.height,
          vx: vx * sp * 6,
          vy: vy * sp * 12,
          len: len * (0.8 + Math.random() * 0.6),
          a: Math.max(0.25, Math.min(1, effectSettings.rain.opacity)) * (0.8 + Math.random() * 0.2)
        });
      }
    }
    function drawRain() {
      if (!rainEnabled || !rainCtx || !rainCanvas) { rainAnimId = null; return; }
      rainCtx.clearRect(0, 0, rainCanvas.width, rainCanvas.height);
      rainCtx.save();
      rainCtx.globalCompositeOperation = 'screen';
      rainCtx.lineCap = 'round';
      for (const d of rainDrops) {
        d.x += d.vx;
        d.y += d.vy;
        if (d.x < -20 || d.x > rainCanvas.width + 20 || d.y > rainCanvas.height + 20) {
          d.x = Math.random() * rainCanvas.width;
          d.y = -20;
        }
        rainCtx.strokeStyle = `rgba(200, 220, 255, ${d.a.toFixed(2)})`;
        rainCtx.lineWidth = 1.2;
        rainCtx.beginPath();
        rainCtx.moveTo(d.x, d.y);
        rainCtx.lineTo(d.x - d.vx * 0.8, d.y - d.vy * 0.8 - d.len);
        rainCtx.stroke();
      }
      rainCtx.restore();
      rainAnimId = requestAnimationFrame(drawRain);
    }
    function enableRainEffect() {
      ensureRainOverlay();
      rainEnabled = true;
      createRainDrops();
      if (!rainAnimId) rainAnimId = requestAnimationFrame(drawRain);
    }
    function disableRainEffect() {
      rainEnabled = false;
      if (rainAnimId) { cancelAnimationFrame(rainAnimId); rainAnimId = null; }
      if (rainCanvas && rainCtx) rainCtx.clearRect(0, 0, rainCanvas.width, rainCanvas.height);
    }
    function updateRainOverlay() {
      if (!rainEnabled) return;
      ensureRainOverlay();
      createRainDrops();
    }

    let oldTVEnabled = false;
    function enableOldTVEffect() {
      // Bundle: scanlines + vignette + flicker + vintage grade
      enableScanlinesEffect();
      enableVignetteEffect();
      enableFlickerEffect();
      enableColorGradeEffect('color-vintage');
      enableGrainEffect();
      // Defaults tuned for CRT feel
      effectSettings.scanlines.opacity = 0.5;
      effectSettings.scanlines.pitch = 3;
      effectSettings.scanlines.speed = 1.0;
      updateScanlinesOverlayStyles();
      effectSettings.vignette.inner = 0.56;
      effectSettings.vignette.strength = 0.6;
      updateVignetteOverlayStyles();
      effectSettings.flicker.minOpacity = 0.82;
      effectSettings.flicker.maxOpacity = 1.0;
      effectSettings.flicker.pulseChance = 0.07;
      effectSettings.flicker.speed = 1.0;
      effectSettings.grain.intensity = 0.22;
      oldTVEnabled = true;
      applyCombinedContentFilters();
    }
    function disableOldTVEffect() {
      oldTVEnabled = false;
      // Remove overlays and reset
      const sc = document.getElementById('scanlines-overlay');
      if (sc && sc.parentNode) sc.parentNode.removeChild(sc);
      const vg = document.getElementById('vignette-overlay');
      if (vg && vg.parentNode) vg.parentNode.removeChild(vg);
      // Stop flicker
      flickerEnabled = false;
      if (flickerAnimId) { cancelAnimationFrame(flickerAnimId); flickerAnimId = null; }
      if (previewContentCanvas) previewContentCanvas.style.opacity = '1';
      // Clear color grade
      if (effectSettings.colorGrade) {
        effectSettings.colorGrade.type = '';
        applyCombinedContentFilters();
      }
      // Stop grain
      disableGrainEffect();
    }

    function removeCutoutOverlays() {
      disableSnowEffect();
      disableRainEffect();
      disableOldTVEffect();
      // Cleanup canvases
      const rm = (id) => { const el = document.getElementById(id); if (el && el.parentNode) el.parentNode.removeChild(el); };
      rm('snow-overlay');
      rm('rain-overlay');
      if (typeof disableOldFilmEffect === 'function') disableOldFilmEffect();
      rm('film-overlay');
      if (typeof disableAnalogHorrorEffect === 'function') disableAnalogHorrorEffect();
      rm('analog-overlay');
    }

    // Replace Magic Effects list when entering/leaving Cut Out mode
    function applyCutoutEffectsList() {
      const list = document.getElementById('effects-list');
      if (!list) return;
      // Hide default items
      Array.from(list.children).forEach((child) => {
        if (child.id !== 'cutout-effects-list') {
          child.dataset.hiddenByCutout = 'true';
          child.style.display = 'none';
        }
      });
      // Check pro status for conditional rendering
      const isPro = !!(window.userHasProAccess || (typeof getCookie === 'function' && getCookie('frameStudioPro') === '1') || localStorage.getItem('frameStudioProUnlocked') === '1');
      // Inject cutout effects list if not present
      if (!document.getElementById('cutout-effects-list')) {
        const wrapper = document.createElement('div');
        wrapper.id = 'cutout-effects-list';
        // Tiny vertical gap between buttons inside wrapper
        wrapper.style.display = 'flex';
        wrapper.style.flexDirection = 'column';
        wrapper.style.gap = '4px';
        wrapper.innerHTML = `
          <div class="tool-btn w-full text-xs flex items-center justify-between" style="padding:6px 8px" data-effect-id="oldTV" data-allow-preview="true" title="CRT scanlines, flicker, vignette and vintage grade">
            <div class="flex items-center gap-2 effect-drag-handle" draggable="false">
              <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="6" width="18" height="12" rx="2"/><path d="M7 18v2M17 18v2"/></svg>
              <span>Old TV</span>
            </div>
            <button class="tool-btn effect-settings-btn p-1" aria-label="Old TV settings">
              <svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor"><path d="M6 9l6 6 6-6"/></svg>
            </button>
          </div>
          <div class="mt-1 hidden effect-settings-panel">
            <div class="grid grid-cols-2 gap-2 text-[10px] text-gray-300">
              <label>Scanlines Opacity <input type="range" min="0" max="1" step="0.01" value="0.5" oninput="updateEffectSetting('oldTV','scan_opacity',parseFloat(this.value))" class="w-full"></label>
              <label>Scanlines Pitch <input type="range" min="2" max="8" step="1" value="3" oninput="updateEffectSetting('oldTV','scan_pitch',parseInt(this.value))" class="w-full"></label>
              <label>Flicker Speed <input type="range" min="0.2" max="3" step="0.1" value="1.0" oninput="updateEffectSetting('oldTV','flicker_speed',parseFloat(this.value))" class="w-full"></label>
              <label>Vignette Strength <input type="range" min="0.1" max="0.9" step="0.01" value="0.6" oninput="updateEffectSetting('oldTV','vig_strength',parseFloat(this.value))" class="w-full"></label>
            </div>
          </div>

          <div class="tool-btn w-full text-xs flex items-center justify-between" style="padding:6px 8px" data-effect-id="oldFilm" data-allow-preview="true" title="Vintage film scratches, dust, jitter and sepia">
            <div class="flex items-center gap-2 effect-drag-handle" draggable="false">
              <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="4" y="3" width="4" height="18" rx="1"/><rect x="12" y="3" width="8" height="18" rx="1"/><path d="M6 7h0M6 12h0M6 17h0"/></svg>
              <span>Old Film</span>
            </div>
            <button class="tool-btn effect-settings-btn p-1" aria-label="Old Film settings">
              <svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor"><path d="M6 9l6 6 6-6"/></svg>
            </button>
          </div>
          <div class="mt-1 hidden effect-settings-panel">
            <div class="grid grid-cols-2 gap-2 text-[10px] text-gray-300">
              <label>Dust Density <input type="range" min="0.2" max="2.0" step="0.05" value="0.9" oninput="updateEffectSetting('oldFilm','dust',parseFloat(this.value))" class="w-full"></label>
              <label>Scratches <input type="range" min="0.0" max="2.0" step="0.05" value="0.7" oninput="updateEffectSetting('oldFilm','scratches',parseFloat(this.value))" class="w-full"></label>
              <label>Jitter <input type="range" min="0.0" max="1.5" step="0.05" value="0.6" oninput="updateEffectSetting('oldFilm','jitter',parseFloat(this.value))" class="w-full"></label>
              <label>Sepia <input type="range" min="0.0" max="0.6" step="0.02" value="0.2" oninput="updateEffectSetting('oldFilm','sepia',parseFloat(this.value))" class="w-full"></label>
              <label>Vignette <input type="range" min="0.0" max="0.9" step="0.02" value="0.45" oninput="updateEffectSetting('oldFilm','vignette',parseFloat(this.value))" class="w-full"></label>
            </div>
          </div>

          <div class="tool-btn w-full text-xs flex items-center justify-between${isPro ? '' : ' locked-feature'}" style="padding:6px 8px" data-effect-id="analogHorror" data-allow-preview="true"${isPro ? '' : ' data-locked="true" aria-disabled="true" title="Locked feature"'}>
            <div class="flex items-center gap-2 effect-drag-handle" draggable="false">
              <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="5" width="18" height="14" rx="2"/><path d="M6 9h6M15 12h4M7 14h3"/></svg>
              <span>Analog Horror</span>
            </div>
            <button class="tool-btn effect-settings-btn p-1" aria-label="Analog Horror settings">
              <svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor"><path d="M6 9l6 6 6-6"/></svg>
            </button>
            ${isPro ? '' : '<span class="locked-badge" aria-hidden="true">Pro</span>'}
          </div>
          <div class="mt-1 hidden effect-settings-panel">
            <div class="grid grid-cols-2 gap-2 text-[10px] text-gray-300">
              <label>Intensity <input type="range" min="0.1" max="1.0" step="0.02" value="0.5" oninput="updateEffectSetting('analogHorror','intensity',parseFloat(this.value))" class="w-full"></label>
              <label>Dash Density <input type="range" min="0.0" max="1.2" step="0.02" value="0.35" oninput="updateEffectSetting('analogHorror','dashDensity',parseFloat(this.value))" class="w-full"></label>
              <label>Glitch Rate <input type="range" min="0.0" max="0.4" step="0.01" value="0.08" oninput="updateEffectSetting('analogHorror','glitchRate',parseFloat(this.value))" class="w-full"></label>
              <label>Speed <input type="range" min="0.2" max="2.5" step="0.1" value="1.0" oninput="updateEffectSetting('analogHorror','speed',parseFloat(this.value))" class="w-full"></label>
            </div>
          </div>

          <div class="tool-btn w-full text-xs flex items-center justify-between" style="padding:6px 8px" data-effect-id="snow" data-allow-preview="true" title="Fine-tuned snowfall overlay">
            <div class="flex items-center gap-2 effect-drag-handle" draggable="false">
              <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2v20M4 6l16 12M20 6L4 18"/></svg>
              <span>Snowfall</span>
            </div>
            <button class="tool-btn effect-settings-btn p-1" aria-label="Snow settings">
              <svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor"><path d="M6 9l6 6 6-6"/></svg>
            </button>
          </div>
          <div class="mt-1 hidden effect-settings-panel">
            <div class="grid grid-cols-2 gap-2 text-[10px] text-gray-300">
              <label>Density <input type="range" min="0.1" max="1.8" step="0.05" value="0.6" oninput="updateEffectSetting('snow','density',parseFloat(this.value));" class="w-full"></label>
              <label>Size <input type="range" min="0.6" max="4" step="0.1" value="2.0" oninput="updateEffectSetting('snow','size',parseFloat(this.value));" class="w-full"></label>
              <label>Speed <input type="range" min="0.2" max="3" step="0.1" value="1.6" oninput="updateEffectSetting('snow','speed',parseFloat(this.value));" class="w-full"></label>
              <label>Wind <input type="range" min="-2" max="2" step="0.1" value="0.0" oninput="updateEffectSetting('snow','wind',parseFloat(this.value));" class="w-full"></label>
            </div>
          </div>

          <div class="tool-btn w-full text-xs flex items-center justify-between${isPro ? '' : ' locked-feature'}" style="padding:6px 8px" data-effect-id="rain" data-allow-preview="true"${isPro ? '' : ' data-locked="true" aria-disabled="true" title="Locked feature"'}>
            <div class="flex items-center gap-2 effect-drag-handle" draggable="false">
              <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M6 4v4M12 4v6M18 4v5"/><path d="M5 20l2-3M11 20l2-3M17 20l2-3"/></svg>
              <span>Rain</span>
            </div>
            <button class="tool-btn effect-settings-btn p-1" aria-label="Rain settings">
              <svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor"><path d="M6 9l6 6 6-6"/></svg>
            </button>
            ${isPro ? '' : '<span class="locked-badge" aria-hidden="true">Pro</span>'}
          </div>
          <div class="mt-1 hidden effect-settings-panel">
            <div class="grid grid-cols-2 gap-2 text-[10px] text-gray-300">
              <label>Density <input type="range" min="0.2" max="2.0" step="0.05" value="0.7" oninput="updateEffectSetting('rain','density',parseFloat(this.value));" class="w-full"></label>
              <label>Speed <input type="range" min="0.4" max="3.0" step="0.1" value="1.3" oninput="updateEffectSetting('rain','speed',parseFloat(this.value));" class="w-full"></label>
              <label>Angle <input type="range" min="-30" max="30" step="1" value="15" oninput="updateEffectSetting('rain','angle',parseFloat(this.value));" class="w-full"></label>
              <label>Length <input type="range" min="6" max="40" step="1" value="14" oninput="updateEffectSetting('rain','length',parseFloat(this.value));" class="w-full"></label>
            </div>
          </div>
        `;
        // Insert at top
        list.insertBefore(wrapper, list.firstChild);
      }
      // Adjust helper note to reflect Cut Out drag target
      try {
        const helper = list.nextElementSibling;
        if (helper && helper.classList && helper.classList.contains('text-xs')) {
          helper.textContent = 'Drag onto the timeline frame.';
        }
      } catch (_e) {}
      initMagicEffectsDrag();
    }

    // Swap Magic Timeline to Magic Transitions in Cut Out mode
    let savedTimelineListHTML = '';
    let savedTimelineTitleText = '';
    function applyCutoutTransitionsList() {
      const list = document.getElementById('timeline-effects-list');
      if (!list) return;
      // Save once
      if (!savedTimelineListHTML) {
        savedTimelineListHTML = list.innerHTML;
        const heading = list.previousElementSibling;
        if (heading && heading.tagName === 'H3') {
          savedTimelineTitleText = heading.textContent || '';
        }
      }
      // Replace title
      const heading = list.previousElementSibling;
      if (heading && heading.tagName === 'H3') {
        heading.textContent = 'Magic Transitions';
      }
      // Build transitions list
      list.innerHTML = `
        <div class="tool-btn w-full text-xs flex items-center justify-between" style="padding:6px 8px" data-transition-id="brightness-flash">
          <div class="flex items-center gap-2 effect-drag-handle" draggable="true">
            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="4"/><path d="M12 2v2M12 20v2M2 12h2M20 12h2M4.5 4.5l1.4 1.4M18.1 18.1l1.4 1.4M4.5 19.5l1.4-1.4M18.1 5.9l1.4-1.4"/></svg>
            <span>Brightness Flash</span>
          </div>
        </div>
        <div class="tool-btn w-full text-xs flex items-center justify-between locked-feature" style="padding:6px 8px" data-transition-id="additive-resolve" data-locked="true" aria-disabled="true" title="Locked feature">
          <div class="flex items-center gap-2 effect-drag-handle" draggable="true">
            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="9" cy="12" r="5"/><circle cx="15" cy="12" r="5" opacity="0.6"/></svg>
            <span>Additive Resolve</span>
          </div>
          <span class="locked-badge" aria-hidden="true">Pro</span>
        </div>
        <div class="tool-btn w-full text-xs flex items-center justify-between" style="padding:6px 8px" data-transition-id="dip-to-color">
          <div class="flex items-center gap-2 effect-drag-handle" draggable="true">
            <svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor"><rect x="4" y="6" width="16" height="12" rx="2"/></svg>
            <span>Dip to Color</span>
          </div>
        </div>
        <div class="tool-btn w-full text-xs flex items-center justify-between" style="padding:6px 8px" data-transition-id="blur-dissolve">
          <div class="flex items-center gap-2 effect-drag-handle" draggable="true">
            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 12c4-4 10 4 18-4"/><path d="M3 12c4 4 10-4 18 4" opacity="0.5"/></svg>
            <span>Blur Dissolve</span>
          </div>
        </div>
        <div class="tool-btn w-full text-xs flex items-center justify-between locked-feature" style="padding:6px 8px" data-transition-id="zoom-in-crash" data-locked="true" aria-disabled="true" title="Locked feature">
          <div class="flex items-center gap-2 effect-drag-handle" draggable="true">
            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="7" y="7" width="10" height="10"/><path d="M3 3l4 4"/></svg>
            <span>Zoom In Crash</span>
          </div>
          <span class="locked-badge" aria-hidden="true">Pro</span>
        </div>
        <div class="tool-btn w-full text-xs flex items-center justify-between" style="padding:6px 8px" data-transition-id="vignette-transition">
          <div class="flex items-center gap-2 effect-drag-handle" draggable="true">
            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="6"/><circle cx="12" cy="12" r="10" opacity="0.4"/></svg>
            <span>Vignette Transition</span>
          </div>
        </div>
      `;
      initMagicEffectsDrag();
      // Change helper hint line if present
      try {
        const helper = list.nextElementSibling;
        if (helper && helper.classList && helper.classList.contains('text-xs')) {
          helper.textContent = 'Drag between frames on the cut out timeline.';
        }
      } catch (_e) {}
    }
    function restoreMagicTimelineList() {
      const list = document.getElementById('timeline-effects-list');
      if (!list || !savedTimelineListHTML) return;
      list.innerHTML = savedTimelineListHTML;
      const heading = list.previousElementSibling;
      if (heading && heading.tagName === 'H3' && savedTimelineTitleText) {
        heading.textContent = savedTimelineTitleText;
      }
      initMagicEffectsDrag();
      try {
        const helper = list.nextElementSibling;
        if (helper && helper.classList && helper.classList.contains('text-xs')) {
          helper.textContent = 'Drag onto the Animation Preview.';
        }
      } catch (_e) {}
    }
    function restoreDefaultEffectsList() {
      const list = document.getElementById('effects-list');
      if (!list) return;
      const cut = document.getElementById('cutout-effects-list');
      if (cut && cut.parentNode) cut.parentNode.removeChild(cut);
      Array.from(list.children).forEach((child) => {
        if (child.dataset.hiddenByCutout === 'true') {
          child.style.display = '';
          delete child.dataset.hiddenByCutout;
        }
      });
      // Restore helper text
      try {
        const helper = list.nextElementSibling;
        if (helper && helper.classList && helper.classList.contains('text-xs')) {
          helper.textContent = 'Drag onto the Animation Preview.';
        }
      } catch (_e) {}
    }

    // Keep overlays in sync with preview size
    window.addEventListener('resize', () => {
      if (snowEnabled) updateSnowOverlay();
      if (rainEnabled) updateRainOverlay();
      if (grainEnabled) updateGrainOverlay();
      if (oldFilmEnabled) updateOldFilmOverlay();
      if (analogHorrorEnabled) updateAnalogOverlay();
    });

    function enableScanlinesEffect() {
      ensureEffectsCSS();
      ensureEffectsOverlayDiv();
      if (!document.getElementById('scanlines-overlay')) {
        const div = document.createElement('div');
        div.id = 'scanlines-overlay';
        effectsOverlayDiv.appendChild(div);
      }
      updateScanlinesOverlayStyles();
    }

    function enableVignetteEffect() {
      ensureEffectsCSS();
      ensureEffectsOverlayDiv();
      if (!document.getElementById('vignette-overlay')) {
        const div = document.createElement('div');
        div.id = 'vignette-overlay';
        effectsOverlayDiv.appendChild(div);
      }
      updateVignetteOverlayStyles();
    }

    function updateScanlinesOverlayStyles() {
      const el = document.getElementById('scanlines-overlay');
      if (!el) return;
      el.style.opacity = String(effectSettings.scanlines.opacity);
      const pitch = Math.max(2, effectSettings.scanlines.pitch);
      el.style.background = `repeating-linear-gradient(to bottom, rgba(255,255,255,0.12) 0px, rgba(255,255,255,0.12) 1px, rgba(0,0,0,0.0) ${pitch}px)`;
      const dur = Math.max(0.1, 0.35 / effectSettings.scanlines.speed);
      el.style.animationDuration = `${dur}s`;
    }

    function updateVignetteOverlayStyles() {
      const el = document.getElementById('vignette-overlay');
      if (!el) return;
      const inner = Math.min(0.8, Math.max(0.3, effectSettings.vignette.inner));
      const strength = Math.min(0.9, Math.max(0.1, effectSettings.vignette.strength));
      el.style.background = `radial-gradient(circle at 50% 50%, rgba(0,0,0,0.0) ${Math.round(inner*100)}%, rgba(0,0,0,${strength}) 100%)`;
    }

    function isEffectLocked(el) {
      return el.classList.contains('locked-feature') || el.getAttribute('data-locked') === 'true';
    }

    function initMagicEffectsDrag() {
      const effectItems = document.querySelectorAll('#effects-list [data-effect-id], #timeline-effects-list [data-effect-id], #timeline-effects-list [data-transition-id], #magic-tools-list [data-effect-id], [data-effect-id="betweenFrames"]');
      effectItems.forEach(el => {
        if (el.dataset.effectsBound === 'true') return;
        const id = el.getAttribute('data-effect-id');
        const transitionId = el.getAttribute('data-transition-id');
        const handle = el.querySelector('.effect-drag-handle') || el;
        const settingsBtn = el.querySelector('.effect-settings-btn');
        if (handle) {
          handle.setAttribute('draggable', 'true');
          handle.addEventListener('dragstart', (e) => {
            if (isEffectLocked(el)) {
              e.preventDefault();
              return;
            }
            if (e.dataTransfer) {
              if (transitionId) {
                e.dataTransfer.setData('text/transition-id', transitionId);
              } else {
                e.dataTransfer.setData('text/effect-id', id);
              }
              e.dataTransfer.effectAllowed = 'copy';
            }
          });
        }

        const ensureHoverLine = () => {
          el.style.position = 'relative';
          let line = el.querySelector('.effects-hover-line');
          if (!line) {
            line = document.createElement('div');
            line.className = 'effects-hover-line';
            line.style.position = 'absolute';
            line.style.top = '0';
            line.style.bottom = '0';
            line.style.width = '1px';
            line.style.background = '#ffffff';
            line.style.boxShadow = '0 0 6px rgba(255,255,255,0.7)';
            line.style.opacity = '0';
            line.style.transition = 'opacity 120ms ease';
            line.style.pointerEvents = 'none';
            line.style.left = '50%';
            el.appendChild(line);
          }
          return line;
        };

        const allowPreview = () => !isEffectLocked(el) || el.getAttribute('data-allow-preview') === 'true';

        el.addEventListener('mouseenter', () => {
          const line = ensureHoverLine();
          requestAnimationFrame(() => { if (line) line.style.opacity = '1'; });
          if (allowPreview()) {
            setEffectHoverPreview(id, 0.5);
          }
        });

        el.addEventListener('mousemove', (ev) => {
          const rect = el.getBoundingClientRect();
          const x = Math.max(0, Math.min(rect.width, ev.clientX - rect.left));
          const line = ensureHoverLine();
          if (line) line.style.left = `${Math.round(x)}px`;
          if (allowPreview()) {
            const t = rect.width > 0 ? (x / rect.width) : 0.5;
            setEffectHoverPreview(id, t);
          }
        });

        el.addEventListener('mouseleave', () => {
          const line = el.querySelector('.effects-hover-line');
          if (line) line.style.opacity = '0';
          if (allowPreview()) {
            filterPreviewPart = '';
            if (hoverOverlayDiv) { hoverOverlayDiv.style.background = ''; hoverOverlayDiv.style.mixBlendMode = ''; hoverOverlayDiv.style.opacity = ''; }
            if (previewContentCanvas) previewContentCanvas.style.transform = previewSavedTransform;
            applyCombinedContentFilters();
          }
        });

        if (handle && !transitionId) {
          handle.addEventListener('click', () => {
            if (isEffectLocked(el)) return;
            if (id === 'heatHaze') {
              applyHeatHazeToFramesDramatic();
              if (typeof showCopyPasteFeedback === 'function') showCopyPasteFeedback('Heat Haze applied to all frames');
            } else if (id === 'timeline-auto-velocity') {
              applyTimelineAutoPaceByMotion();
            } else if (id === 'timeline-keypose-holds') {
              applyTimelineKeyposeHolds();
            } else if (id === 'smearFrames') {
              applySmearFrames();
              if (typeof showCopyPasteFeedback === 'function') showCopyPasteFeedback('Smear in-betweens inserted');
            } else if (id === 'echoTrail') {
              applyEchoTrail();
              if (typeof showCopyPasteFeedback === 'function') showCopyPasteFeedback('Echo trails added');
            } else if (id === 'bounceEase') {
              applyBounceEase();
              if (typeof showCopyPasteFeedback === 'function') showCopyPasteFeedback('Bounce easing in-betweens inserted');
            } else if (id === 'squashStretch') {
              applySquashStretch();
              if (typeof showCopyPasteFeedback === 'function') showCopyPasteFeedback('Squash & Stretch in-betweens inserted');
            } else if (id === 'frameBlend') {
              applyFrameBlendAcrossPairs();
              if (typeof showCopyPasteFeedback === 'function') showCopyPasteFeedback('Blended in-betweens inserted');
            } else if (id === 'betweenFrames') {
              applyBetweenFrames();
              if (typeof showCopyPasteFeedback === 'function') showCopyPasteFeedback('Between Frames added');
            } else if (id === 'timeline-ease-in') {
              applyTimelineEaseIn();
            } else if (id === 'timeline-ease-out') {
              applyTimelineEaseOut();
            } else if (id === 'timeline-ease-inout') {
              applyTimelineEaseInOut();
            } else if (id === 'timeline-linear') {
              applyTimelineLinear();
            } else if (id === 'timeline-slow-down') {
              applyTimelineSlowDown();
            } else if (id === 'timeline-acceleration') {
              applyTimelineAcceleration();
            } else if (id === 'oldTV') {
              // Toggle friendly: enable on click
              if (!oldTVEnabled) enableOldTVEffect(); else disableOldTVEffect();
            } else if (id === 'snow') {
              if (!snowEnabled) enableSnowEffect(); else disableSnowEffect();
            } else if (id === 'rain') {
              if (!rainEnabled) enableRainEffect(); else disableRainEffect();
            } else if (id === 'oldFilm') {
              if (!oldFilmEnabled) enableOldFilmEffect(); else disableOldFilmEffect();
            } else if (id === 'analogHorror') {
              if (!analogHorrorEnabled) enableAnalogHorrorEffect(); else disableAnalogHorrorEffect();
            }
          });
        }

        if (settingsBtn) {
          settingsBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            if (isEffectLocked(el)) return;
            openEffectSettings(id, settingsBtn);
          });
        }

        el.dataset.effectsBound = 'true';
      });
    }

    if (previewContainer) {
      previewContainer.addEventListener('dragover', (e) => {
        e.preventDefault();
        previewContainer.style.outline = '2px solid #6366f1';
      });
      previewContainer.addEventListener('dragleave', () => {
        previewContainer.style.outline = '';
      });
      previewContainer.addEventListener('drop', (e) => {
        e.preventDefault();
        previewContainer.style.outline = '';
        const effectId = e.dataTransfer ? e.dataTransfer.getData('text/effect-id') : '';
        if (effectId === 'heatHaze') {
          applyHeatHazeToFramesDramatic();
          if (typeof showCopyPasteFeedback === 'function') showCopyPasteFeedback('Heat Haze applied to all frames');
        } else if (effectId === 'timeline-auto-velocity') {
          applyTimelineAutoPaceByMotion();
        } else if (effectId === 'timeline-keypose-holds') {
          applyTimelineKeyposeHolds();
        } else if (effectId === 'smearFrames') {
          applySmearFrames();
          if (typeof showCopyPasteFeedback === 'function') showCopyPasteFeedback('Smear in-betweens inserted');
        } else if (effectId === 'echoTrail') {
          applyEchoTrail();
          if (typeof showCopyPasteFeedback === 'function') showCopyPasteFeedback('Echo trails added');
        } else if (effectId === 'bounceEase') {
          applyBounceEase();
          if (typeof showCopyPasteFeedback === 'function') showCopyPasteFeedback('Bounce easing in-betweens inserted');
        } else if (effectId === 'squashStretch') {
          applySquashStretch();
          if (typeof showCopyPasteFeedback === 'function') showCopyPasteFeedback('Squash & Stretch in-betweens inserted');
        } else if (effectId === 'frameBlend') {
          applyFrameBlendAcrossPairs();
          if (typeof showCopyPasteFeedback === 'function') showCopyPasteFeedback('Blended in-betweens inserted');
        } else if (effectId === 'betweenFrames') {
          applyBetweenFrames();
          if (typeof showCopyPasteFeedback === 'function') showCopyPasteFeedback('Between Frames added');
        } else if (effectId === 'timeline-ease-in') {
          applyTimelineEaseIn();
        } else if (effectId === 'timeline-ease-out') {
          applyTimelineEaseOut();
        } else if (effectId === 'timeline-ease-inout') {
          applyTimelineEaseInOut();
        } else if (effectId === 'timeline-linear') {
          applyTimelineLinear();
        } else if (effectId === 'timeline-slow-down') {
          applyTimelineSlowDown();
        } else if (effectId === 'timeline-acceleration') {
          applyTimelineAcceleration();
        }
      });
      // Also allow dropping timeline effects onto the timeline area itself
      const timelineContainerEl = document.getElementById('timeline-container');
      if (timelineContainerEl) {
        timelineContainerEl.addEventListener('dragover', (e) => { e.preventDefault(); });
        timelineContainerEl.addEventListener('drop', (e) => {
          e.preventDefault();
          const effectId = e.dataTransfer ? e.dataTransfer.getData('text/effect-id') : '';
          if (effectId === 'timeline-auto-velocity') {
            applyTimelineAutoPaceByMotion();
          } else if (effectId === 'timeline-keypose-holds') {
            applyTimelineKeyposeHolds();
          } else if (effectId === 'timeline-ease-in') {
            applyTimelineEaseIn();
          } else if (effectId === 'timeline-ease-out') {
            applyTimelineEaseOut();
          } else if (effectId === 'timeline-ease-inout') {
            applyTimelineEaseInOut();
          } else if (effectId === 'timeline-linear') {
            applyTimelineLinear();
          } else if (effectId === 'timeline-slow-down') {
            applyTimelineSlowDown();
          } else if (effectId === 'timeline-acceleration') {
            applyTimelineAcceleration();
          }
        });
      }
      const timelineRulerEl = document.getElementById('timeline-ruler');
      if (timelineRulerEl) {
        timelineRulerEl.addEventListener('dragover', (e) => { e.preventDefault(); });
        timelineRulerEl.addEventListener('drop', (e) => {
          e.preventDefault();
          const effectId = e.dataTransfer ? e.dataTransfer.getData('text/effect-id') : '';
          if (effectId === 'timeline-auto-velocity') {
            applyTimelineAutoPaceByMotion();
          } else if (effectId === 'timeline-keypose-holds') {
            applyTimelineKeyposeHolds();
          } else if (effectId === 'timeline-ease-in') {
            applyTimelineEaseIn();
          } else if (effectId === 'timeline-ease-out') {
            applyTimelineEaseOut();
          } else if (effectId === 'timeline-ease-inout') {
            applyTimelineEaseInOut();
          } else if (effectId === 'timeline-linear') {
            applyTimelineLinear();
          } else if (effectId === 'timeline-slow-down') {
            applyTimelineSlowDown();
          } else if (effectId === 'timeline-acceleration') {
            applyTimelineAcceleration();
          }
        });
      }
      // Hover scrub line logic (active when Magic Effects list is hovered)
      let isEffectsHoverActive = false;
      let isScrubActive = false;
      let scrubWasPlaying = false;
      let scrubPrevAnimationFrame = 0;
      function ensureScrubLine() {
        let el = document.getElementById('hover-scrub-line');
        if (!el) {
          el = document.createElement('div');
          el.id = 'hover-scrub-line';
          el.style.position = 'absolute';
          el.style.top = '0';
          el.style.bottom = '0';
          el.style.width = '2px';
          el.style.background = 'linear-gradient(to bottom, #ffffff, #f59e0b)';
          el.style.boxShadow = '0 0 6px rgba(245,158,11,0.7)';
          el.style.opacity = '0';
          el.style.transition = 'opacity 120ms ease';
          el.style.pointerEvents = 'none';
          previewContainer.appendChild(el);
        }
        return el;
      }
      const effectsListEl = document.getElementById('effects-list');
      if (effectsListEl) {
        effectsListEl.addEventListener('mouseenter', () => { isEffectsHoverActive = true; });
        effectsListEl.addEventListener('mouseleave', () => { isEffectsHoverActive = false; });
      }
      const timelineEffectsEl = document.getElementById('timeline-effects-list');
      if (timelineEffectsEl) {
        timelineEffectsEl.addEventListener('mouseenter', () => { isEffectsHoverActive = true; });
        timelineEffectsEl.addEventListener('mouseleave', () => { isEffectsHoverActive = false; });
      }
      function beginScrub() {
        if (!isEffectsHoverActive) return false;
        const line = ensureScrubLine();
        line.style.opacity = '1';
        if (!contentCtx) ensurePreviewContentOverlay();
        scrubWasPlaying = !!animationInterval;
        scrubPrevAnimationFrame = animationFrame;
        if (scrubWasPlaying) { clearInterval(animationInterval); animationInterval = null; }
        isScrubActive = true;
        return true;
      }
      function endScrub() {
        const line = document.getElementById('hover-scrub-line');
        if (line) line.style.opacity = '0';
        if (isScrubActive) {
          if (scrubWasPlaying) {
            animationFrame = scrubPrevAnimationFrame;
            currentFrameTime = 0;
            currentFrameDuration = frameDurations[animationFrame];
            animationInterval = setInterval(updateAnimation, 1000 / fps);
          } else {
            renderStaticFrame(scrubPrevAnimationFrame);
          }
        }
        isScrubActive = false;
      }
      previewContainer.addEventListener('mouseenter', () => { if (isEffectsHoverActive) beginScrub(); });
      previewContainer.addEventListener('mousemove', (e) => {
        if (!isEffectsHoverActive) return;
        if (!isScrubActive) { if (!beginScrub()) return; }
        const rect = previewContainer.getBoundingClientRect();
        const x = Math.max(0, Math.min(rect.width, e.clientX - rect.left));
        const line = ensureScrubLine();
        line.style.left = `${Math.round(x)}px`;
        const total = frameDurations.reduce((a,b)=>a+b,0) || 1;
        const t = x / rect.width;
        let accum = 0;
        let idx = 0;
        for (let i = 0; i < frameDurations.length; i++) {
          accum += frameDurations[i] / total;
          if (t <= accum) { idx = i; break; }
          if (i === frameDurations.length - 1) idx = i;
        }
        renderStaticFrame(idx);
      });
      previewContainer.addEventListener('mouseleave', () => { if (isScrubActive) endScrub(); });
    }

    // Initialize effects once DOM nodes exist
    initMagicEffectsDrag();
    // Clips UI removed
    function openEffectSettings(effectId, anchorEl) {
      const item = anchorEl.closest('[data-effect-id]');
      if (!item) return;
      let panel = item.nextElementSibling;
      if (!panel || !panel.classList || !panel.classList.contains('effect-settings-panel')) return;
      const isHidden = panel.classList.contains('hidden');
      // Collapse other open panels
      document.querySelectorAll('#effects-list .effect-settings-panel').forEach(p => {
        if (p !== panel) p.classList.add('hidden');
      });
      if (isHidden) panel.classList.remove('hidden'); else panel.classList.add('hidden');
    }

    function updateEffectSetting(effectId, key, value) {
      if (!effectSettings[effectId]) effectSettings[effectId] = {};
      effectSettings[effectId][key] = value;
      if (effectId === 'glowPulse' || effectId === 'heatHaze') applyCombinedContentFilters();
      if (effectId === 'scanlines') updateScanlinesOverlayStyles();
      if (effectId === 'vignette') updateVignetteOverlayStyles();
      if (effectId === 'snow') updateSnowOverlay();
      if (effectId === 'rain') updateRainOverlay();
      if (effectId === 'oldTV') {
        // Map proxies to underlying parts
        if (key === 'scan_opacity') { effectSettings.scanlines.opacity = value; updateScanlinesOverlayStyles(); }
        if (key === 'scan_pitch') { effectSettings.scanlines.pitch = value; updateScanlinesOverlayStyles(); }
        if (key === 'flicker_speed') { effectSettings.flicker.speed = value; }
        if (key === 'vig_strength') { effectSettings.vignette.strength = value; updateVignetteOverlayStyles(); }
        applyCombinedContentFilters();
      }
      if (effectId === 'grain') updateGrainOverlay();
      if (effectId === 'oldFilm') updateOldFilmOverlay();
      if (effectId === 'analogHorror') updateAnalogOverlay();
    }

    /* Added zoom handler function - Point-accurate zoom */
    // Per-frame point origin storage for point-accurate zoom
    if (!window.zoomOriginPoints) {
      window.zoomOriginPoints = [];
    }
    
    function handleZoom(e, frameIndex) {
      const delta = e.deltaY > 0 ? -0.1 : 0.1;
      // Limit zoom to not go below 1.0 (actual canvas size) and max 3.0
      const oldScale = zoomLevels[frameIndex] || 1.0;
      const newScale = Math.max(1.0, Math.min(3.0, oldScale + delta));
      if (newScale === oldScale) return;
      zoomLevels[frameIndex] = newScale;
      
      const canvas = canvases[frameIndex];
      if (!canvas) return;
      const onionCanvas = onionCanvases[frameIndex];
      const guideCanvas = guideCanvases[frameIndex];
      const container = canvas.parentElement;
      if (!container) return;
      
      const rect = container.getBoundingClientRect();
      
      // Point-accurate zoom: always update origin to current mouse position
      // Ensure array is large enough
      while (window.zoomOriginPoints.length <= frameIndex) {
        window.zoomOriginPoints.push(null);
      }
      
      if (newScale > 1.0) {
        const newPoint = getPointOrigin(rect, e.clientX, e.clientY);
        if (oldScale <= 1.0 + 1e-9) {
          // Starting fresh zoom - use exact mouse position
          window.zoomOriginPoints[frameIndex] = newPoint;
        } else if (window.zoomOriginPoints[frameIndex]) {
          // Already zoomed - smoothly interpolate origin towards new point
          const t = Math.min(1, (3.0 - oldScale) / 2.0) * 0.3;
          window.zoomOriginPoints[frameIndex] = {
            x: window.zoomOriginPoints[frameIndex].x + (newPoint.x - window.zoomOriginPoints[frameIndex].x) * t,
            y: window.zoomOriginPoints[frameIndex].y + (newPoint.y - window.zoomOriginPoints[frameIndex].y) * t
          };
        } else {
          window.zoomOriginPoints[frameIndex] = newPoint;
        }
      } else {
        // Zoomed back to 1.0 - reset origin for next zoom
        window.zoomOriginPoints[frameIndex] = null;
      }
      
      // Get the CSS origin string
      const originPoint = window.zoomOriginPoints[frameIndex];
      const origin = originPoint ? pointOriginToCss(originPoint) : 'center center';
      
      // Apply zoom about point-accurate origin
      ensureZoomCenterOverlay(container);
      canvas.style.transformOrigin = origin;
      canvas.style.transform = `scale(${zoomLevels[frameIndex]})`;
      if (onionCanvas) {
        onionCanvas.style.transformOrigin = origin;
        onionCanvas.style.transform = `scale(${zoomLevels[frameIndex]})`;
      }
      // Keep lasso overlay (if present on this frame) in sync
      if (typeof lassoOverlayCanvas !== 'undefined' && lassoOverlayCanvas && lassoOverlayCanvas.parentElement === container) {
        lassoOverlayCanvas.style.transformOrigin = origin;
        lassoOverlayCanvas.style.transform = `scale(${zoomLevels[frameIndex]})`;
      }
      if (guideCanvas) {
        guideCanvas.style.transform = `scale(${zoomLevels[frameIndex]})`;
        guideCanvas.style.transformOrigin = origin;
      }
      // Keep selection overlay (if present) in sync with zoom on the active frame
      if (typeof currentFrame === 'number' && frameIndex === currentFrame && typeof moveOverlayCanvas !== 'undefined' && moveOverlayCanvas) {
        moveOverlayCanvas.style.transformOrigin = origin;
        moveOverlayCanvas.style.transform = `scale(${zoomLevels[frameIndex]})`;
      }
      
      // If zoomed out too much, reset to minimum zoom
      if (zoomLevels[frameIndex] < 1.0) {
        zoomLevels[frameIndex] = 1.0;
        canvas.style.transform = 'scale(1)';
        if (onionCanvas) onionCanvas.style.transform = 'scale(1)';
      }
    }

    /* Added viewport switching function */
    function setViewport(mode) {
      currentViewport = mode;
      const containers = document.querySelectorAll('.canvas-container');
      
      document.getElementById('desktop-btn').classList.toggle('active', mode === 'desktop');
      document.getElementById('phone-btn').classList.toggle('active', mode === 'phone');
      
      // Reset zoom levels and origin points when switching viewports
      zoomLevels.fill(1.0);
      if (window.zoomOriginPoints) {
        window.zoomOriginPoints.fill(null);
      }
      
      if (mode === 'desktop') {
        // Desktop: 16:9 aspect ratio
        containers.forEach(container => {
          container.style.setProperty('--canvas-aspect-ratio', '16 / 9');
          ensureZoomCenterOverlay(container);
        });
        ensureZoomCenterOverlays();
        
        /* Reduced desktop canvas dimensions */
        // Update canvas dimensions for all frames
        const newSize = getTargetCanvasSizeForViewport('desktop');
        for (let i = 0; i < frameLayers.length; i++) {
          const canvas = document.getElementById(`canvas-${i}`);
          const onionCanvas = document.getElementById(`onion-${i}`);
          if (canvas && onionCanvas) {
            const oldW = canvas.width;
            const oldH = canvas.height;
            canvas.width = newSize.width;
            canvas.height = newSize.height;
            onionCanvas.width = newSize.width;
            onionCanvas.height = newSize.height;
            // Reset zoom transform
            canvas.style.transform = 'scale(1)';
            onionCanvas.style.transform = 'scale(1)';
            // Rescale image objects for this frame
            const sx = newSize.width / oldW;
            const sy = newSize.height / oldH;
            frameLayers[i].forEach(layer => {
              if (Array.isArray(layer.images)) {
                layer.images.forEach(obj => {
                  obj.x *= sx;
                  obj.y *= sy;
                  obj.scale *= Math.min(sx, sy);
                });
              }
            });
          }
        }
        
        // Update layer canvases
        frameLayers.forEach(layers => {
          layers.forEach(layer => {
            const oldCanvas = layer.canvas;
            const newCanvas = document.createElement('canvas');
            newCanvas.width = newSize.width;
            newCanvas.height = newSize.height;
            const newCtx = newCanvas.getContext('2d', { willReadFrequently: true });
            
            // Enable high-quality image smoothing
            newCtx.imageSmoothingEnabled = true;
            newCtx.imageSmoothingQuality = 'high';
            
            newCtx.drawImage(oldCanvas, 0, 0, oldCanvas.width, oldCanvas.height, 0, 0, newSize.width, newSize.height);
            layer.canvas = newCanvas;
            layer.ctx = newCtx;
          });
        });
        
        previewCanvas.width = newSize.width;
        previewCanvas.height = newSize.height;
        // Sync content overlay size
        if (typeof ensurePreviewContentOverlay === 'function') ensurePreviewContentOverlay();
        if (typeof previewContentCanvas !== 'undefined' && previewContentCanvas) {
          previewContentCanvas.width = newSize.width;
          previewContentCanvas.height = newSize.height;
        }
        // Set preview container aspect ratio for desktop
        const previewContainer = document.getElementById('preview-container');
        if (previewContainer) {
          previewContainer.style.setProperty('--canvas-aspect-ratio', '16 / 9');
        }
        // Sync Cut Out Mode sizing to viewport
        if (typeof syncCutoutSizing === 'function') syncCutoutSizing();
        // Sync all clip canvases to new viewport dimensions
        if (typeof syncAllClipCanvasDimensions === 'function') {
          try { syncAllClipCanvasDimensions(); } catch (_e) {}
        }
      if (typeof refreshMiniPreviewSizing === 'function') refreshMiniPreviewSizing();
      } else {
        // Phone: 9:16 aspect ratio
        containers.forEach(container => {
          container.style.setProperty('--canvas-aspect-ratio', '9 / 16');
          ensureZoomCenterOverlay(container);
        });
        ensureZoomCenterOverlays();
        
        /* Reduced phone canvas dimensions */
        // Update canvas dimensions for all frames
        const newSize = getTargetCanvasSizeForViewport('phone');
        for (let i = 0; i < frameLayers.length; i++) {
          const canvas = document.getElementById(`canvas-${i}`);
          const onionCanvas = document.getElementById(`onion-${i}`);
          if (canvas && onionCanvas) {
            const oldW = canvas.width;
            const oldH = canvas.height;
            canvas.width = newSize.width;
            canvas.height = newSize.height;
            onionCanvas.width = newSize.width;
            onionCanvas.height = newSize.height;
            // Reset zoom transform
            canvas.style.transform = 'scale(1)';
            onionCanvas.style.transform = 'scale(1)';
            // Rescale image objects for this frame
            const sx = newSize.width / oldW;
            const sy = newSize.height / oldH;
            frameLayers[i].forEach(layer => {
              if (Array.isArray(layer.images)) {
                layer.images.forEach(obj => {
                  obj.x *= sx;
                  obj.y *= sy;
                  obj.scale *= Math.min(sx, sy);
                });
              }
            });
          }
        }
        
        // Update layer canvases
        frameLayers.forEach(layers => {
          layers.forEach(layer => {
            const oldCanvas = layer.canvas;
            const newCanvas = document.createElement('canvas');
            newCanvas.width = newSize.width;
            newCanvas.height = newSize.height;
            const newCtx = newCanvas.getContext('2d', { willReadFrequently: true });
            newCtx.drawImage(oldCanvas, 0, 0, oldCanvas.width, oldCanvas.height, 0, 0, newSize.width, newSize.height);
            layer.canvas = newCanvas;
            layer.ctx = newCtx;
          });
        });
        
        previewCanvas.width = newSize.width;
        previewCanvas.height = newSize.height;
        // Sync content overlay size
        if (typeof ensurePreviewContentOverlay === 'function') ensurePreviewContentOverlay();
        if (typeof previewContentCanvas !== 'undefined' && previewContentCanvas) {
          previewContentCanvas.width = newSize.width;
          previewContentCanvas.height = newSize.height;
        }
        // Set preview container aspect ratio for phone
        const previewContainer = document.getElementById('preview-container');
        if (previewContainer) {
          previewContainer.style.setProperty('--canvas-aspect-ratio', '9 / 16');
        }
        // Sync Cut Out Mode sizing to viewport
        if (typeof syncCutoutSizing === 'function') syncCutoutSizing();
        // Sync all clip canvases to new viewport dimensions
        if (typeof syncAllClipCanvasDimensions === 'function') {
          try { syncAllClipCanvasDimensions(); } catch (_e) {}
        }
        if (typeof refreshMiniPreviewSizing === 'function') refreshMiniPreviewSizing();
      }
      
      // Ensure frames per row based on viewport mode (desktop=2, phone=3) on desktop-width screens only
      const grid = document.querySelector('.canvas-grid');
      if (grid) {
        if (window.innerWidth >= 1024) {
          if (mode === 'desktop') {
            grid.style.gridTemplateColumns = 'repeat(2, 1fr)';
          } else {
            grid.style.gridTemplateColumns = 'repeat(3, 1fr)';
          }
        } else {
          // Do not force columns on smaller screens; use responsive CSS
          grid.style.removeProperty('grid-template-columns');
        }
      }
      
      // Redraw all frames
      for (let i = 0; i < 6; i++) {
        composeLayers(i);
        updateThumbnail(i);
      }
      
      updateOnionSkin();
    }

    function saveState() {
      const state = {
        frameLayers: frameLayers.map(layers => layers.map(layer => layer.canvas.toDataURL())),
        images: frameLayers.map(layers => layers.map(layer => Array.isArray(layer.images) ? layer.images.map(obj => ({ src: obj.src, x: obj.x, y: obj.y, scale: obj.scale })) : [])),
        onionSkinEnabled: onionSkinEnabled,
        // Persist selection-lasso enable so undo/redo doesn't disable segmentation
        selectLassoEnabled: !!selectLassoEnabled,
        guideOverlays: guideCanvases.map((gc) => {
          try { return (gc && gc.width && gc.height) ? gc.toDataURL() : null; } catch (e) { return null; }
        }),
        bones: bones.map((b) => {
          if (!b) return null;
          let imageIndex = -1;
          const layer = frameLayers[b.frameIndex] && frameLayers[b.frameIndex][b.layerIndex];
          if (layer && Array.isArray(layer.images) && b.imageObj) imageIndex = layer.images.indexOf(b.imageObj);
          return {
            frameIndex: b.frameIndex,
            layerIndex: b.layerIndex,
            startX: b.startX, startY: b.startY, endX: b.endX, endY: b.endY,
            restLength: b.restLength,
            initialScale: b.initialScale,
            restAngle: b.restAngle,
            prevAngle: b.prevAngle,
            imageRotationOffset: b.imageRotationOffset,
            parentBoneIndex: (b.parentBoneIndex !== undefined ? b.parentBoneIndex : null),
            attachedAt: (b.attachedAt !== undefined ? b.attachedAt : null),
            parentAttach: (b.parentAttach !== undefined ? b.parentAttach : null),
            imageIndex
          };
        }),
        cutout: (function () {
          try {
            const clips = Array.isArray(cutoutClips) ? cutoutClips.map((c) => {
              let dataUrl = c && (c.dataUrl || null);
              try {
                if (c && c.canvas) {
                  dataUrl = c.canvas.toDataURL('image/png');
                }
              } catch (_e) { /* ignore */ }
              const objects = Array.isArray(c && c.objects) ? c.objects.map((o) => ({
                id: o.id,
                name: o.name,
                color: o.color,
                src: o.src,
                layerIndex: Number.isFinite(o.layerIndex) ? o.layerIndex : 0,
                x: Number.isFinite(o.x) ? o.x : 0,
                y: Number.isFinite(o.y) ? o.y : 0,
                scale: Number.isFinite(o.scale) ? o.scale : 1,
                scaleX: Number.isFinite(o.scaleX) ? o.scaleX : 1,
                scaleY: Number.isFinite(o.scaleY) ? o.scaleY : 1,
                rotation: Number.isFinite(o.rotation) ? o.rotation : 0,
                opacity: Number.isFinite(o.opacity) ? o.opacity : 1,
                drawW: o.drawW,
                drawH: o.drawH,
                keys: {
                  position: Array.isArray(o.keys && o.keys.position) ? o.keys.position.map(k => ({ time: k.time, x: k.x, y: k.y })) : [],
                  zoom: Array.isArray(o.keys && o.keys.zoom) ? o.keys.zoom.map(k => ({ time: k.time, sx: k.sx, sy: k.sy })) : [],
                  rotation: Array.isArray(o.keys && o.keys.rotation) ? o.keys.rotation.map(k => ({ time: k.time, deg: k.deg })) : [],
                  opacity: Array.isArray(o.keys && o.keys.opacity) ? o.keys.opacity.map(k => ({ time: k.time, value: k.value })) : []
                }
              })) : [];
              return {
                start: c && typeof c.start === 'number' ? c.start : 0,
                end: c && typeof c.end === 'number' ? c.end : 0,
                width: (c && c.canvas && c.canvas.width > 0) ? c.canvas.width : 0,
                height: (c && c.canvas && c.canvas.height > 0) ? c.canvas.height : 0,
                dataUrl: dataUrl || null,
                objects
              };
            }) : [];
            const propKeys = {
              position: (cutoutPropertyKeys && Array.isArray(cutoutPropertyKeys.position)) ? cutoutPropertyKeys.position.map(k => ({ time: k.time, x: k.x, y: k.y })) : [],
              zoom: (cutoutPropertyKeys && Array.isArray(cutoutPropertyKeys.zoom)) ? cutoutPropertyKeys.zoom.map(k => ({ time: k.time, sx: k.sx, sy: k.sy })) : [],
              rotation: (cutoutPropertyKeys && Array.isArray(cutoutPropertyKeys.rotation)) ? cutoutPropertyKeys.rotation.map(k => ({ time: k.time, deg: k.deg })) : [],
              opacity: (cutoutPropertyKeys && Array.isArray(cutoutPropertyKeys.opacity)) ? cutoutPropertyKeys.opacity.map(k => ({ time: k.time, value: k.value })) : []
            };
            return {
              clips,
              propKeys,
              keys: Array.isArray(cutoutKeys) ? cutoutKeys.map(k => ({ time: k.time })) : [],
              duration: typeof cutoutDuration === 'number' ? cutoutDuration : 3.0,
              currentTime: typeof cutoutCurrentTime === 'number' ? cutoutCurrentTime : 0,
              selectedIndex: (typeof selectedCutoutClipIndex === 'number' ? selectedCutoutClipIndex : -1),
              bones: (function () {
                try {
                  return Array.isArray(cutoutBones) ? cutoutBones.map((b) => {
                    if (!b) return null;
                    let objectIndex = -1;
                    const clip = cutoutClips[b.clipIndex];
                    if (clip && Array.isArray(clip.objects) && b.objectRef) objectIndex = clip.objects.indexOf(b.objectRef);
                    return {
                      clipIndex: b.clipIndex,
                      startX: b.startX, startY: b.startY, endX: b.endX, endY: b.endY,
                      restLength: b.restLength,
                      initialScale: b.initialScale,
                      restAngle: b.restAngle,
                      prevAngle: b.prevAngle,
                      imageRotationOffset: b.imageRotationOffset,
                      parentBoneIndex: (b.parentBoneIndex !== undefined ? b.parentBoneIndex : null),
                      attachedAt: (b.attachedAt !== undefined ? b.attachedAt : null),
                      parentAttach: (b.parentAttach !== undefined ? b.parentAttach : null),
                      pinnedLocalX: (typeof b.pinnedLocalX === 'number' ? b.pinnedLocalX : undefined),
                      pinnedLocalY: (typeof b.pinnedLocalY === 'number' ? b.pinnedLocalY : undefined),
                      endLocalX: (typeof b.endLocalX === 'number' ? b.endLocalX : undefined),
                      endLocalY: (typeof b.endLocalY === 'number' ? b.endLocalY : undefined),
                      objectIndex
                    };
                  }) : [];
                } catch (_e) {
                  return [];
                }
              })(),
              preBonePivotStorage: (function() {
                try {
                  return JSON.parse(JSON.stringify(preBonePivotStorage || {}));
                } catch (_e) {
                  return {};
                }
              })()
            };
          } catch (_err) {
            return null;
          }
        })()
      };
      history.push(state);
      if (history.length > 50) history.shift();
      redoStack.length = 0;
      updateHistoryButtons();
    }

    function undo() {
      if (history.length > 1) {
        redoStack.push(history.pop());
        const state = history[history.length - 1];
        restoreState(state);
        updateHistoryButtons();
        // Restore select-lasso availability if present in state
        try {
          if (state && typeof state.selectLassoEnabled === 'boolean') {
            selectLassoEnabled = state.selectLassoEnabled;
            if (typeof updateSelectLassoToggle === 'function') updateSelectLassoToggle();
          }
        } catch (_e) {}
      }
    }

    function redo() {
      if (redoStack.length > 0) {
        const state = redoStack.pop();
        history.push(state);
        restoreState(state);
        updateHistoryButtons();
        // Restore select-lasso availability if present in state
        try {
          if (state && typeof state.selectLassoEnabled === 'boolean') {
            selectLassoEnabled = state.selectLassoEnabled;
            if (typeof updateSelectLassoToggle === 'function') updateSelectLassoToggle();
          }
        } catch (_e) {}
      }
    }

    function restoreState(state) {
      // Handle both old format (array) and new format (object)
      let frameLayersData, onionSkinState;
      
      if (Array.isArray(state)) {
        // Old format - just frame layers, keep current onion skin state
        frameLayersData = state;
        onionSkinState = onionSkinEnabled;
      } else {
        // New format - object with frame layers and onion skin state
        frameLayersData = state.frameLayers;
        onionSkinState = state.onionSkinEnabled;
      }
      
      frameLayersData.forEach((layersDataURL, frameIndex) => {
        layersDataURL.forEach((dataURL, layerIndex) => {
          const img = new Image();
          img.onload = () => {
            const layer = frameLayers[frameIndex][layerIndex];
            layer.ctx.clearRect(0, 0, layer.canvas.width, layer.canvas.height);
            layer.ctx.drawImage(img, 0, 0);
            if (frameIndex === currentFrame) {
              composeLayers();
              updateThumbnail(frameIndex);
            }
          };
          img.src = dataURL;
        });
      });
      if (state.images) {
        state.images.forEach((layersImages, frameIndex) => {
          layersImages.forEach((imageList, layerIndex) => {
            const layer = frameLayers[frameIndex][layerIndex];
            layer.images = [];
            if (Array.isArray(imageList)) {
              imageList.forEach(obj => {
                const img = new Image();
                img.onload = () => {
                  composeLayers(frameIndex);
                  updateThumbnail(frameIndex);
                };
                img.src = obj.src;
        layer.images.push({ img, src: obj.src, x: obj.x, y: obj.y, scale: obj.scale, scaleX: 1, scaleY: 1, rotation: obj.rotation || 0 });
              });
            }
          });
        });
      }
      // Restore animation path guide overlays if present
      if (state.guideOverlays && Array.isArray(state.guideOverlays)) {
        state.guideOverlays.forEach((dataURL, frameIndex) => {
          const base = canvases[frameIndex];
          if (!base) return;
          let gCanvas = guideCanvases[frameIndex];
          let gCtx = guideContexts[frameIndex];
          if (!gCanvas || !gCtx || gCanvas.width !== base.width || gCanvas.height !== base.height || !gCanvas.parentElement) {
            const container = base.parentElement;
            if (!container) return;
            if (gCanvas && gCanvas.parentElement) gCanvas.parentElement.removeChild(gCanvas);
            gCanvas = document.createElement('canvas');
            gCanvas.id = `guides-${frameIndex}`;
            gCanvas.width = base.width;
            gCanvas.height = base.height;
            gCanvas.style.position = 'absolute';
            gCanvas.style.top = '0';
            gCanvas.style.left = '0';
            gCanvas.style.width = '100%';
            gCanvas.style.height = '100%';
            gCanvas.style.pointerEvents = 'none';
            gCanvas.style.zIndex = '1001';
            gCanvas.style.transformOrigin = 'top left';
            gCanvas.style.transform = `scale(${zoomLevels[frameIndex] || 1})`;
            gCtx = gCanvas.getContext('2d', { willReadFrequently: true });
            container.style.position = 'relative';
            container.appendChild(gCanvas);
            guideCanvases[frameIndex] = gCanvas;
            guideContexts[frameIndex] = gCtx;
          } else {
            gCtx.clearRect(0, 0, gCanvas.width, gCanvas.height);
          }
          if (dataURL) {
            const img = new Image();
            img.onload = () => {
              gCtx.clearRect(0, 0, gCanvas.width, gCanvas.height);
              gCtx.drawImage(img, 0, 0);
            };
            img.src = dataURL;
          } else {
            gCtx.clearRect(0, 0, gCanvas.width, gCanvas.height);
          }
        });
      }

      // Restore bones if present
      bones = [];
      if (state.bones && Array.isArray(state.bones)) {
        state.bones.forEach((sb) => {
          if (!sb) { bones.push(null); return; }
          const layer = frameLayers[sb.frameIndex] && frameLayers[sb.frameIndex][sb.layerIndex];
          const imageObj = (layer && Array.isArray(layer.images) && sb.imageIndex >= 0) ? layer.images[sb.imageIndex] : null;
          bones.push({
            frameIndex: sb.frameIndex,
            layerIndex: sb.layerIndex,
            imageObj: imageObj || null,
            startX: sb.startX, startY: sb.startY, endX: sb.endX, endY: sb.endY,
            restLength: sb.restLength,
            initialScale: sb.initialScale,
            restAngle: sb.restAngle,
            prevAngle: sb.prevAngle,
            imageRotationOffset: sb.imageRotationOffset,
            parentBoneIndex: sb.parentBoneIndex,
            attachedAt: sb.attachedAt,
            parentAttach: sb.parentAttach
          });
        });
        ensureBonesOverlay();
        drawBonesOverlay();
      }
      
      // Restore onion skin state if it was different
      if (onionSkinState !== onionSkinEnabled) {
        onionSkinEnabled = onionSkinState;
        updateOnionSkin();
      }
      
      // Restore Cut Out Mode if snapshot present
      if (state.cutout) {
        try {
          if (state.cutout.propKeys) {
            cutoutPropertyKeys = {
              position: Array.isArray(state.cutout.propKeys.position) ? state.cutout.propKeys.position.map(k => ({ time: k.time, x: k.x, y: k.y })) : [],
              zoom: Array.isArray(state.cutout.propKeys.zoom) ? state.cutout.propKeys.zoom.map(k => ({ time: k.time, sx: k.sx, sy: k.sy })) : [],
              rotation: Array.isArray(state.cutout.propKeys.rotation) ? state.cutout.propKeys.rotation.map(k => ({ time: k.time, deg: k.deg })) : [],
              opacity: Array.isArray(state.cutout.propKeys.opacity) ? state.cutout.propKeys.opacity.map(k => ({ time: k.time, value: k.value })) : []
            };
          }
          if (Array.isArray(state.cutout.keys)) {
            cutoutKeys = state.cutout.keys.map(k => ({ time: k.time }));
          }
          if (typeof state.cutout.duration === 'number') {
            cutoutDuration = state.cutout.duration;
          }
          if (typeof state.cutout.currentTime === 'number') {
            cutoutCurrentTime = state.cutout.currentTime;
          }
          selectedCutoutClipIndex = (typeof state.cutout.selectedIndex === 'number') ? state.cutout.selectedIndex : -1;
          // Rebuild clips with offscreen canvases
          cutoutClips = [];
          // Determine target dimensions for clip canvases
          let targetClipW = 1920, targetClipH = 1080;
          if (cutoutCanvas && cutoutCanvas.width > 0 && cutoutCanvas.height > 0) {
            targetClipW = cutoutCanvas.width;
            targetClipH = cutoutCanvas.height;
          } else if (typeof getTargetCanvasSizeForViewport === 'function' && typeof currentViewport !== 'undefined') {
            const target = getTargetCanvasSizeForViewport(currentViewport);
            targetClipW = target.width || 1920;
            targetClipH = target.height || 1080;
          } else if (canvases && canvases[0] && canvases[0].width > 0 && canvases[0].height > 0) {
            targetClipW = canvases[0].width;
            targetClipH = canvases[0].height;
          }
          if (Array.isArray(state.cutout.clips)) {
            state.cutout.clips.forEach((c) => {
              const off = document.createElement('canvas');
              // Set initial dimensions from saved state or target dimensions
              off.width = (c.width && c.width > 0) ? c.width : targetClipW;
              off.height = (c.height && c.height > 0) ? c.height : targetClipH;
              const offCtx = off.getContext('2d', { willReadFrequently: true });
              const clipObj = { start: c.start, end: c.end, canvas: off, ctx: offCtx, dataUrl: c.dataUrl || null };
              if (c.dataUrl) {
                const img = new Image();
                img.onload = () => {
                  // Use image dimensions if available, otherwise keep target dimensions
                  const imgW = img.naturalWidth || img.width;
                  const imgH = img.naturalHeight || img.height;
                  // Only resize if image has valid dimensions and they differ
                  if (imgW > 0 && imgH > 0 && (off.width !== imgW || off.height !== imgH)) {
                    off.width = imgW;
                    off.height = imgH;
                  }
                  offCtx.clearRect(0, 0, off.width, off.height);
                  offCtx.drawImage(img, 0, 0);
                  if (typeof renderCutoutClips === 'function') renderCutoutClips();
                  if (typeof renderCutoutPreviewForTime === 'function') renderCutoutPreviewForTime();
                };
                img.src = c.dataUrl;
              }
              // Restore animated objects if present
              if (Array.isArray(c.objects)) {
                clipObj.objects = c.objects.map((o) => {
                  const oimg = new Image();
                  const baseObj = {
                    id: o.id,
                    name: o.name,
                    color: o.color,
                    src: o.src,
                    layerIndex: Number.isFinite(o.layerIndex) ? o.layerIndex : 0,
                    img: oimg,
                    isImage: true,
                    x: Number.isFinite(o.x) ? o.x : 0,
                    y: Number.isFinite(o.y) ? o.y : 0,
                    scale: Number.isFinite(o.scale) ? o.scale : 1,
                    scaleX: Number.isFinite(o.scaleX) ? o.scaleX : 1,
                    scaleY: Number.isFinite(o.scaleY) ? o.scaleY : 1,
                    rotation: Number.isFinite(o.rotation) ? o.rotation : 0,
                    opacity: Number.isFinite(o.opacity) ? o.opacity : 1,
                    drawW: o.drawW,
                    drawH: o.drawH,
                    keys: {
                      position: Array.isArray(o.keys && o.keys.position) ? o.keys.position.map(k => ({ time: k.time, x: k.x, y: k.y })) : [],
                      zoom: Array.isArray(o.keys && o.keys.zoom) ? o.keys.zoom.map(k => ({ time: k.time, sx: k.sx, sy: k.sy })) : [],
                      rotation: Array.isArray(o.keys && o.keys.rotation) ? o.keys.rotation.map(k => ({ time: k.time, deg: k.deg })) : [],
                      opacity: Array.isArray(o.keys && o.keys.opacity) ? o.keys.opacity.map(k => ({ time: k.time, value: k.value })) : []
                    }
                  };
                  oimg.onload = () => {
                    if (typeof renderCutoutPreviewForTime === 'function') renderCutoutPreviewForTime();
                  };
                  oimg.src = o.src;
                  return baseObj;
                });
              }
              cutoutClips.push(clipObj);
            });
          }
          if (typeof drawCutoutTimeline === 'function') drawCutoutTimeline();
          if (typeof updateRowKeyActiveStates === 'function') updateRowKeyActiveStates();
          if (typeof updateCutoutScrubber === 'function') updateCutoutScrubber();
          if (typeof renderCutoutClips === 'function') renderCutoutClips();
          if (typeof renderCutoutPreviewForTime === 'function') renderCutoutPreviewForTime();
          // Restore Cut Out bones if present
          try {
            cutoutBones = [];
            if (Array.isArray(state.cutout.bones)) {
              state.cutout.bones.forEach((sb) => {
                if (!sb) { cutoutBones.push(null); return; }
                const clip = cutoutClips[sb.clipIndex];
                const obj = (clip && Array.isArray(clip.objects) && sb.objectIndex >= 0) ? clip.objects[sb.objectIndex] : null;
                cutoutBones.push({
                  clipIndex: sb.clipIndex,
                  objectRef: obj || null,
                  startX: sb.startX, startY: sb.startY, endX: sb.endX, endY: sb.endY,
                  restLength: sb.restLength,
                  initialScale: sb.initialScale,
                  restAngle: sb.restAngle,
                  prevAngle: sb.prevAngle,
                  imageRotationOffset: sb.imageRotationOffset,
                  parentBoneIndex: sb.parentBoneIndex,
                  attachedAt: sb.attachedAt,
                  parentAttach: sb.parentAttach,
                  pinnedLocalX: sb.pinnedLocalX,
                  pinnedLocalY: sb.pinnedLocalY,
                  endLocalX: sb.endLocalX,
                  endLocalY: sb.endLocalY
                });
              });
              ensureCutoutBonesOverlay();
              drawCutoutBonesOverlay();
            }
            // Restore preBonePivotStorage
            if (state.cutout.preBonePivotStorage) {
              preBonePivotStorage = JSON.parse(JSON.stringify(state.cutout.preBonePivotStorage));
            } else {
              preBonePivotStorage = {};
            }
          } catch (_e) {}
        } catch (_e) {
          // ignore cutout restore errors
        }
      }
      // After restoring, ensure transient selection/lasso overlays are reset for a clean state
      try {
        isLassoActive = false;
        lassoPoints = [];
        isSelectLassoActive = false;
        selectLassoPoints = [];
        if (typeof lassoOverlayCanvas !== 'undefined' && lassoOverlayCanvas) {
          try { lassoOverlayCanvas.remove(); } catch (_e2) {}
          lassoOverlayCanvas = null;
          lassoOverlayCtx = null;
        }
        if (typeof moveOverlayCanvas !== 'undefined' && moveOverlayCanvas) {
          try { moveOverlayCanvas.remove(); } catch (_e3) {}
          moveOverlayCanvas = null;
          moveOverlayCtx = null;
        }
        selectedImageObject = null;
        isDraggingImage = false;
        isResizingImage = false;
        isRotatingImage = false;
        activeTransformHandle = null;
      } catch (_e) {}
    }

    function updateHistoryButtons() {
      const undoButton = document.getElementById('undo-btn');
      if (undoButton) {
        undoButton.disabled = history.length <= 1;
      }
      const redoButton = document.getElementById('redo-btn');
      if (redoButton) {
        redoButton.disabled = redoStack.length === 0;
      }
    }

    function selectFrame(index, event) {
      // Handle copy/paste functionality
      if (event && event.ctrlKey) {
        if (copiedFrameData && copiedFrameIndex !== -1) {
          // Paste operation
          pasteFrame(index);
          showCopyPasteFeedback('Pasted frame ' + (copiedFrameIndex + 1) + ' to frame ' + (index + 1));
        } else {
          // Copy operation
          copyFrame(index);
          showCopyPasteFeedback('Copied frame ' + (index + 1));
        }
        return; // Don't switch frames during copy/paste
      }
      
      // Only do essential cleanup if not drawing
      if (!isDrawing) {
        // Clean up lasso overlay when switching frames
        if (lassoOverlayCanvas) {
          lassoOverlayCanvas.remove();
          lassoOverlayCanvas = null;
          lassoOverlayCtx = null;
          isLassoActive = false;
          lassoPoints = [];
        }
        // Clean up bones overlays when switching frames
        if (bonesOverlayCanvas) {
          bonesOverlayCanvas.remove();
          bonesOverlayCanvas = null;
          bonesOverlayCtx = null;
        }
        isBoneLassoActive = false;
        boneLassoPoints = [];
        // Clean up move overlay when switching frames
        if (moveOverlayCanvas) {
          moveOverlayCanvas.remove();
          moveOverlayCanvas = null;
          moveOverlayCtx = null;
        }
        dragBaseCanvas = null;
        dragBaseCtx = null;
        selectedImageObject = null;
        isDraggingImage = false;
        isResizingImage = false;
        isRotatingImage = false;
        activeTransformHandle = null;
      }
      
      // Instant frame switch - only essential updates
      currentFrame = index;
      document.querySelectorAll('.canvas-container').forEach((el, i) => {
        el.classList.toggle('active', i === index);
      });
      document.querySelectorAll('.timeline-frame').forEach((el, i) => {
        el.classList.toggle('active', i === index);
      });
      document.getElementById('current-frame-info').textContent = index + 1;
      
      // Defer non-essential updates to avoid delay
      if (!isDrawing) {
        requestAnimationFrame(() => {
          updateLayersList();
          updateOnionSkin();
          updateFrameLabel();
          updateTimelineRuler();
        });
      }
    }

    // Copy/paste functionality for frames (copies full drawing content)
    function copyFrame(frameIndex) {
      // Capture raster content per layer and image metadata
      const layers = frameLayers[frameIndex].map(layer => ({
        dataURL: layer.canvas.toDataURL(),
        visible: !!layer.visible,
        opacity: layer.opacity,
        color: layer.color,
        images: Array.isArray(layer.images) ? layer.images.map(obj => ({
          src: obj.src,
          x: obj.x,
          y: obj.y,
          scale: obj.scale,
          rotation: obj.rotation || 0
        })) : []
      }));
      copiedFrameData = { layers };
      copiedFrameIndex = frameIndex;
    }

    function pasteFrame(targetFrameIndex) {
      if (!copiedFrameData || copiedFrameIndex === -1) return;
      saveState();
      
      const targetSize = getTargetCanvasSizeForViewport(currentViewport);
      const layersData = copiedFrameData.layers || [];
      
      // Rebuild target frame's layers to match source
      frameLayers[targetFrameIndex] = [];
      layersData.forEach(srcLayer => {
        const layerCanvas = document.createElement('canvas');
        layerCanvas.width = targetSize.width;
        layerCanvas.height = targetSize.height;
        const layerCtx = layerCanvas.getContext('2d', { willReadFrequently: true });
        layerCtx.imageSmoothingEnabled = true;
        layerCtx.imageSmoothingQuality = 'high';
        
        const newLayer = {
          canvas: layerCanvas,
          ctx: layerCtx,
          visible: srcLayer.visible,
          opacity: srcLayer.opacity,
          color: srcLayer.color,
          images: []
        };
        frameLayers[targetFrameIndex].push(newLayer);
        
        // Restore raster pixels
        if (srcLayer.dataURL) {
          const img = new Image();
          img.onload = () => {
            layerCtx.clearRect(0, 0, layerCanvas.width, layerCanvas.height);
            layerCtx.drawImage(img, 0, 0);
            composeLayers(targetFrameIndex);
            updateThumbnail(targetFrameIndex);
          };
          img.src = srcLayer.dataURL;
        }
        
        // Restore image objects
        if (Array.isArray(srcLayer.images)) {
          srcLayer.images.forEach(obj => {
            if (!obj || !obj.src) return;
            const img = new Image();
            img.onload = () => {
              composeLayers(targetFrameIndex);
              updateThumbnail(targetFrameIndex);
            };
            img.src = obj.src;
            newLayer.images.push({ img, src: obj.src, x: obj.x, y: obj.y, scale: obj.scale, rotation: obj.rotation || 0 });
          });
        }
      });
      
      // Compose immediately for responsiveness
      composeLayers(targetFrameIndex);
      updateThumbnail(targetFrameIndex);
      if (targetFrameIndex === currentFrame) {
        updateLayersList();
      }
    }

    function pasteFrameToAllFrames() {
      if (!copiedFrameData || copiedFrameIndex === -1) return;
      for (let i = 0; i < 6; i++) {
        pasteFrame(i);
      }
    }

    function showCopyPasteFeedback(message) {
      // Create or update feedback element
      let feedback = document.getElementById('copy-paste-feedback');
      if (!feedback) {
        feedback = document.createElement('div');
        feedback.id = 'copy-paste-feedback';
        feedback.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: #1f2937;
          color: white;
          padding: 12px 20px;
          border-radius: 8px;
          font-size: 14px;
          font-weight: 500;
          z-index: 10000;
          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
          transition: opacity 0.3s ease;
        `;
        document.body.appendChild(feedback);
      }
      
      feedback.textContent = message;
      feedback.style.opacity = '1';
      
      // Hide after 2 seconds
      setTimeout(() => {
        feedback.style.opacity = '0';
        setTimeout(() => {
          if (feedback.parentNode) {
            feedback.parentNode.removeChild(feedback);
          }
        }, 300);
      }, 2000);
    }

    // Comprehensive Safari-compatible context menu system
    let isRightClicking = false;
    let rightClickTimer = null;
    
    // Detect Safari browser
    const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    
    // Add comprehensive CSS to disable all default behaviors
    const contextMenuStyle = document.createElement('style');
    contextMenuStyle.textContent = `
      .timeline-frame {
        -webkit-user-select: none !important;
        -moz-user-select: none !important;
        -ms-user-select: none !important;
        user-select: none !important;
        -webkit-touch-callout: none !important;
        -webkit-tap-highlight-color: transparent !important;
        -webkit-context-menu: none !important;
        -moz-context-menu: none !important;
        context-menu: none !important;
      }
      
      .timeline-frame * {
        -webkit-user-select: none !important;
        -moz-user-select: none !important;
        -ms-user-select: none !important;
        user-select: none !important;
        -webkit-touch-callout: none !important;
        -webkit-tap-highlight-color: transparent !important;
      }
      
      /* Disable default context behaviors on main canvas containers as well */
      .canvas-container {
        -webkit-user-select: none !important;
        -moz-user-select: none !important;
        -ms-user-select: none !important;
        user-select: none !important;
        -webkit-touch-callout: none !important;
        -webkit-tap-highlight-color: transparent !important;
        -webkit-context-menu: none !important;
        -moz-context-menu: none !important;
        context-menu: none !important;
      }
      .canvas-container * {
        -webkit-user-select: none !important;
        -moz-user-select: none !important;
        -ms-user-select: none !important;
        user-select: none !important;
        -webkit-touch-callout: none !important;
        -webkit-tap-highlight-color: transparent !important;
      }
    `;
    document.head.appendChild(contextMenuStyle);
    
    // Custom context menu function
    function showFrameContextMenu(event, frameIndex) {
      console.log('Custom context menu triggered for frame:', frameIndex);
      
      // Remove any existing context menu
      const existingMenu = document.getElementById('frame-context-menu');
      if (existingMenu) {
        existingMenu.remove();
      }
      
      // Create context menu
      const menu = document.createElement('div');
      menu.id = 'frame-context-menu';
      menu.style.cssText = `
        position: fixed;
        left: ${event.clientX}px;
        top: ${event.clientY}px;
        background: #0f172a;
        color: #e5e7eb;
        border: 1px solid #1f2937;
        border-radius: 10px;
        box-shadow: 0 20px 50px rgba(0, 0, 0, 0.45);
        z-index: 999999;
        min-width: 190px;
        overflow: hidden;
        pointer-events: auto;
      `;
      
      // Copy option
      const copyOption = document.createElement('div');
      copyOption.style.cssText = `
        padding: 12px 16px;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 14px;
        color: #e5e7eb;
        transition: background-color 0.15s ease;
        pointer-events: auto;
      `;
      copyOption.innerHTML = `
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <rect width="14" height="14" x="8" y="8" rx="2" ry="2"/>
          <path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"/>
        </svg>
        Copy Frame
      `;
      copyOption.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        copyFrame(frameIndex);
        showCopyPasteFeedback(`Copied frame ${frameIndex + 1}`);
        menu.remove();
      });
      copyOption.addEventListener('mouseenter', () => {
        copyOption.style.backgroundColor = '#111827';
      });
      copyOption.addEventListener('mouseleave', () => {
        copyOption.style.backgroundColor = 'transparent';
      });
      
      // Paste option
      const pasteOption = document.createElement('div');
      pasteOption.style.cssText = `
        padding: 12px 16px;
        cursor: ${copiedFrameData ? 'pointer' : 'not-allowed'};
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 14px;
        color: ${copiedFrameData ? '#e5e7eb' : '#6b7280'};
        transition: background-color 0.15s ease;
        pointer-events: auto;
      `;
      pasteOption.innerHTML = `
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"/>
          <rect width="8" height="4" x="8" y="2" rx="1" ry="1"/>
        </svg>
        Paste Frame
      `;
      
      if (copiedFrameData) {
        pasteOption.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          pasteFrame(frameIndex);
          showCopyPasteFeedback(`Pasted frame ${copiedFrameIndex + 1} to frame ${frameIndex + 1}`);
          menu.remove();
        });
        pasteOption.addEventListener('mouseenter', () => {
          pasteOption.style.backgroundColor = '#111827';
        });
        pasteOption.addEventListener('mouseleave', () => {
          pasteOption.style.backgroundColor = 'transparent';
        });
      }
      
      // Paste to all frames option
      const pasteAllOption = document.createElement('div');
      pasteAllOption.style.cssText = `
        padding: 12px 16px;
        cursor: ${copiedFrameData ? 'pointer' : 'not-allowed'};
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 14px;
        color: ${copiedFrameData ? '#e5e7eb' : '#6b7280'};
        transition: background-color 0.15s ease;
        pointer-events: auto;
      `;
      pasteAllOption.innerHTML = `
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"/>
          <rect width="8" height="4" x="8" y="2" rx="1" ry="1"/>
        </svg>
        Paste to All Frames
      `;
      if (copiedFrameData) {
        pasteAllOption.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          pasteFrameToAllFrames();
          showCopyPasteFeedback('Pasted copied frame to all frames');
          menu.remove();
        });
        pasteAllOption.addEventListener('mouseenter', () => {
          pasteAllOption.style.backgroundColor = '#111827';
        });
        pasteAllOption.addEventListener('mouseleave', () => {
          pasteAllOption.style.backgroundColor = 'transparent';
        });
      }

      // Divider helper
      const divider = () => {
        const hr = document.createElement('div');
        hr.style.cssText = 'height:1px;background:#1f2937;margin:4px 0;';
        return hr;
      };
      
      // Delete frame option
      const deleteOption = document.createElement('div');
      deleteOption.style.cssText = `
        padding: 12px 16px;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 14px;
        color: #fca5a5;
        transition: background-color 0.15s ease;
        pointer-events: auto;
      `;
      deleteOption.innerHTML = `
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M3 6h18"/>
          <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6"/>
          <path d="M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
        </svg>
        Delete Frame
      `;
      deleteOption.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        deleteFrameAt(frameIndex);
        if (typeof showCopyPasteFeedback === 'function') {
          showCopyPasteFeedback(`Deleted frame ${frameIndex + 1}`);
        }
        menu.remove();
      });
      deleteOption.addEventListener('mouseenter', () => {
        deleteOption.style.backgroundColor = '#111827';
      });
      deleteOption.addEventListener('mouseleave', () => {
        deleteOption.style.backgroundColor = 'transparent';
      });
      
      // Download frame option
      const downloadOption = document.createElement('div');
      downloadOption.style.cssText = `
        padding: 12px 16px;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 14px;
        color: #e5e7eb;
        transition: background-color 0.15s ease;
        pointer-events: auto;
      `;
      downloadOption.innerHTML = `
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
          <path d="M7 10l5 5 5-5"/>
          <path d="M12 15V3"/>
        </svg>
        Download PNG
      `;
      downloadOption.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        downloadFramePng(frameIndex);
        menu.remove();
      });
      downloadOption.addEventListener('mouseenter', () => {
        downloadOption.style.backgroundColor = '#111827';
      });
      downloadOption.addEventListener('mouseleave', () => {
        downloadOption.style.backgroundColor = 'transparent';
      });
      
      menu.appendChild(copyOption);
      menu.appendChild(pasteOption);
      menu.appendChild(pasteAllOption);
      menu.appendChild(divider());
      menu.appendChild(deleteOption);
      menu.appendChild(downloadOption);
      document.body.appendChild(menu);
      
      // Close menu when clicking outside
      const closeMenu = (e) => {
        if (!menu.contains(e.target)) {
          menu.remove();
          document.removeEventListener('click', closeMenu);
          document.removeEventListener('contextmenu', closeMenu);
          document.removeEventListener('keydown', onKeyDownClose);
        }
      };
      
      // Close on Escape key
      const onKeyDownClose = (e) => {
        if (e.key === 'Escape') {
          menu.remove();
          document.removeEventListener('click', closeMenu);
          document.removeEventListener('contextmenu', closeMenu);
          document.removeEventListener('keydown', onKeyDownClose);
        }
      };
      
      setTimeout(() => {
        document.addEventListener('click', closeMenu);
        document.addEventListener('contextmenu', closeMenu);
        document.addEventListener('keydown', onKeyDownClose);
      }, 10);
    }
    
    // Comprehensive event handling system
    function setupTimelineFrameEvents() {
      // Remove all existing event listeners first
      document.removeEventListener('contextmenu', handleGlobalContextMenu, true);
      document.removeEventListener('mousedown', handleGlobalMouseDown, true);
      document.removeEventListener('mouseup', handleGlobalMouseUp, true);
      document.removeEventListener('auxclick', handleGlobalAuxClick, true);
      
      // Add comprehensive event listeners
      document.addEventListener('contextmenu', handleGlobalContextMenu, true);
      document.addEventListener('mousedown', handleGlobalMouseDown, true);
      document.addEventListener('mouseup', handleGlobalMouseUp, true);
      document.addEventListener('auxclick', handleGlobalAuxClick, true);
      document.addEventListener('mousemove', handleGlobalMouseMove, true);
    }
    
    // Global context menu handler
    function handleGlobalContextMenu(event) {
      const timelineFrame = event.target.closest('.timeline-frame');
      const canvasContainer = event.target.closest('.canvas-container');
      if (timelineFrame || canvasContainer) {
        event.preventDefault();
        event.stopPropagation();
        event.stopImmediatePropagation();
        
        let frameIndex = -1;
        if (timelineFrame) {
          const frameId = timelineFrame.id;
          frameIndex = parseInt(frameId.replace('timeline-', ''));
        } else if (canvasContainer) {
          // Determine frame index from container or child canvas
          const containerId = canvasContainer.id || '';
          if (containerId.startsWith('frame-container-')) {
            frameIndex = parseInt(containerId.replace('frame-container-', ''));
          } else {
            const childCanvas = canvasContainer.querySelector('canvas[id^="canvas-"]');
            if (childCanvas) {
              frameIndex = parseInt(childCanvas.id.replace('canvas-', ''));
            } else {
              frameIndex = typeof currentFrame === 'number' ? currentFrame : 0;
            }
          }
        }
        if (frameIndex < 0 || Number.isNaN(frameIndex)) {
          frameIndex = typeof currentFrame === 'number' ? currentFrame : 0;
        }
        showFrameContextMenu(event, frameIndex);
        return false;
      }
    }
    
    // Global mouse down handler for right-click detection
    function handleGlobalMouseDown(event) {
      const timelineFrame = event.target.closest('.timeline-frame');
      const canvasContainer = event.target.closest('.canvas-container');
      if (timelineFrame || canvasContainer) {
        if (event.button === 2) {
          isRightClicking = true;
          event.preventDefault();
          event.stopPropagation();
          event.stopImmediatePropagation();
          
          if (rightClickTimer) {
            clearTimeout(rightClickTimer);
          }
          
          rightClickTimer = setTimeout(() => {
            let frameIndex = -1;
            if (timelineFrame) {
              const frameId = timelineFrame.id;
              frameIndex = parseInt(frameId.replace('timeline-', ''));
            } else if (canvasContainer) {
              const containerId = canvasContainer.id || '';
              if (containerId.startsWith('frame-container-')) {
                frameIndex = parseInt(containerId.replace('frame-container-', ''));
              } else {
                const childCanvas = canvasContainer.querySelector('canvas[id^="canvas-"]');
                if (childCanvas) {
                  frameIndex = parseInt(childCanvas.id.replace('canvas-', ''));
                } else {
                  frameIndex = typeof currentFrame === 'number' ? currentFrame : 0;
                }
              }
            }
            if (frameIndex < 0 || Number.isNaN(frameIndex)) {
              frameIndex = typeof currentFrame === 'number' ? currentFrame : 0;
            }
            showFrameContextMenu(event, frameIndex);
            isRightClicking = false;
          }, 50);
          
          return false;
        }
      }
    }
    
    // Global mouse up handler
    function handleGlobalMouseUp(event) {
      if (isRightClicking && event.button === 2) {
        event.preventDefault();
        event.stopPropagation();
        event.stopImmediatePropagation();
        isRightClicking = false;
        return false;
      }
    }
    
    // Global auxclick handler (for right-click)
    function handleGlobalAuxClick(event) {
      const timelineFrame = event.target.closest('.timeline-frame');
      const canvasContainer = event.target.closest('.canvas-container');
      if ((timelineFrame || canvasContainer) && event.button === 2) {
        event.preventDefault();
        event.stopPropagation();
        event.stopImmediatePropagation();
        
        let frameIndex = -1;
        if (timelineFrame) {
          const frameId = timelineFrame.id;
          frameIndex = parseInt(frameId.replace('timeline-', ''));
        } else if (canvasContainer) {
          const containerId = canvasContainer.id || '';
          if (containerId.startsWith('frame-container-')) {
            frameIndex = parseInt(containerId.replace('frame-container-', ''));
          } else {
            const childCanvas = canvasContainer.querySelector('canvas[id^="canvas-"]');
            if (childCanvas) {
              frameIndex = parseInt(childCanvas.id.replace('canvas-', ''));
            } else {
              frameIndex = typeof currentFrame === 'number' ? currentFrame : 0;
            }
          }
        }
        if (frameIndex < 0 || Number.isNaN(frameIndex)) {
          frameIndex = typeof currentFrame === 'number' ? currentFrame : 0;
        }
        showFrameContextMenu(event, frameIndex);
        return false;
      }
    }
    
    // Global mousemove handler for seamless drawing across frames
    function handleGlobalMouseMove(event) {
      if (!isDrawing) return;
      
      // Check if mouse is over any canvas
      const canvas = event.target.closest('canvas');
      if (!canvas || !canvases.includes(canvas)) return;
      
      const frameIndex = canvases.indexOf(canvas);
      if (frameIndex !== currentFrame) {
        // Switch frame instantly if different
        currentFrame = frameIndex;
        document.querySelectorAll('.canvas-container').forEach((el, i) => {
          el.classList.toggle('active', i === frameIndex);
        });
        document.querySelectorAll('.timeline-frame').forEach((el, i) => {
          el.classList.toggle('active', i === frameIndex);
        });
        document.getElementById('current-frame-info').textContent = frameIndex + 1;
      }
      
      // Continue drawing
      draw(event);
    }
    
    // Initialize the event system
    setupTimelineFrameEvents();

    // Clear all layers in a frame (delete drawing) and refresh
    function clearEntireFrame(frameIndex) {
      saveState();
      const layers = frameLayers[frameIndex] || [];
      layers.forEach(layer => {
        if (!layer || !layer.ctx || !layer.canvas) return;
        layer.ctx.clearRect(0, 0, layer.canvas.width, layer.canvas.height);
        if (Array.isArray(layer.images)) layer.images = [];
      });
      composeLayers(frameIndex);
      updateThumbnail(frameIndex);
      if (frameIndex === currentFrame) {
        updateOnionSkin();
      }
    }

    // Download composed frame as PNG
    function downloadFramePng(frameIndex) {
      composeLayers(frameIndex);
      const canvas = canvases[frameIndex];
      if (!canvas) return;
      const data = canvas.toDataURL('image/png');
      const link = document.createElement('a');
      link.href = data;
      link.download = `frame-${frameIndex + 1}.png`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }

    function setTool(tool) {
      // If a cutout selection exists, only commit when leaving select tools (keep overlay when switching into select)
      if (tool !== currentTool && cutoutSelectedObject) {
        if (currentTool === 'select' || currentTool === 'select-lasso') {
          try { cutoutCommitSelection(); } catch (e) {}
          try { renderCutoutPreviewForTime(); } catch (_e) {}
        }
      }
      // Clean up lasso overlay if switching away from lasso
      if (currentTool === 'lasso' && lassoOverlayCanvas) {
        lassoOverlayCanvas.remove();
        lassoOverlayCanvas = null;
        lassoOverlayCtx = null;
        isLassoActive = false;
        lassoPoints = [];
      }
      // Clean up bones overlays if switching away from bones
      if (currentTool === 'bones') {
        if (lassoOverlayCanvas) {
          lassoOverlayCanvas.remove();
          lassoOverlayCanvas = null;
          lassoOverlayCtx = null;
        }
        isBoneLassoActive = false;
        boneLassoPoints = [];
        isDraggingBoneHandle = false;
        boneDrag = null;
        selectedBoneIndex = -1;
        if (bonesOverlayCanvas) {
          bonesOverlayCanvas.remove();
          bonesOverlayCanvas = null;
          bonesOverlayCtx = null;
        }
        // Cutout bones cleanup as well
        cutoutIsBoneLassoActive = false;
        cutoutBoneLassoPoints = [];
        cutoutIsDraggingBoneHandle = false;
        cutoutBoneDrag = null;
        cutoutBonesModeObjDrag = null;
        cutoutSelectedBoneIndex = -1;
        if (cutoutBonesOverlayCanvas) {
          cutoutBonesOverlayCanvas.remove();
          cutoutBonesOverlayCanvas = null;
          cutoutBonesOverlayCtx = null;
        }
        
        // Restore original pivot for all objects that had bones attached
        // when switching to regular selection mode
        if (tool === 'select' || tool === 'select-lasso') {
          try {
            for (const objIdStr in preBonePivotStorage) {
              const objId = parseInt(objIdStr, 10);
              const stored = preBonePivotStorage[objId];
              // Find the object across all clips
              for (let ci = 0; ci < cutoutClips.length; ci++) {
                const clip = cutoutClips[ci];
                if (!clip || !Array.isArray(clip.objects)) continue;
                for (let oi = 0; oi < clip.objects.length; oi++) {
                  const obj = clip.objects[oi];
                  if (obj && obj.id === objId) {
                    // Restore original pivot
                    if (stored.pivotLocalX !== undefined) {
                      obj.pivotLocalX = stored.pivotLocalX;
                    } else {
                      delete obj.pivotLocalX;
                    }
                    if (stored.pivotLocalY !== undefined) {
                      obj.pivotLocalY = stored.pivotLocalY;
                    } else {
                      delete obj.pivotLocalY;
                    }
                  }
                }
              }
            }
          } catch (_e) {}
        }
      }
      // Clean up magic lasso if switching away from magic tools
      if (currentTool === 'inbetween' || currentTool === 'detail' || currentTool === 'extend-lasso') {
        if (lassoOverlayCanvas) {
          lassoOverlayCanvas.remove();
          lassoOverlayCanvas = null;
          lassoOverlayCtx = null;
        }
        isMagicLassoActive = false;
        magicLassoPoints = [];
        magicLassoMode = null;
      }
      // If switching away from select, clear any selection and overlays/handles
      if (currentTool === 'select') {
        // Clear select-lasso in-progress visuals
        if (lassoOverlayCanvas) {
          lassoOverlayCanvas.remove();
          lassoOverlayCanvas = null;
          lassoOverlayCtx = null;
        }
        isSelectLassoActive = false;
        selectLassoPoints = [];

        // Clear selection and remove transform handles overlay
        if (selectedImageObject) {
          // First remove the overlay so base compose includes the selected image (prevents one-frame flicker)
          endImageDrag();
          // Ensure latest transforms are reflected in composition before deselect
          try {
            composeLayers(currentFrame);
            updateThumbnail(currentFrame);
          } catch (_e) {}
          selectedImageObject = null;
        } else {
          endImageDrag();
        }
        isDraggingImage = false;
        isResizingImage = false;
        isRotatingImage = false;
        // Cutout: commit active selection if any when leaving select
        if (cutoutSelectedObject) {
          cutoutCommitSelection();
        }
      }
      
      currentTool = tool;
      document.querySelectorAll('.tool-btn').forEach(btn => {
        btn.classList.remove('active');
      });
      let toolBtn = document.getElementById(`${tool}-btn`);
      // Map special-case tool IDs (e.g., eraser lasso uses 'eraser-lasso-btn' for tool 'lasso')
      if (!toolBtn && tool === 'lasso') {
        toolBtn = document.getElementById('eraser-lasso-btn');
      }
      if (toolBtn) toolBtn.classList.add('active');
      document.getElementById('status-text').textContent = `Tool: ${tool.charAt(0).toUpperCase() + tool.slice(1)}`;
      
      // Update cursor style based on tool
      const canvasContainers = document.querySelectorAll('.canvas-container');
      canvasContainers.forEach(container => {
        if (tool === 'color-picker') {
          container.style.cursor = 'crosshair';
        } else if (tool === 'select') {
          container.style.cursor = 'default';
        } else {
          container.style.cursor = 'crosshair';
        }
      });

      // When switching INTO bones, make sure select overlay is removed
      if (tool === 'bones') {
        // Arm bones lasso drawing on explicit tool click
        cutoutBonesDrawArmed = true;
        if (moveOverlayCanvas) {
          moveOverlayCanvas.remove();
          moveOverlayCanvas = null;
          moveOverlayCtx = null;
        }
        
        // Restore bone positions from local coordinates when switching to bones mode
        // This handles the case where objects were moved/rotated in select mode
        try {
          for (let bi = 0; bi < cutoutBones.length; bi++) {
            const bone = cutoutBones[bi];
            if (!bone || !bone.objectRef) continue;
            const obj = bone.objectRef;
            
            // Get object dimensions
            const baseW = (obj.drawW != null) ? obj.drawW : ((obj.img && (obj.img.naturalWidth || obj.img.width)) || 0);
            const baseH = (obj.drawH != null) ? obj.drawH : ((obj.img && (obj.img.naturalHeight || obj.img.height)) || 0);
            const effScaleX = (typeof obj.scaleX === 'number' ? obj.scaleX : 1);
            const effScaleY = (typeof obj.scaleY === 'number' ? obj.scaleY : 1);
            const objW = baseW * (obj.scale || 1) * effScaleX;
            const objH = baseH * (obj.scale || 1) * effScaleY;
            const objCenterX = obj.x + objW / 2;
            const objCenterY = obj.y + objH / 2;
            const rot = obj.rotation || 0;
            const cos = Math.cos(rot), sin = Math.sin(rot);
            
            // Restore start position from pinnedLocalX/Y
            if (typeof bone.pinnedLocalX === 'number' && typeof bone.pinnedLocalY === 'number') {
              const rx = bone.pinnedLocalX * cos - bone.pinnedLocalY * sin;
              const ry = bone.pinnedLocalX * sin + bone.pinnedLocalY * cos;
              bone.startX = objCenterX + rx;
              bone.startY = objCenterY + ry;
            }
            
            // Restore end position from endLocalX/Y
            if (typeof bone.endLocalX === 'number' && typeof bone.endLocalY === 'number') {
              const rxEnd = bone.endLocalX * cos - bone.endLocalY * sin;
              const ryEnd = bone.endLocalX * sin + bone.endLocalY * cos;
              bone.endX = objCenterX + rxEnd;
              bone.endY = objCenterY + ryEnd;
            }
            
            // Update rest length after position restore
            bone.restLength = Math.hypot(bone.endX - bone.startX, bone.endY - bone.startY);
          }
        } catch (_e) {}
        
        // Ensure bones overlay is visible to allow moving bones without accidental new lasso
        try { ensureCutoutBonesOverlay(); drawCutoutBonesOverlay(); } catch (_e) {}
      }
      // When switching INTO magic tools (including eraser lasso), clear selection overlays
      if (tool === 'inbetween' || tool === 'detail' || tool === 'extend-lasso' || tool === 'lasso') {
        if (moveOverlayCanvas) {
          moveOverlayCanvas.remove();
          moveOverlayCanvas = null;
          moveOverlayCtx = null;
        }
        // Ensure base canvas is fully composed with all images visible
        try {
          composeLayers(currentFrame);
          updateThumbnail(currentFrame);
        } catch (_e) {}
      }
      updateSelectLassoToggle();
    }

    function updateSelectLassoToggle() {
      const toggle = document.getElementById('select-lasso-toggle');
      if (!toggle) return;
      toggle.classList.toggle('active', !!selectLassoEnabled);
      toggle.setAttribute('aria-checked', selectLassoEnabled ? 'true' : 'false');
      toggle.setAttribute('aria-label', selectLassoEnabled ? 'Select lasso on' : 'Select lasso off');
    }

    function toggleSelectLasso(event) {
      if (event) {
        event.stopPropagation();
        event.preventDefault();
      }
      selectLassoEnabled = !selectLassoEnabled;
      if (!selectLassoEnabled && isSelectLassoActive) {
        if (lassoOverlayCanvas) {
          lassoOverlayCanvas.remove();
          lassoOverlayCanvas = null;
          lassoOverlayCtx = null;
        }
        isSelectLassoActive = false;
        selectLassoPoints = [];
      }
      updateSelectLassoToggle();
      if (currentTool !== 'select') {
        setTool('select');
      }
    }

    // Brush menu functions
    function toggleBrushMenu() {
      const menu = document.getElementById('brush-menu');
      const isHidden = menu.classList.contains('hidden');
      
      // Close other dropdowns first
      document.querySelectorAll('[id$="-menu"]').forEach(m => {
        if (m !== menu) m.classList.add('hidden');
      });
      
      if (isHidden) {
        menu.classList.remove('hidden');
        setTool('brush');
      } else {
        menu.classList.add('hidden');
      }
    }

    function toggleDetailMenu(event) {
      event.stopPropagation();
      const menu = document.getElementById('detail-menu');
      const btn = document.getElementById('detail-btn');
      const isHidden = menu.classList.contains('hidden');
      // Close other dropdowns first
      document.querySelectorAll('[id$="-menu"]').forEach(m => {
        if (m !== menu) m.classList.add('hidden');
      });
      if (isHidden) {
        if (btn) menu.style.width = btn.offsetWidth + 'px';
        updateDetailMenuActive();
        menu.classList.remove('hidden');
      } else {
        menu.classList.add('hidden');
      }
    }

    function selectDetailStyle(style) {
      detailStyle = style;
      const menu = document.getElementById('detail-menu');
      if (menu) menu.classList.add('hidden');
      setTool('detail');
    }

    function updateDetailMenuActive() {
      const options = document.querySelectorAll('.detail-option');
      options.forEach(opt => {
        opt.classList.remove('bg-[#6366f1]', 'text-white');
        opt.classList.add('text-gray-300');
        if (opt.getAttribute('data-style') === detailStyle) {
          opt.classList.add('bg-[#6366f1]', 'text-white');
          opt.classList.remove('text-gray-300');
        }
      });
    }

    function selectBrushType(brushType) {
      currentBrushType = brushType;
      const brushTypeText = document.getElementById('brush-type-text');
      const brushOptions = document.querySelectorAll('.brush-option');
      
      // Update button text
      const brushNames = {
        'brokenCrayon': 'Broken Crayon',
        'oil': 'Oil Paint',
        'basic': 'Basic Brush',
        'necroMist': 'Necro Mist',
        'runeGlyph': 'Rune Glyph',
        'hexSigil': 'Hex Sigil',
        'thornBloom': 'Thorn Bloom',
        'voidScratch': 'Void Scratch',
        'animationPath': 'Animation Path',
        'scratches': 'Scratches'
      };
      brushTypeText.textContent = brushNames[brushType];
      
      // Update active state
      brushOptions.forEach(option => {
        option.classList.remove('bg-[#6366f1]', 'text-white');
        option.classList.add('text-gray-300');
      });
      
      const selectedOption = document.querySelector(`[data-brush="${brushType}"]`);
      if (selectedOption) {
        selectedOption.classList.add('bg-[#6366f1]', 'text-white');
        selectedOption.classList.remove('text-gray-300');
      }
      
      // Close menu
      document.getElementById('brush-menu').classList.add('hidden');
      
      // Set tool to brush
      setTool('brush');
    }

    function drawWithBrushType(ctx, fromX, fromY, toX, toY) {
      const distance = Math.sqrt((toX - fromX) ** 2 + (toY - fromY) ** 2);
      const steps = Math.max(1, Math.floor(distance / 2));
      
      for (let i = 0; i <= steps; i++) {
        const t = i / steps;
        const x = fromX + (toX - fromX) * t;
        const y = fromY + (toY - fromY) * t;
        
        switch (currentBrushType) {
          case 'animationPath': {
            // Route to guides overlay (non-exported)
            const base = canvases[currentFrame];
            if (!base) return;
            // Ensure overlay exists and matches size
            let gCanvas = guideCanvases[currentFrame];
            let gCtx = guideContexts[currentFrame];
            if (!gCanvas || !gCtx || gCanvas.width !== base.width || gCanvas.height !== base.height || !gCanvas.parentElement) {
              // (Re)create overlay
              const container = base.parentElement;
              if (!container) return;
              if (gCanvas && gCanvas.parentElement) gCanvas.parentElement.removeChild(gCanvas);
              gCanvas = document.createElement('canvas');
              gCanvas.id = `guides-${currentFrame}`;
              gCanvas.width = base.width;
              gCanvas.height = base.height;
              gCanvas.style.position = 'absolute';
              gCanvas.style.top = '0';
              gCanvas.style.left = '0';
              gCanvas.style.width = '100%';
              gCanvas.style.height = '100%';
              gCanvas.style.pointerEvents = 'none';
              gCanvas.style.zIndex = '1001';
              gCanvas.style.transformOrigin = 'top left';
              gCanvas.style.transform = `scale(${zoomLevels[currentFrame] || 1})`;
              gCtx = gCanvas.getContext('2d', { willReadFrequently: true });
              container.style.position = 'relative';
              container.appendChild(gCanvas);
              guideCanvases[currentFrame] = gCanvas;
              guideContexts[currentFrame] = gCtx;
            }
            gCtx.save();
            // Fixed turquoise color and low opacity for differentiation
            gCtx.globalAlpha = 0.28;
            gCtx.strokeStyle = '#40E0D0'; // turquoise
            gCtx.lineWidth = Math.max(1, Math.round(brushSize * 0.8));
            gCtx.lineCap = 'round';
            gCtx.lineJoin = 'round';
            // Draw segment from previous sample or a small dot if stationary
            if (i === 0 && distance < 0.001) {
              gCtx.beginPath();
              gCtx.arc(x, y, Math.max(1, gCtx.lineWidth / 2), 0, Math.PI * 2);
              gCtx.fillStyle = '#40E0D0';
              gCtx.fill();
            } else if (i > 0) {
              const px = fromX + (toX - fromX) * ((i - 1) / steps);
              const py = fromY + (toY - fromY) * ((i - 1) / steps);
              gCtx.beginPath();
              gCtx.moveTo(px, py);
              gCtx.lineTo(x, y);
              gCtx.stroke();
            }
            gCtx.restore();
            break;
          }
          case 'brokenCrayon': {
            drawBrokenCrayon(ctx, x, y, fromX, fromY, toX, toY);
            break;
          }
          case 'shade': {
            // Darken only existing strokes (attempt to ignore background)
            // Draw segment with multiply, then undo effect on background-colored pixels within the stroke bbox
            const px = fromX + (toX - fromX) * ((i - 1) / Math.max(1, steps));
            const py = fromY + (toY - fromY) * ((i - 1) / Math.max(1, steps));
            const r = Math.max(2, brushSize);
            const minX = Math.max(0, Math.floor(Math.min(px, x) - r));
            const minY = Math.max(0, Math.floor(Math.min(py, y) - r));
            const maxX = Math.ceil(Math.max(px, x) + r);
            const maxY = Math.ceil(Math.max(py, y) + r);
            const w = Math.max(1, maxX - minX);
            const h = Math.max(1, maxY - minY);
            try {
              const pre = ctx.getImageData(minX, minY, w, h);
              // Shade stroke using fixed black (darken via multiply)
              ctx.save();
              ctx.globalCompositeOperation = 'multiply';
              ctx.strokeStyle = darkerFromCurrentColor(0.25, 0.3);
              ctx.lineWidth = r;
              ctx.lineCap = 'round';
              ctx.lineJoin = 'round';
              if (i === 0 || steps === 1) {
                ctx.beginPath();
                ctx.arc(x, y, r / 2, 0, Math.PI * 2);
                ctx.fillStyle = darkerFromCurrentColor(0.25, 0.3);
                ctx.fill();
              } else {
                ctx.beginPath();
                ctx.moveTo(px, py);
                ctx.lineTo(x, y);
                ctx.stroke();
              }
              ctx.restore();
              // Undo shading on background pixels (#1a1a1a)
              const post = ctx.getImageData(minX, minY, w, h);
              const dataPre = pre.data;
              const dataPost = post.data;
              const bgR = 0x1a, bgG = 0x1a, bgB = 0x1a;
              const tol = 4;
              for (let p = 0; p < dataPost.length; p += 4) {
                const r0 = dataPre[p], g0 = dataPre[p + 1], b0 = dataPre[p + 2], a0 = dataPre[p + 3];
                if (
                  Math.abs(r0 - bgR) <= tol &&
                  Math.abs(g0 - bgG) <= tol &&
                  Math.abs(b0 - bgB) <= tol &&
                  a0 >= 250
                ) {
                  // restore background pixel
                  dataPost[p] = dataPre[p];
                  dataPost[p + 1] = dataPre[p + 1];
                  dataPost[p + 2] = dataPre[p + 2];
                  dataPost[p + 3] = dataPre[p + 3];
                } else if (a0 <= 5) {
                  // fully transparent previously -> don't introduce paint
                  dataPost[p] = dataPre[p];
                  dataPost[p + 1] = dataPre[p + 1];
                  dataPost[p + 2] = dataPre[p + 2];
                  dataPost[p + 3] = dataPre[p + 3];
                }
              }
              ctx.putImageData(post, minX, minY);
            } catch (e) {
              // Fallback: simple multiply stroke
              ctx.save();
              ctx.globalCompositeOperation = 'multiply';
              ctx.strokeStyle = darkerFromCurrentColor(0.25, 0.3);
              ctx.lineWidth = Math.max(2, brushSize);
              ctx.lineCap = 'round';
              ctx.lineJoin = 'round';
              if (i === 0 || steps === 1) {
                ctx.beginPath();
                ctx.arc(x, y, ctx.lineWidth / 2, 0, Math.PI * 2);
                ctx.fillStyle = darkerFromCurrentColor(0.25, 0.3);
                ctx.fill();
              } else {
                ctx.beginPath();
                ctx.moveTo(px, py);
                ctx.lineTo(x, y);
                ctx.stroke();
              }
              ctx.restore();
            }
            break;
          }
          case 'thornBloom':
            drawThornBloom(ctx, x, y, fromX, fromY, toX, toY);
            break;
          case 'runeGlyph':
            drawRuneGlyph(ctx, x, y, fromX, fromY, toX, toY);
            break;
          case 'hexSigil':
            drawHexSigil(ctx, x, y, fromX, fromY, toX, toY);
            break;
          case 'voidScratch':
            drawVoidScratch(ctx, x, y, fromX, fromY, toX, toY);
            break;
          // Spray removed; Grainy Sand replaces it in the menu as texture overlay
          case 'watercolor': // legacy route; replaced by new set
            drawWatercolorBrush(ctx, x, y);
            break;
          case 'oil':
            drawOilBrush(ctx, x, y, fromX, fromY, toX, toY); // enhanced with side smears
            break;
          case 'scratches':
            drawScratchesBrush(ctx, x, y, fromX, fromY, toX, toY);
            break;
          case 'basic':
            drawBasicBrush(ctx, x, y);
            break;
          case 'wind':
            drawWindBrush(ctx, x, y, fromX, fromY, toX, toY);
            applyBrushTexture(ctx, x, y, brushSize, 'paperGrain');
            break;
        }
        // Advance stroke age as we lay down more samples
        brushStrokeAge += 1;
      }
    }

    function drawRoundBrush(ctx, x, y) {
      // Professional round brush with soft edges and pressure sensitivity
      const gradient = ctx.createRadialGradient(x, y, 0, x, y, brushSize / 2);
      gradient.addColorStop(0, currentColor);
      gradient.addColorStop(0.7, currentColor);
      gradient.addColorStop(1, 'transparent');
      
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(x, y, brushSize / 2, 0, Math.PI * 2);
      ctx.fill();
    }

    function drawBrokenCrayon(ctx, x, y, fromX, fromY, toX, toY) {
      // Highly grainy, broken crayon texture: dense speckles + short directional streaks
      const rgb = hexToRgb(currentColor);
      const dirAngle = Math.atan2(toY - fromY, toX - fromX);
      const cosA = Math.cos(dirAngle);
      const sinA = Math.sin(dirAngle);
      // Particle density scales with brush size; clamp to avoid overload
      const particleBase = Math.max(8, Math.min(28, Math.floor(brushSize * 2)));
      const streaks = Math.floor(Math.random() * 3); // short broken streaks
      // Randomized speckles clustered around current point
      for (let p = 0; p < particleBase; p++) {
        const r = (Math.random() ** 1.6) * (brushSize * 0.7); // more points near center
        const a = Math.random() * Math.PI * 2;
        const px = x + Math.cos(a) * r + (Math.random() - 0.5) * 0.4;
        const py = y + Math.sin(a) * r + (Math.random() - 0.5) * 0.4;
        const sz = Math.max(0.6, (Math.random() * brushSize * 0.22));
        const alpha = Math.max(0.1, Math.min(0.5, (0.12 + Math.random() * 0.4)));
        ctx.fillStyle = `rgba(${rgb.r},${rgb.g},${rgb.b},${(brushOpacity * alpha).toFixed(3)})`;
        if (Math.random() < 0.5) {
          ctx.fillRect(px, py, sz, sz);
        } else {
          ctx.beginPath();
          ctx.arc(px, py, sz * 0.6, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      // Add extreme grain: tiny darker-color dots over the pigment
      // Use a higher density than colored speckles for a paper-grit look
      const blackParticles = particleBase * 3;
      // Derive a darker version of the current color (keep hue, reduce brightness)
      const darkFactor = 0.25; // 25% brightness
      const dr = Math.max(0, Math.floor(rgb.r * darkFactor));
      const dg = Math.max(0, Math.floor(rgb.g * darkFactor));
      const db = Math.max(0, Math.floor(rgb.b * darkFactor));
      for (let b = 0; b < blackParticles; b++) {
        const r = (Math.random() ** 1.4) * (brushSize * 0.8);
        const a = Math.random() * Math.PI * 2;
        const px = x + Math.cos(a) * r + (Math.random() - 0.5) * 0.3;
        const py = y + Math.sin(a) * r + (Math.random() - 0.5) * 0.3;
        const sz = Math.max(0.25, Math.random() * Math.max(0.9, brushSize * 0.08));
        const alpha = 0.18 + Math.random() * 0.42; // 0.18..0.60
        ctx.fillStyle = `rgba(${dr},${dg},${db},${(brushOpacity * alpha).toFixed(3)})`;
        // Mix circles and squares for more randomness
        if (Math.random() < 0.65) {
          ctx.fillRect(px, py, sz, sz);
        } else {
          ctx.beginPath();
          ctx.arc(px, py, sz * 0.55, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      // Add a few tiny directional streaks to emulate wax catching paper grooves
      for (let k = 0; k < streaks; k++) {
        const len = Math.max(1.0, brushSize * (0.4 + Math.random() * 0.6));
        const jitter = (Math.random() - 0.5) * brushSize * 0.35;
        const sx = x + (-sinA * jitter);
        const sy = y + (cosA * jitter);
        const lw = Math.max(0.7, brushSize * 0.18 * (0.6 + Math.random() * 0.8));
        const alpha = 0.12 + Math.random() * 0.38;
        ctx.save();
        ctx.globalAlpha = brushOpacity;
        ctx.strokeStyle = `rgba(${rgb.r},${rgb.g},${rgb.b},${alpha.toFixed(3)})`;
        ctx.lineWidth = lw;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(sx, sy);
        ctx.lineTo(sx + cosA * len, sy + sinA * len);
        ctx.stroke();
        ctx.restore();
      }
      // Sparse darker-color micro-scratches
      if (Math.random() < 0.35) {
        const micro = 1 + Math.floor(Math.random() * 2);
        for (let m = 0; m < micro; m++) {
          const len = Math.max(0.6, brushSize * 0.25 * Math.random());
          const jitter = (Math.random() - 0.5) * brushSize * 0.25;
          const sx = x + (-sinA * jitter);
          const sy = y + (cosA * jitter);
          ctx.save();
          ctx.strokeStyle = `rgba(${dr},${dg},${db},${(0.15 + Math.random() * 0.35).toFixed(3)})`;
          ctx.lineWidth = Math.max(0.4, brushSize * 0.06);
          ctx.lineCap = 'round';
          ctx.beginPath();
          ctx.moveTo(sx, sy);
          ctx.lineTo(sx + cosA * len, sy + sinA * len);
          ctx.stroke();
          ctx.restore();
        }
      }
      // Occasionally skip laying pigment to create "broken" gaps
      if (Math.random() < 0.12) {
        return;
      }
    }

    function drawFlatBrush(ctx, x, y, fromX, fromY, toX, toY) {
      // Professional flat brush with texture and directional bristles
      const angle = Math.atan2(toY - fromY, toX - fromX);
      const pressure = Math.min(1, Math.max(0.3, Math.random()));
      const width = brushSize * pressure;
      const height = brushSize * 0.6;
      
      ctx.save();
      ctx.fillStyle = currentColor;
      ctx.translate(x, y);
      ctx.rotate(angle);
      
      // Create bristle texture
      for (let i = 0; i < 8; i++) {
        const bristleX = (Math.random() - 0.5) * width;
        const bristleY = (Math.random() - 0.5) * height;
        const bristleWidth = Math.random() * width * 0.3;
        const bristleHeight = Math.random() * height * 0.8;
        
        ctx.fillRect(bristleX - bristleWidth/2, bristleY - bristleHeight/2, bristleWidth, bristleHeight);
      }
      ctx.restore();
    }

    function drawCalligraphyBrush(ctx, x, y, fromX, fromY, toX, toY) {
      // Rewritten: color-relative textured calligraphy (no black overlays)
      const angle = Math.atan2(toY - fromY, toX - fromX);
      const speed = Math.sqrt((toX - fromX) ** 2 + (toY - fromY) ** 2);
      const pressure = Math.min(1, Math.max(0.2, 1 - speed / 50));
      const width = brushSize * pressure * 1.2;
      const height = Math.max(1, brushSize * 0.42);
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(angle);
      // Base pigment
      ctx.globalAlpha = brushOpacity;
      ctx.fillStyle = currentColor;
      ctx.fillRect(-width / 2, -height / 2, width, height);
      // Internal fiber texture across entire shape (multiply darker shade)
      ctx.globalCompositeOperation = 'multiply';
      ctx.strokeStyle = darkerFromCurrentColor(0.16, 0.28);
      ctx.lineCap = 'round';
      const lines = 8 + Math.floor(brushSize * 0.3);
      for (let i = 0; i < lines; i++) {
        const ly = (Math.random() - 0.5) * height;
        const len = width * (0.6 + Math.random() * 0.8);
        ctx.lineWidth = Math.max(0.6, height * 0.18 * Math.random());
        ctx.beginPath();
        ctx.moveTo(-len / 2, ly);
        ctx.lineTo(len / 2, ly + (Math.random() - 0.5) * (height * 0.25));
        ctx.stroke();
      }
      ctx.restore();
    }

    function drawAirbrush(ctx, x, y) {
      // Rewritten: full-footprint airbrush with soft dot cloud and color-relative grain
      const core = Math.max(2, brushSize * 0.4);
      ctx.save();
      // Core soft fill
      const g = ctx.createRadialGradient(x, y, 0, x, y, brushSize);
      g.addColorStop(0, currentColor);
      g.addColorStop(0.5, currentColor);
      g.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.globalAlpha = brushOpacity * 0.8;
      ctx.fillStyle = g;
      ctx.beginPath(); ctx.arc(x, y, brushSize, 0, Math.PI * 2); ctx.fill();
      // Grain across entire footprint
      ctx.globalCompositeOperation = 'multiply';
      ctx.fillStyle = darkerFromCurrentColor(0.14, 0.3);
      const density = 28 + Math.floor(brushSize * 1.2);
      for (let i = 0; i < density; i++) {
        const a = Math.random() * Math.PI * 2;
        const d = Math.random() * brushSize;
        const sx = x + Math.cos(a) * d, sy = y + Math.sin(a) * d;
        const s = Math.random() * (brushSize * 0.08);
        ctx.beginPath(); ctx.arc(sx, sy, s, 0, Math.PI * 2); ctx.fill();
      }
      ctx.restore();
    }

    function drawMarkerBrush(ctx, x, y) {
      // Rewritten: marker round cap with internal fiber texture
      const r = Math.max(2, brushSize / 2);
      ctx.save();
      // Base
      ctx.globalAlpha = brushOpacity * 0.95;
      ctx.fillStyle = currentColor;
      ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2); ctx.fill();
      // Interior fibers
      ctx.globalCompositeOperation = 'multiply';
      ctx.strokeStyle = darkerFromCurrentColor(0.18, 0.3);
      ctx.lineCap = 'round';
      const lines = 10 + Math.floor(brushSize * 0.25);
      for (let i = 0; i < lines; i++) {
        const a = Math.random() * Math.PI * 2;
        const len = r * (0.6 + Math.random() * 0.8);
        const sx = x + Math.cos(a) * (r * 0.4 * (Math.random() - 0.5));
        const sy = y + Math.sin(a) * (r * 0.4 * (Math.random() - 0.5));
        ctx.lineWidth = Math.max(0.8, r * 0.12 * Math.random());
        ctx.beginPath(); ctx.moveTo(sx - Math.cos(a) * len / 2, sy - Math.sin(a) * len / 2);
        ctx.lineTo(sx + Math.cos(a) * len / 2, sy + Math.sin(a) * len / 2); ctx.stroke();
      }
      ctx.restore();
    }

    function drawChalkBrush(ctx, x, y) {
      // Rewritten: dense chalk with grain across entire footprint
      const r = Math.max(2, brushSize / 2);
      ctx.save();
      // Base soft fill
      ctx.globalAlpha = brushOpacity * 0.9;
      ctx.fillStyle = currentColor;
      ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2); ctx.fill();
      // Gritty interior dots
      ctx.globalCompositeOperation = 'multiply';
      ctx.fillStyle = darkerFromCurrentColor(0.16, 0.28);
      const dots = 18 + Math.floor(brushSize * 1.4);
      for (let i = 0; i < dots; i++) {
        const a = Math.random() * Math.PI * 2;
        const d = Math.sqrt(Math.random()) * r;
        const px = x + Math.cos(a) * d, py = y + Math.sin(a) * d;
        const s = Math.random() * (r * 0.12);
        ctx.beginPath(); ctx.arc(px, py, s, 0, Math.PI * 2); ctx.fill();
      }
      ctx.restore();
    }

    function drawInkBrush(ctx, x, y, fromX, fromY, toX, toY) {
      // Rewritten: rectangular ink stroke with internal darker fibers
      const angle = Math.atan2(toY - fromY, toX - fromX);
      const speed = Math.sqrt((toX - fromX) ** 2 + (toY - fromY) ** 2);
      const pressure = Math.min(1, Math.max(0.15, 1 - speed / 35));
      const width = Math.max(1, brushSize * pressure * 1.4);
      const height = Math.max(1, brushSize * 0.32);
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(angle);
      // Base
      ctx.globalAlpha = brushOpacity;
      ctx.fillStyle = currentColor;
      ctx.fillRect(-width / 2, -height / 2, width, height);
      // Internal fibers
      ctx.globalCompositeOperation = 'multiply';
      ctx.strokeStyle = darkerFromCurrentColor(0.16, 0.28);
      ctx.lineCap = 'round';
      const fibers = 8 + Math.floor(brushSize * 0.25);
      for (let i = 0; i < fibers; i++) {
        const ly = (Math.random() - 0.5) * height;
        const len = width * (0.5 + Math.random() * 0.9);
        ctx.lineWidth = Math.max(0.6, height * 0.18 * Math.random());
        ctx.beginPath(); ctx.moveTo(-len / 2, ly); ctx.lineTo(len / 2, ly + (Math.random()-0.5)*height*0.2); ctx.stroke();
      }
      ctx.restore();
    }

    function drawSprayBrush(ctx, x, y) {
      // Professional spray paint with realistic stencil-like effects
      const particles = 16 + Math.floor(Math.random() * 10);
      ctx.fillStyle = currentColor;
      
      for (let i = 0; i < particles; i++) {
        const angle = Math.random() * Math.PI * 2;
        const distance = Math.random() * brushSize * 2;
        const offsetX = Math.cos(angle) * distance;
        const offsetY = Math.sin(angle) * distance;
        const size = Math.random() * brushSize * 0.5;
        const alpha = Math.random() * 0.6;
        
        ctx.globalAlpha = brushOpacity * alpha;
        ctx.beginPath();
        ctx.arc(x + offsetX, y + offsetY, size, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Add spray mist effect
      for (let i = 0; i < 6; i++) {
        const mistX = (Math.random() - 0.5) * brushSize * 3;
        const mistY = (Math.random() - 0.5) * brushSize * 3;
        const mistSize = Math.random() * brushSize * 0.3;
        
        ctx.globalAlpha = brushOpacity * 0.15;
        ctx.beginPath();
        ctx.arc(x + mistX, y + mistY, mistSize, 0, Math.PI * 2);
        ctx.fill();
      }
      
      ctx.globalAlpha = brushOpacity;
    }

    function drawWatercolorBrush(ctx, x, y) {
      // Rewritten: blotchy watercolor with bleed and darker edge grain
      const r = Math.max(2, brushSize / 2);
      const atten = Math.max(0.15, Math.exp(-brushStrokeAge * 0.05));
      ctx.save();
      // Base blobs
      ctx.fillStyle = currentColor;
      for (let i = 0; i < 8; i++) {
        const dx = (Math.random() - 0.5) * r * 1.4;
        const dy = (Math.random() - 0.5) * r * 1.4;
        const s = Math.random() * (r * 0.9);
        ctx.globalAlpha = brushOpacity * (0.14 + Math.random() * 0.32) * atten;
        ctx.beginPath(); ctx.arc(x + dx, y + dy, s, 0, Math.PI * 2); ctx.fill();
      }
      // Bleed ring
      ctx.globalCompositeOperation = 'multiply';
      ctx.strokeStyle = darkerFromCurrentColor(0.12, 0.3);
      ctx.lineWidth = Math.max(1.0, r * 0.12);
      ctx.globalAlpha = 1.0;
      ctx.beginPath(); ctx.arc(x, y, r * 0.7, 0, Math.PI * 2); ctx.stroke();
      // Interior grain
      ctx.fillStyle = darkerFromCurrentColor(0.1, 0.28);
      const dots = 14 + Math.floor(brushSize * 0.8);
      for (let i = 0; i < dots; i++) {
        const a = Math.random() * Math.PI * 2, d = Math.random() * r;
        const px = x + Math.cos(a) * d, py = y + Math.sin(a) * d;
        const s = Math.random() * (r * 0.08);
        ctx.beginPath(); ctx.arc(px, py, s, 0, Math.PI * 2); ctx.fill();
      }
      ctx.restore();
    }

    function drawOilBrush(ctx, x, y, fromX, fromY, toX, toY) {
      // Professional oil paint with thick, impasto-like texture
      const particles = 6 + Math.floor(Math.random() * 4);
      ctx.fillStyle = currentColor;
      
      for (let i = 0; i < particles; i++) {
        const offsetX = (Math.random() - 0.5) * brushSize * 0.8;
        const offsetY = (Math.random() - 0.5) * brushSize * 0.8;
        const size = Math.random() * brushSize * 0.8;
        const alpha = Math.random() * 0.95;
        
        ctx.globalAlpha = brushOpacity * alpha;
        ctx.beginPath();
        ctx.arc(x + offsetX, y + offsetY, size, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Add impasto texture strokes
      for (let i = 0; i < 3; i++) {
        const strokeX = (Math.random() - 0.5) * brushSize * 1.2;
        const strokeY = (Math.random() - 0.5) * brushSize * 1.2;
        const strokeWidth = Math.random() * brushSize * 0.3;
        const strokeHeight = Math.random() * brushSize * 0.8;
        const strokeAngle = Math.random() * Math.PI * 2;
        
        ctx.save();
        ctx.translate(x + strokeX, y + strokeY);
        ctx.rotate(strokeAngle);
        ctx.globalAlpha = brushOpacity * 0.7;
        ctx.fillRect(-strokeWidth/2, -strokeHeight/2, strokeWidth, strokeHeight);
        ctx.restore();
      }

      // Add darker dried paint specks
      const rgb = hexToRgb(currentColor || '#000000');
      const darkR = Math.max(0, Math.floor(rgb.r * 0.55));
      const darkG = Math.max(0, Math.floor(rgb.g * 0.55));
      const darkB = Math.max(0, Math.floor(rgb.b * 0.55));
      const specks = 6 + Math.floor(Math.random() * 6);
      for (let i = 0; i < specks; i++) {
        const sx = x + (Math.random() - 0.5) * brushSize * 1.2;
        const sy = y + (Math.random() - 0.5) * brushSize * 1.2;
        const sSize = Math.max(0.8, Math.random() * (brushSize * 0.25));
        ctx.globalAlpha = brushOpacity * (0.65 + Math.random() * 0.25);
        ctx.fillStyle = `rgb(${darkR},${darkG},${darkB})`;
        ctx.beginPath();
        ctx.arc(sx, sy, sSize, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Side smears (3D borderline from both directions)
      try {
        let ang = 0;
        if (typeof fromX === 'number' && typeof fromY === 'number' && typeof toX === 'number' && typeof toY === 'number') {
          const dx = toX - fromX, dy = toY - fromY;
          if (dx !== 0 || dy !== 0) ang = Math.atan2(dy, dx);
        } else {
          ang = lastOilAngle || 0;
        }
        lastOilAngle = ang;
        const length = Math.max(brushSize * 1.4, 10);
        const thickness = Math.max(brushSize * 0.9, 8);
        const band = Math.max(brushSize * 0.18, 3); // smear band thickness
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(ang);
        // Top band (one side)
        ctx.globalCompositeOperation = 'multiply';
        ctx.globalAlpha = Math.min(1, brushOpacity * 0.9);
        ctx.fillStyle = darkerFromCurrentColor(0.22, 0.55);
        ctx.fillRect(-length/2, -thickness/2, length, band);
        // Bottom band (other side)
        ctx.fillRect(-length/2, thickness/2 - band, length, band);
        // Micro streaks within bands to enhance relief
        ctx.strokeStyle = darkerFromCurrentColor(0.18, 0.55);
        ctx.lineCap = 'round';
        for (let i = 0; i < 3; i++) {
          const oy = (-thickness/2) + (band*0.5) + (i-1) * (thickness*0.35);
          ctx.lineWidth = Math.max(1.0, brushSize * 0.12 * Math.random());
          ctx.beginPath(); ctx.moveTo(-length*0.35, oy); ctx.lineTo(length*0.35, oy); ctx.stroke();
        }
        ctx.restore();
      } catch (_e) { /* ignore */ }
      ctx.globalAlpha = brushOpacity;
    }

    function drawBasicBrush(ctx, x, y) {
      // Rewritten: simple round with subtle full-footprint grain
      const r = Math.max(2, brushSize / 2);
      ctx.save();
      // Base
      ctx.globalAlpha = brushOpacity;
      ctx.fillStyle = currentColor;
      ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2); ctx.fill();
      // Gentle grain
      ctx.globalCompositeOperation = 'multiply';
      ctx.fillStyle = darkerFromCurrentColor(0.08, 0.3);
      const dots = 8 + Math.floor(brushSize * 0.6);
      for (let i = 0; i < dots; i++) {
        const a = Math.random() * Math.PI * 2, d = Math.sqrt(Math.random()) * r;
        const px = x + Math.cos(a) * d, py = y + Math.sin(a) * d;
        const s = Math.random() * (r * 0.06);
        ctx.beginPath(); ctx.arc(px, py, s, 0, Math.PI * 2); ctx.fill();
      }
      ctx.restore();
    }

    // --- New Dark Fantasy 80s brushes ---
    function drawThornBloom(ctx, x, y, fromX, fromY, toX, toY) {
      // Thorn Bloom (revised): consistent, centerâ€‘strong spikes/thorns without cumulative darkening
      const r = Math.max(4, brushSize);
      // Deterministic pseudo-random based on position to keep pattern consistent across samples
      const seed = Math.sin(x * 12.9898 + y * 78.233) * 43758.5453;
      const randN = (n) => {
        const t = Math.sin(seed + n * 1.61803398875) * 10000;
        return t - Math.floor(t);
      };
      // Stroke direction for orientation
      let ang = lastOilAngle || 0;
      if (typeof fromX === 'number' && typeof fromY === 'number' && typeof toX === 'number' && typeof toY === 'number') {
        const dx = toX - fromX, dy = toY - fromY;
        if (dx !== 0 || dy !== 0) ang = Math.atan2(dy, dx);
      }
      ctx.save();
      // Base bloom (source-over so repeated passes don't blacken)
      ctx.globalCompositeOperation = 'source-over';
      ctx.globalAlpha = brushOpacity * 0.85;
      ctx.fillStyle = currentColor;
      ctx.beginPath(); ctx.arc(x, y, r * 0.28, 0, Math.PI * 2); ctx.fill();
      // Radial spikes â€“ use currentColor (not darker) to avoid darkening; deterministic jitter
      ctx.strokeStyle = currentColor;
      ctx.lineCap = 'round';
      const spikes = 10 + Math.floor(brushSize * 0.25);
      for (let i = 0; i < spikes; i++) {
        const baseA = ang + (i / spikes) * Math.PI * 2;
        const jitterA = (randN(i) - 0.5) * 0.12;
        const a = baseA + jitterA;
        const len = r * (0.55 + randN(i + 11) * 0.5);
        ctx.lineWidth = Math.max(0.8, r * 0.08 * randN(i + 23));
      ctx.beginPath();
        ctx.moveTo(x - Math.cos(a) * len * 0.15, y - Math.sin(a) * len * 0.15);
        ctx.lineTo(x + Math.cos(a) * len * 0.85, y + Math.sin(a) * len * 0.85);
        ctx.stroke();
      }
      // Accent overlay for spikes: colorâ€‘relative darker lines (multiply) to keep pattern strong but tied to the hue
      ctx.globalCompositeOperation = 'multiply';
      ctx.globalAlpha = Math.min(1, brushOpacity * 0.92);
      ctx.strokeStyle = darkerFromCurrentColor(0.18, 0.6);
      for (let i = 0; i < spikes; i++) {
        const baseA = ang + (i / spikes) * Math.PI * 2;
        const jitterA = (randN(i + 31) - 0.5) * 0.08;
        const a = baseA + jitterA;
        const len = r * (0.44 + randN(i + 41) * 0.38);
        ctx.lineWidth = Math.max(0.7, r * 0.065 * randN(i + 53));
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + Math.cos(a) * len, y + Math.sin(a) * len);
        ctx.stroke();
      }
      // Curved thorns â€“ also in currentColor to keep tone consistent; deterministic layout
      ctx.globalCompositeOperation = 'source-over';
      ctx.strokeStyle = currentColor;
      for (let i = 0; i < 8 + Math.floor(brushSize * 0.2); i++) {
        const a = ang + (i / 6) * Math.PI + (randN(i + 101) - 0.5) * 0.4;
        const inner = r * 0.14, outer = r * 0.5;
        const cx = x + Math.cos(a) * inner;
        const cy = y + Math.sin(a) * inner;
        const tip = a + (randN(i + 77) - 0.5) * 0.7;
        ctx.lineWidth = Math.max(0.6, r * 0.06 * randN(i + 55));
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.quadraticCurveTo(
          x + Math.cos((a + tip) / 2) * (r * 0.23),
          y + Math.sin((a + tip) / 2) * (r * 0.23),
          x + Math.cos(tip) * outer,
          y + Math.sin(tip) * outer
        );
        ctx.stroke();
      }
      // Thorn notches overlay (multiply, darker shade) to add crisp texture without black
      ctx.globalCompositeOperation = 'multiply';
      ctx.strokeStyle = darkerFromCurrentColor(0.15, 0.6);
      for (let i = 0; i < 8; i++) {
        const a = ang + (i / 6) * Math.PI * 2;
        const ringR = r * (0.2 + 0.08 * randN(i + 211));
        const arcLen = Math.PI / 7;
        ctx.lineWidth = Math.max(0.55, r * 0.045);
        ctx.beginPath();
        for (let t = 0; t <= 10; t++) {
          const angSeg = a + (t / 10 - 0.5) * arcLen;
          const px = x + Math.cos(angSeg) * ringR;
          const py = y + Math.sin(angSeg) * ringR;
          if (t === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
        }
        ctx.stroke();
      }
      // Centerâ€‘biased speckle using a slightly darker shade but low alpha; still source-over
      ctx.globalCompositeOperation = 'source-over';
      ctx.globalAlpha = Math.min(1, brushOpacity * 0.65);
      ctx.fillStyle = darkerFromCurrentColor(0.24, 0.6);
      for (let i = 0; i < Math.floor(22 + brushSize * 0.6); i++) {
        const u = randN(i + 333);
        const d = Math.sqrt(u) * (r * 0.55); // bias to center
        const a = ang + randN(i + 444) * Math.PI * 2;
        const px = x + Math.cos(a) * d, py = y + Math.sin(a) * d;
        const s = Math.max(0.3, (1 - d / (r * 0.55)) * (r * 0.045) * randN(i + 555));
        ctx.beginPath(); ctx.arc(px, py, s, 0, Math.PI * 2); ctx.fill();
      }
      // Side-edge darkening only (two subtle arcs at Â±90Â° to stroke direction)
      ctx.globalCompositeOperation = 'multiply';
      ctx.globalAlpha = Math.min(1, brushOpacity * 0.38);
      ctx.strokeStyle = darkerFromCurrentColor(0.16, 0.65);
      ctx.lineCap = 'round';
      ctx.lineWidth = Math.max(0.55, r * 0.035);
      const edgeR = r * 0.54;
      const span = Math.PI / 9; // short arc
      const mids = [ang + Math.PI / 2, ang - Math.PI / 2];
      for (let mi = 0; mi < mids.length; mi++) {
        const mid = mids[mi];
        ctx.beginPath();
        for (let t = 0; t <= 10; t++) {
          const offs = (t / 10 - 0.5) * span;
          const jitter = (randN(700 + mi * 31 + t) - 0.5) * (span * 0.12);
          const a2 = mid + offs + jitter;
          const px = x + Math.cos(a2) * edgeR;
          const py = y + Math.sin(a2) * edgeR;
          if (t === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
        }
        ctx.stroke();
      }
      ctx.restore();
    }
    function drawRuneGlyph(ctx, x, y, fromX, fromY, toX, toY) {
      const angle = Math.atan2(toY - fromY, toX - fromX);
      const r = Math.max(3, brushSize * 0.9);
      ctx.save();
      ctx.translate(x, y); ctx.rotate(angle);
      // Base faint fill
      ctx.globalAlpha = brushOpacity * 0.8;
      ctx.fillStyle = currentColor;
      ctx.beginPath(); ctx.arc(0, 0, r*0.5, 0, Math.PI*2); ctx.fill();
      // Glyph dashes
      ctx.globalCompositeOperation = 'multiply';
      ctx.strokeStyle = darkerFromCurrentColor(0.2, 0.28);
      ctx.lineCap = 'round';
      const dashes = 8 + Math.floor(brushSize * 0.3);
      for (let i=0;i<dashes;i++){
        const ang = Math.random()*Math.PI*2;
        const rr = r*0.5 + Math.random()*r*0.4;
        const len = Math.max(1, r*0.3*Math.random());
        const cx = Math.cos(ang)*rr, cy = Math.sin(ang)*rr;
        ctx.lineWidth = Math.max(0.6, r*0.1*Math.random());
        ctx.beginPath();
        ctx.moveTo(cx - Math.cos(ang)*len/2, cy - Math.sin(ang)*len/2);
        ctx.lineTo(cx + Math.cos(ang)*len/2, cy + Math.sin(ang)*len/2);
        ctx.stroke();
      }
      ctx.restore();
    }
    function drawHexSigil(ctx, x, y, fromX, fromY, toX, toY) {
      // Hex Sigil: hexagonal lattice + rune strokes + center-biased shards (no circular patterns)
      const r = Math.max(4, brushSize);
      ctx.save();
      // Base hex fill (small)
      ctx.globalAlpha = brushOpacity * 0.8;
      ctx.fillStyle = currentColor;
      const hex = [];
      const sides = 6;
      const baseRadius = r * 0.3;
      for (let i=0;i<sides;i++){
        const a = Math.PI/6 + (i/sides)*Math.PI*2;
        hex.push({x: x + Math.cos(a)*baseRadius, y: y + Math.sin(a)*baseRadius});
      }
      ctx.beginPath();
      ctx.moveTo(hex[0].x, hex[0].y);
      for (let i=1;i<sides;i++) ctx.lineTo(hex[i].x, hex[i].y);
      ctx.closePath(); ctx.fill();
      // Multiply overlays
      ctx.globalCompositeOperation = 'multiply';
      // Hex lattice spokes from center (center-strong)
      ctx.strokeStyle = darkerFromCurrentColor(0.1, 0.38);
      ctx.lineCap='round';
      ctx.lineWidth = Math.max(0.7, r*0.05);
      for (let i=0;i<sides;i++){
        ctx.beginPath(); ctx.moveTo(x,y);
        ctx.lineTo(hex[i].x, hex[i].y); ctx.stroke();
      }
      // Offset mini-hexes around center (non-circular, jagged)
      ctx.strokeStyle = darkerFromCurrentColor(0.09, 0.4);
      ctx.lineWidth = Math.max(0.6, r*0.04);
      const mini = 4 + Math.floor(brushSize * 0.15);
      for (let m=0;m<mini;m++){
        const ang = Math.random()*Math.PI*2;
        const dist = Math.random()* (r*0.35);
        const cx = x + Math.cos(ang)*dist;
        const cy = y + Math.sin(ang)*dist;
        const rad = r * (0.12 + Math.random()*0.12);
        ctx.beginPath();
        for (let i=0;i<sides;i++){
          const a = Math.PI/6 + (i/sides)*Math.PI*2 + (Math.random()-0.5)*0.08;
          const px = cx + Math.cos(a)*rad;
          const py = cy + Math.sin(a)*rad;
          if (i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
        }
        ctx.closePath(); ctx.stroke();
      }
      // Rune strokes crossing axes
      ctx.strokeStyle = darkerFromCurrentColor(0.08, 0.45);
      for (let i=0;i<6;i++){
        const a = (i/6)*Math.PI*2;
        const len = r*(0.4 + Math.random()*0.2);
        const jitter = (Math.random()-0.5)*r*0.08;
        ctx.lineWidth = Math.max(0.6, r*0.04*Math.random());
        ctx.beginPath();
        ctx.moveTo(x + Math.cos(a+Math.PI/2)*(jitter), y + Math.sin(a+Math.PI/2)*(jitter));
        ctx.lineTo(x + Math.cos(a)*len, y + Math.sin(a)*len);
        ctx.stroke();
      }
      // Shard speckle (center-biased)
      ctx.fillStyle = darkerFromCurrentColor(0.08, 0.45);
      for (let i=0;i<Math.floor(24 + brushSize*0.8); i++){
        const ang = Math.random()*Math.PI*2, u=Math.random();
        const d = Math.sqrt(u) * (r*0.55);
        const px = x + Math.cos(ang)*d, py = y + Math.sin(ang)*d;
        const s = Math.max(0.3, (1-d/(r*0.55)) * (r*0.045) * Math.random());
        ctx.beginPath(); ctx.arc(px, py, s, 0, Math.PI*2); ctx.fill();
      }
      ctx.restore();
    }
    function drawVoidScratch(ctx, x, y, fromX, fromY, toX, toY) {
      const angle = Math.atan2(toY-fromY, toX-fromX);
      const r = Math.max(2, brushSize);
      ctx.save();
      ctx.translate(x,y); ctx.rotate(angle);
      // Base thin stroke
      ctx.globalAlpha = brushOpacity;
      ctx.strokeStyle = currentColor;
      ctx.lineCap='round';
      ctx.lineWidth = Math.max(1.0, r*0.2);
      ctx.beginPath(); ctx.moveTo(-r*0.6, 0); ctx.lineTo(r*0.6, 0); ctx.stroke();
      // Jagged darker scratches
      ctx.globalCompositeOperation = 'multiply';
      ctx.strokeStyle = darkerFromCurrentColor(0.2, 0.28);
      const scratches = 6 + Math.floor(brushSize * 0.3);
      for (let i=0;i<scratches;i++){
        const jitter = (Math.random()-0.5)*r*0.6;
        const len = r*(0.5+Math.random()*0.9);
        ctx.lineWidth = Math.max(0.6, r*0.08*Math.random());
        ctx.beginPath();
        ctx.moveTo(-len/2, jitter);
        ctx.lineTo(len/2, jitter + (Math.random()-0.5)*r*0.2);
        ctx.stroke();
      }
      ctx.restore();
    }

    function drawCrayonBrush(ctx, x, y) {
      // Crayon with many tiny holes: fill base, then punch out micro-holes, add edge grain
      const r = Math.max(2, brushSize / 2);
      // Base soft fill
      ctx.save();
      ctx.globalAlpha = brushOpacity * 0.9;
      ctx.fillStyle = currentColor;
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.fill();
      // Punch tiny holes (simulate crayon paper gaps)
      ctx.globalCompositeOperation = 'destination-out';
      const holes = 20 + Math.floor(Math.random() * 25);
      for (let i = 0; i < holes; i++) {
        const ang = Math.random() * Math.PI * 2;
        const rad = Math.sqrt(Math.random()) * (r * 0.95); // bias towards center
        const hx = x + Math.cos(ang) * rad;
        const hy = y + Math.sin(ang) * rad;
        const hSize = Math.max(0.3, Math.random() * (brushSize * 0.12));
        ctx.beginPath();
        ctx.arc(hx, hy, hSize, 0, Math.PI * 2);
        ctx.fill();
      }
      // Restore paint, add rough edge speckles
      ctx.restore();
      const edgeDots = 18 + Math.floor(Math.random() * 10);
      for (let i = 0; i < edgeDots; i++) {
        const ang = Math.random() * Math.PI * 2;
        const rad = r * (0.8 + Math.random() * 0.35);
        const dx = Math.cos(ang) * rad + (Math.random() - 0.5) * (r * 0.18);
        const dy = Math.sin(ang) * rad + (Math.random() - 0.5) * (r * 0.18);
        const size = Math.max(0.4, Math.random() * (brushSize * 0.22));
        ctx.globalAlpha = brushOpacity * (0.35 + Math.random() * 0.35);
        ctx.fillStyle = currentColor;
        ctx.beginPath();
        ctx.arc(x + dx, y + dy, size, 0, Math.PI * 2);
        ctx.fill();
      }
      // Light interior pigment speckle
      const specks = 15 + Math.floor(Math.random() * 15);
      for (let i = 0; i < specks; i++) {
        const rx = (Math.random() - 0.5) * r * 1.4;
        const ry = (Math.random() - 0.5) * r * 1.4;
        if (rx * rx + ry * ry > r * r) continue;
        const size = Math.max(0.3, Math.random() * (brushSize * 0.1));
        ctx.globalAlpha = brushOpacity * (0.22 + Math.random() * 0.25);
        ctx.fillStyle = currentColor;
        ctx.beginPath();
        ctx.arc(x + rx, y + ry, size, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = brushOpacity;
    }

    // Regular Scratches brush (lays pigment, not overlay/masked)
    function drawScratchesBrush(ctx, x, y, fromX, fromY, toX, toY) {
      const angle = Math.atan2(toY - fromY, toX - fromX);
      ctx.save();
      ctx.globalAlpha = brushOpacity * 0.9;
      ctx.strokeStyle = currentColor;
      ctx.lineCap = 'round';
      for (let i = 0; i < 12; i++) {
        const len = brushSize * (0.5 + Math.random() * 1.2);
        const jitter = (Math.random() - 0.5) * brushSize;
        const a = angle + (Math.random() - 0.5) * 0.6;
        const sx = x + Math.cos(a + Math.PI / 2) * jitter;
        const sy = y + Math.sin(a + Math.PI / 2) * jitter;
        ctx.lineWidth = Math.max(0.6, brushSize * 0.1 * Math.random());
        ctx.beginPath();
        ctx.moveTo(sx, sy);
        ctx.lineTo(sx + Math.cos(a) * len, sy + Math.sin(a) * len);
        ctx.stroke();
      }
      ctx.restore();
    }

    // --- Procedural texture overlays for brushes ---
    function darkerFromCurrentColor(alpha, factor) {
      const rgb = hexToRgb(currentColor || '#000000');
      const f = typeof factor === 'number' ? factor : 0.25; // 25% brightness
      const r = Math.max(0, Math.floor(rgb.r * f));
      const g = Math.max(0, Math.floor(rgb.g * f));
      const b = Math.max(0, Math.floor(rgb.b * f));
      const a = Math.max(0, Math.min(1, alpha));
      return `rgba(${r},${g},${b},${a})`;
    }
    function applyBrushTexture(ctx, x, y, size, kind) {
      const r = Math.max(2, size);
      ctx.save();
      // Use multiply blend and a darker shade of the current color for all overlays
      ctx.globalCompositeOperation = 'multiply';
      switch (kind) {
        case 'paperGrain': {
          // soft micro speckles across the whole footprint
          const densityBoost = 1 + Math.min(1.2, brushStrokeAge * 0.06);
          const dots = Math.max(18, Math.floor(r * 1.6 * densityBoost));
          for (let i = 0; i < dots; i++) {
            const a = Math.random() * Math.PI * 2;
            const d = Math.random() * r;
            const px = x + Math.cos(a) * d, py = y + Math.sin(a) * d;
            const s = Math.random() * (r * 0.09 * densityBoost);
            ctx.fillStyle = darkerFromCurrentColor(0.12, 0.28);
            ctx.beginPath(); ctx.arc(px, py, s, 0, Math.PI * 2); ctx.fill();
          }
          break;
        }
        case 'fiber': {
          // short fibrous lines in random directions
          ctx.strokeStyle = darkerFromCurrentColor(0.16, 0.3);
          ctx.lineCap = 'round';
          const lines = Math.floor(10 + r * 0.2);
          const thickness = (1 + Math.min(1.5, brushStrokeAge * 0.06));
          for (let i = 0; i < lines; i++) {
            const a = Math.random() * Math.PI * 2;
            const d = Math.random() * r;
            const len = r * (0.18 + Math.random() * 0.28);
            const px = x + Math.cos(a) * d, py = y + Math.sin(a) * d;
            ctx.lineWidth = Math.max(0.8, r * 0.05 * Math.random() * thickness);
            ctx.beginPath(); ctx.moveTo(px, py); ctx.lineTo(px + Math.cos(a) * len, py + Math.sin(a) * len); ctx.stroke();
          }
          break;
        }
        case 'chalkDust': {
          const densityBoost = 1 + Math.min(1.5, brushStrokeAge * 0.05);
          const particles = Math.max(18, Math.floor(r * 1.8 * densityBoost));
          for (let i = 0; i < particles; i++) {
            const a = Math.random() * Math.PI * 2;
            const d = Math.random() * r * 1.2;
            const px = x + Math.cos(a) * d, py = y + Math.sin(a) * d;
            const s = Math.random() * (r * 0.11 * densityBoost);
            ctx.fillStyle = darkerFromCurrentColor(0.14, 0.3);
            ctx.beginPath(); ctx.arc(px, py, s, 0, Math.PI * 2); ctx.fill();
          }
          break;
        }
        case 'fibersLinear': {
          // paper fibers aligned roughly along x
          ctx.strokeStyle = darkerFromCurrentColor(0.14, 0.3);
          ctx.lineCap = 'round';
          const count = 10 + Math.floor(r * 0.1);
          const thickness = (1 + Math.min(1.6, brushStrokeAge * 0.06));
          for (let i = 0; i < count; i++) {
            const d = (Math.random() - 0.5) * r * 1.2;
            const len = r * (0.35 + Math.random() * 0.55);
            const px = x - len / 2, py = y + d;
            ctx.lineWidth = Math.max(0.8, r * 0.05 * Math.random() * thickness);
            ctx.beginPath(); ctx.moveTo(px, py); ctx.lineTo(px + len, py + (Math.random() - 0.5) * r * 0.2); ctx.stroke();
          }
          break;
        }
        case 'speckle': {
          const densityBoost = 1 + Math.min(1.5, brushStrokeAge * 0.05);
          const dots = Math.max(20, Math.floor(r * 1.8 * densityBoost));
          for (let i = 0; i < dots; i++) {
            const a = Math.random() * Math.PI * 2;
            const d = Math.random() * r * 1.5;
            const px = x + Math.cos(a) * d, py = y + Math.sin(a) * d;
            const s = Math.random() * (r * 0.08 * densityBoost);
            ctx.fillStyle = darkerFromCurrentColor(0.14, 0.28);
            ctx.beginPath(); ctx.arc(px, py, s, 0, Math.PI * 2); ctx.fill();
          }
          break;
        }
        case 'lightPaper': {
          const dots = Math.max(10, Math.floor(r * 1.2));
          for (let i = 0; i < dots; i++) {
            const a = Math.random() * Math.PI * 2;
            const d = Math.random() * r * 0.9;
            const px = x + Math.cos(a) * d, py = y + Math.sin(a) * d;
            const s = Math.random() * (r * 0.06);
            ctx.fillStyle = darkerFromCurrentColor(0.08, 0.28);
            ctx.beginPath(); ctx.arc(px, py, s, 0, Math.PI * 2); ctx.fill();
          }
          break;
        }
        case 'bleedEdge': {
          // subtle darker ring close to edge to emulate bleed
          const ringR = r * 0.6;
          ctx.strokeStyle = darkerFromCurrentColor(0.12, 0.3);
          ctx.lineWidth = Math.max(1.0, r * 0.1 * (1 + Math.min(1.2, brushStrokeAge * 0.05)));
          ctx.beginPath(); ctx.arc(x, y, ringR, 0, Math.PI * 2); ctx.stroke();
          break;
        }
      }
      ctx.restore();
    }

    // --- New texture-only brushes (use current color lightly) ---
    function drawTextureScratches(ctx, x, y, fromX, fromY, toX, toY) {
      // Apply scratch texture only over existing paint (like Shade), using darker pigment
      const px = fromX, py = fromY;
      const r = Math.max(2, brushSize);
      const minX = Math.max(0, Math.floor(Math.min(px, x) - r));
      const minY = Math.max(0, Math.floor(Math.min(py, y) - r));
      const maxX = Math.ceil(Math.max(px, x) + r);
      const maxY = Math.ceil(Math.max(py, y) + r);
      const w = Math.max(1, maxX - minX), h = Math.max(1, maxY - minY);
      try {
        const pre = ctx.getImageData(minX, minY, w, h);
        // Draw scratches with multiply, using darker variant of current color
        const rgb = hexToRgb(currentColor || '#000000');
        const dark = `rgba(${Math.floor(rgb.r*0.2)},${Math.floor(rgb.g*0.2)},${Math.floor(rgb.b*0.2)},${(0.5*brushOpacity).toFixed(3)})`;
        ctx.save();
        ctx.globalCompositeOperation = 'multiply';
        ctx.strokeStyle = dark;
        ctx.lineCap = 'round';
        const angle = Math.atan2(toY - fromY, toX - fromX);
        for (let i = 0; i < 12; i++) {
          const len = r * (0.5 + Math.random() * 1.3);
          const jitter = (Math.random() - 0.5) * r * 1.2;
          const a = angle + (Math.random() - 0.5) * 0.7;
          const sx = x + Math.cos(a + Math.PI / 2) * jitter;
          const sy = y + Math.sin(a + Math.PI / 2) * jitter;
          ctx.lineWidth = Math.max(0.6, r * 0.08 * Math.random());
          ctx.beginPath(); ctx.moveTo(sx, sy); ctx.lineTo(sx + Math.cos(a) * len, sy + Math.sin(a) * len); ctx.stroke();
        }
        ctx.restore();
        // Restore background/transparent pixels (only affect previously drawn content)
        const post = ctx.getImageData(minX, minY, w, h);
        const dataPre = pre.data, dataPost = post.data;
        const bgR = 0x1a, bgG = 0x1a, bgB = 0x1a, tol = 4;
        for (let p = 0; p < dataPost.length; p += 4) {
          const r0 = dataPre[p], g0 = dataPre[p+1], b0 = dataPre[p+2], a0 = dataPre[p+3];
          if ((Math.abs(r0-bgR)<=tol && Math.abs(g0-bgG)<=tol && Math.abs(b0-bgB)<=tol && a0>=250) || a0<=5) {
            dataPost[p]=dataPre[p]; dataPost[p+1]=dataPre[p+1]; dataPost[p+2]=dataPre[p+2]; dataPost[p+3]=dataPre[p+3];
          }
        }
        ctx.putImageData(post, minX, minY);
      } catch (_) {
        // Fallback without masking
        const angle = Math.atan2(toY - fromY, toX - fromX);
        const rgb = hexToRgb(currentColor || '#000000');
        ctx.save();
        ctx.globalCompositeOperation = 'multiply';
        ctx.strokeStyle = darkerFromCurrentColor(0.35 * brushOpacity, 0.28);
        ctx.lineCap = 'round';
        for (let i = 0; i < 8; i++) {
          const len = r * (0.4 + Math.random() * 1.0);
          const a = angle + (Math.random() - 0.5) * 0.7;
          ctx.lineWidth = Math.max(0.6, r * 0.06 * Math.random());
          ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x + Math.cos(a) * len, y + Math.sin(a) * len); ctx.stroke();
        }
        ctx.restore();
      }
    }
    function drawTextureDrywall(ctx, x, y, fromX, fromY, toX, toY) {
      // Speckled drywall pattern, only on existing paint
      const r = Math.max(2, brushSize);
      const minX = Math.max(0, Math.floor(Math.min(fromX, x) - r));
      const minY = Math.max(0, Math.floor(Math.min(fromY, y) - r));
      const maxX = Math.ceil(Math.max(fromX, x) + r);
      const maxY = Math.ceil(Math.max(fromY, y) + r);
      const w = Math.max(1, maxX - minX), h = Math.max(1, maxY - minY);
      try {
        const pre = ctx.getImageData(minX, minY, w, h);
        const thick = (1 + Math.min(1.4, brushStrokeAge * 0.06));
        const dark = darkerFromCurrentColor(0.5 * brushOpacity, 0.28);
        ctx.save();
        ctx.globalCompositeOperation = 'multiply';
        // dots
        const count = Math.floor(28 * thick);
        for (let i = 0; i < count; i++) {
          const a = Math.random() * Math.PI * 2;
          const d = Math.random() * r * 1.2;
          const px = x + Math.cos(a) * d, py = y + Math.sin(a) * d;
          const s = Math.random() * (r * 0.12 * thick);
          ctx.fillStyle = dark;
          if (Math.random() < 0.7) { ctx.beginPath(); ctx.arc(px, py, s, 0, Math.PI * 2); ctx.fill(); }
          else ctx.fillRect(px, py, s, s);
        }
        // short strokes
        ctx.strokeStyle = dark;
        ctx.lineCap = 'round';
        for (let i = 0; i < Math.ceil(6 * thick); i++) {
          const a = Math.random() * Math.PI * 2;
          const len = r * (0.3 + Math.random() * 0.6);
          const px = x + (Math.random() - 0.5) * r, py = y + (Math.random() - 0.5) * r;
          ctx.lineWidth = Math.max(0.5, r * 0.06 * thick);
          ctx.beginPath(); ctx.moveTo(px, py); ctx.lineTo(px + Math.cos(a) * len, py + Math.sin(a) * len); ctx.stroke();
        }
        ctx.restore();
        const post = ctx.getImageData(minX, minY, w, h);
        const dataPre = pre.data, dataPost = post.data;
        const bgR = 0x1a, bgG = 0x1a, bgB = 0x1a, tol = 4;
        for (let p = 0; p < dataPost.length; p += 4) {
          const r0 = dataPre[p], g0 = dataPre[p+1], b0 = dataPre[p+2], a0 = dataPre[p+3];
          if ((Math.abs(r0-bgR)<=tol && Math.abs(g0-bgG)<=tol && Math.abs(b0-bgB)<=tol && a0>=250) || a0<=5) {
            dataPost[p]=dataPre[p]; dataPost[p+1]=dataPre[p+1]; dataPost[p+2]=dataPre[p+2]; dataPost[p+3]=dataPre[p+3];
          }
        }
        ctx.putImageData(post, minX, minY);
      } catch (_) {
        // fallback simple
        ctx.save();
        ctx.globalCompositeOperation = 'multiply';
        ctx.fillStyle = darkerFromCurrentColor(0.3, 0.28);
        for (let i = 0; i < 20; i++) {
          const a = Math.random() * Math.PI * 2, d = Math.random() * r;
          ctx.beginPath(); ctx.arc(x + Math.cos(a)*d, y + Math.sin(a)*d, Math.random()* (r*0.1), 0, Math.PI*2); ctx.fill();
        }
        ctx.restore();
      }
    }
    function drawTextureSand(ctx, x, y, fromX, fromY, toX, toY) {
      // Grainy sand texture, only on existing paint
      const r = Math.max(2, brushSize);
      const minX = Math.max(0, Math.floor(Math.min(fromX, x) - r));
      const minY = Math.max(0, Math.floor(Math.min(fromY, y) - r));
      const maxX = Math.ceil(Math.max(fromX, x) + r);
      const maxY = Math.ceil(Math.max(fromY, y) + r);
      const w = Math.max(1, maxX - minX), h = Math.max(1, maxY - minY);
      try {
        const pre = ctx.getImageData(minX, minY, w, h);
        const thick = (1 + Math.min(1.6, brushStrokeAge * 0.06));
        const dark = darkerFromCurrentColor(0.46 * brushOpacity, 0.3);
        ctx.save();
        ctx.globalCompositeOperation = 'multiply';
        for (let i = 0; i < Math.floor(60 * thick); i++) {
          const a = Math.random() * Math.PI * 2;
          const d = Math.random() * r * 1.4;
          const px = x + Math.cos(a) * d, py = y + Math.sin(a) * d;
          const s = Math.max(0.4, Math.random() * (r * 0.08 * thick));
          ctx.fillStyle = dark;
          ctx.beginPath(); ctx.arc(px, py, s, 0, Math.PI * 2); ctx.fill();
        }
        ctx.restore();
        const post = ctx.getImageData(minX, minY, w, h);
        const dataPre = pre.data, dataPost = post.data;
        const bgR = 0x1a, bgG = 0x1a, bgB = 0x1a, tol = 4;
        for (let p = 0; p < dataPost.length; p += 4) {
          const r0 = dataPre[p], g0 = dataPre[p+1], b0 = dataPre[p+2], a0 = dataPre[p+3];
          if ((Math.abs(r0-bgR)<=tol && Math.abs(g0-bgG)<=tol && Math.abs(b0-bgB)<=tol && a0>=250) || a0<=5) {
            dataPost[p]=dataPre[p]; dataPost[p+1]=dataPre[p+1]; dataPost[p+2]=dataPre[p+2]; dataPost[p+3]=dataPre[p+3];
          }
        }
        ctx.putImageData(post, minX, minY);
      } catch (_) {
        ctx.save();
        ctx.globalCompositeOperation = 'multiply';
        ctx.fillStyle = darkerFromCurrentColor(0.35, 0.28);
        for (let i = 0; i < 40; i++) {
          const a = Math.random() * Math.PI * 2, d = Math.random() * r * 1.2;
          ctx.beginPath(); ctx.arc(x + Math.cos(a)*d, y + Math.sin(a)*d, Math.random()*(r*0.06), 0, Math.PI*2); ctx.fill();
        }
        ctx.restore();
      }
    }

    function drawTextureCurly(ctx, x, y, fromX, fromY, toX, toY) {
      // Curly swirls overlay-only (masked like Shade)
      const r = Math.max(2, brushSize);
      const minX = Math.max(0, Math.floor(Math.min(fromX, x) - r));
      const minY = Math.max(0, Math.floor(Math.min(fromY, y) - r));
      const maxX = Math.ceil(Math.max(fromX, x) + r);
      const maxY = Math.ceil(Math.max(fromY, y) + r);
      const w = Math.max(1, maxX - minX), h = Math.max(1, maxY - minY);
      try {
        const pre = ctx.getImageData(minX, minY, w, h);
        const rgb = hexToRgb(currentColor || '#000000');
        const dark = `rgba(${Math.floor(rgb.r*0.25)},${Math.floor(rgb.g*0.25)},${Math.floor(rgb.b*0.25)},${(0.5*brushOpacity).toFixed(3)})`;
        ctx.save();
        ctx.globalCompositeOperation = 'multiply';
        ctx.strokeStyle = dark;
        ctx.lineCap = 'round';
        // draw several curls (approximate with small arcs)
        for (let i = 0; i < 6; i++) {
          const cx = x + (Math.random()-0.5) * r;
          const cy = y + (Math.random()-0.5) * r;
          const rad = Math.max(1.5, r * (0.15 + Math.random()*0.25));
          const turns = 2 + Math.floor(Math.random()*2);
          ctx.lineWidth = Math.max(0.6, r*0.06);
          ctx.beginPath();
          for (let t = 0; t < turns*24; t++) {
            const a = (t/24) * Math.PI*2;
            const rr = rad * (1 - t/(turns*24)) * 1.1;
            const px = cx + Math.cos(a)*rr;
            const py = cy + Math.sin(a)*rr;
            if (t === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
          }
          ctx.stroke();
        }
        ctx.restore();
        const post = ctx.getImageData(minX, minY, w, h);
        const dataPre = pre.data, dataPost = post.data;
        const bgR = 0x1a, bgG = 0x1a, bgB = 0x1a, tol = 4;
        for (let p = 0; p < dataPost.length; p += 4) {
          const r0 = dataPre[p], g0 = dataPre[p+1], b0 = dataPre[p+2], a0 = dataPre[p+3];
          if ((Math.abs(r0-bgR)<=tol && Math.abs(g0-bgG)<=tol && Math.abs(b0-bgB)<=tol && a0>=250) || a0<=5) {
            dataPost[p]=dataPre[p]; dataPost[p+1]=dataPre[p+1]; dataPost[p+2]=dataPre[p+2]; dataPost[p+3]=dataPre[p+3];
          }
        }
        ctx.putImageData(post, minX, minY);
      } catch (_) {
        // fallback simple
        ctx.save();
        ctx.globalCompositeOperation = 'multiply';
        ctx.strokeStyle = darkerFromCurrentColor(0.35, 0.28);
        ctx.lineWidth = Math.max(0.6, r*0.06);
        ctx.beginPath();
        ctx.arc(x, y, r*0.3, 0, Math.PI*2);
        ctx.stroke();
        ctx.restore();
      }
    }

    function drawTextureWood(ctx, x, y, fromX, fromY, toX, toY) {
      // Wood grain rings overlay-only
      const r = Math.max(2, brushSize);
      const minX = Math.max(0, Math.floor(Math.min(fromX, x) - r));
      const minY = Math.max(0, Math.floor(Math.min(fromY, y) - r));
      const maxX = Math.ceil(Math.max(fromX, x) + r);
      const maxY = Math.ceil(Math.max(fromY, y) + r);
      const w = Math.max(1, maxX - minX), h = Math.max(1, maxY - minY);
      try {
        const pre = ctx.getImageData(minX, minY, w, h);
        const rgb = hexToRgb(currentColor || '#000000');
        const dark = `rgba(${Math.floor(rgb.r*0.2)},${Math.floor(rgb.g*0.2)},${Math.floor(rgb.b*0.2)},${(0.5*brushOpacity).toFixed(3)})`;
        ctx.save();
        ctx.globalCompositeOperation = 'multiply';
        ctx.strokeStyle = dark;
        ctx.lineCap = 'round';
        // draw multiple concentric irregular rings
        for (let ring = 0; ring < 3; ring++) {
          const baseR = r * (0.25 + ring * 0.18);
          ctx.lineWidth = Math.max(0.5, r*0.05);
          ctx.beginPath();
          for (let t = 0; t <= 48; t++) {
            const a = (t/48) * Math.PI*2;
            const jitter = Math.sin(a*5 + ring) * (r*0.02) + (Math.random()-0.5) * (r*0.01);
            const rr = baseR + jitter;
            const px = x + Math.cos(a)*rr, py = y + Math.sin(a)*rr;
            if (t === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
          }
          ctx.stroke();
        }
        ctx.restore();
        const post = ctx.getImageData(minX, minY, w, h);
        const dataPre = pre.data, dataPost = post.data;
        const bgR = 0x1a, bgG = 0x1a, bgB = 0x1a, tol = 4;
        for (let p = 0; p < dataPost.length; p += 4) {
          const r0 = dataPre[p], g0 = dataPre[p+1], b0 = dataPre[p+2], a0 = dataPre[p+3];
          if ((Math.abs(r0-bgR)<=tol && Math.abs(g0-bgG)<=tol && Math.abs(b0-bgB)<=tol && a0>=250) || a0<=5) {
            dataPost[p]=dataPre[p]; dataPost[p+1]=dataPre[p+1]; dataPost[p+2]=dataPre[p+2]; dataPost[p+3]=dataPre[p+3];
          }
        }
        ctx.putImageData(post, minX, minY);
      } catch (_) {
        ctx.save();
        ctx.globalCompositeOperation = 'multiply';
        ctx.strokeStyle = darkerFromCurrentColor(0.35, 0.28);
        ctx.lineWidth = Math.max(0.5, r*0.05);
        ctx.beginPath(); ctx.arc(x, y, r*0.3, 0, Math.PI*2); ctx.stroke();
        ctx.restore();
      }
    }
    function drawWindBrush(ctx, x, y, fromX, fromY, toX, toY) {
      // Wind/movement brush for animation effects - creates faded, directional strokes
      const angle = Math.atan2(toY - fromY, toX - fromX);
      const speed = Math.sqrt((toX - fromX) ** 2 + (toY - fromY) ** 2);
      const intensity = Math.min(1, Math.max(0.1, speed / 20));
      
      // Create wind streaks
      const streaks = 3 + Math.floor(Math.random() * 4);
      for (let i = 0; i < streaks; i++) {
        const streakLength = brushSize * (0.5 + Math.random() * 1.5);
        const streakWidth = brushSize * (0.1 + Math.random() * 0.3);
        const streakAngle = angle + (Math.random() - 0.5) * 0.5; // Slight variation
        const streakX = x + (Math.random() - 0.5) * brushSize * 0.5;
        const streakY = y + (Math.random() - 0.5) * brushSize * 0.5;
        
        ctx.save();
        ctx.translate(streakX, streakY);
        ctx.rotate(streakAngle);
        ctx.globalAlpha = brushOpacity * intensity * (0.3 + Math.random() * 0.4);
        ctx.fillStyle = currentColor;
        ctx.fillRect(-streakLength/2, -streakWidth/2, streakLength, streakWidth);
        ctx.restore();
      }
      
      // Add subtle wind particles
      for (let i = 0; i < 2; i++) {
        const particleX = x + (Math.random() - 0.5) * brushSize * 2;
        const particleY = y + (Math.random() - 0.5) * brushSize * 2;
        const particleSize = Math.random() * brushSize * 0.3;
        
        ctx.globalAlpha = brushOpacity * intensity * 0.2;
        ctx.fillStyle = currentColor;
        ctx.beginPath();
        ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
        ctx.fill();
      }
      
      ctx.globalAlpha = brushOpacity;
    }

    function updateColor(color) {
      currentColor = color;
      document.getElementById('current-color').textContent = color.toUpperCase();
    }

    function selectColor(color) {
      currentColor = color;
      document.getElementById('color-picker').value = color;
      document.getElementById('current-color').textContent = color.toUpperCase();
    }

    // Using the native browser color picker (no custom wheel UI)

    function updateBrushSize(size) {
      brushSize = parseInt(size);
      document.getElementById('size-value').textContent = size;
    }

    function updateOpacity(opacity) {
      brushOpacity = opacity / 100;
      document.getElementById('opacity-value').textContent = opacity + '%';
    }

    function updateOnionOpacity(opacity) {
      onionOpacity = opacity / 100;
      document.getElementById('onion-opacity-value').textContent = opacity + '%';
      updateOnionSkin();
    }

    function updateFPS(newFps) {
      fps = parseInt(newFps);
      if (animationInterval) {
        clearInterval(animationInterval);
        animationInterval = setInterval(updateAnimation, 1000 / fps);
      }
      // Update time scale indicators when FPS changes
      updateAllTimeScaleIndicators();
    }

    function updateLoopCount(newLoopCount) {
      loopCount = Math.max(1, parseInt(newLoopCount));
      updateTotalDuration();
    }

    // Multi-frame drawing helpers
    function getDrawingTargetFrames() {
      const targets = [];
      for (let i = 0; i < frameLayers.length; i++) {
        const layers = frameLayers[i];
        if (!layers) continue;
        const isGenerated = !!layers.__generatedInbetween;
        if (!isGenerated) targets.push(i);
      }
      return targets;
    }
    function ensureLayerExistsForFrame(frameIndex, layerIndex) {
      while (frameLayers[frameIndex].length <= layerIndex) {
        const layerCanvas = document.createElement('canvas');
        layerCanvas.width = canvases[frameIndex].width;
        layerCanvas.height = canvases[frameIndex].height;
        const layerCtx = layerCanvas.getContext('2d', { willReadFrequently: true });
        const newIndex = frameLayers[frameIndex].length;
        frameLayers[frameIndex].push({
          canvas: layerCanvas,
          ctx: layerCtx,
          visible: true,
          name: `Layer ${newIndex + 1}`,
          opacity: 1,
          color: layerColors[newIndex % layerColors.length]
        });
      }
    }
    function replicateInitialDotToOtherFrames(x, y) {
      if (currentBrushType !== 'animationPath') return;
      const targets = getDrawingTargetFrames();
      for (const idx of targets) {
        if (idx === currentFrame) continue;
        // Ensure guides overlay for target frame
        const base = canvases[idx];
        if (!base) continue;
        let gCanvas = guideCanvases[idx];
        let gCtx = guideContexts[idx];
        if (!gCanvas || !gCtx || gCanvas.width !== base.width || gCanvas.height !== base.height || !gCanvas.parentElement) {
          const container = base.parentElement;
          if (!container) continue;
          if (gCanvas && gCanvas.parentElement) gCanvas.parentElement.removeChild(gCanvas);
          gCanvas = document.createElement('canvas');
          gCanvas.id = `guides-${idx}`;
          gCanvas.width = base.width;
          gCanvas.height = base.height;
          gCanvas.style.position = 'absolute';
          gCanvas.style.top = '0';
          gCanvas.style.left = '0';
          gCanvas.style.width = '100%';
          gCanvas.style.height = '100%';
          gCanvas.style.pointerEvents = 'none';
          gCanvas.style.zIndex = '1001';
          gCanvas.style.transformOrigin = 'top left';
          gCanvas.style.transform = `scale(${zoomLevels[idx] || 1})`;
          gCtx = gCanvas.getContext('2d', { willReadFrequently: true });
          container.style.position = 'relative';
          container.appendChild(gCanvas);
          guideCanvases[idx] = gCanvas;
          guideContexts[idx] = gCtx;
        }
        gCtx.save();
        gCtx.globalAlpha = 0.28;
        gCtx.fillStyle = '#40E0D0';
        const lw = Math.max(1, Math.round(brushSize * 0.8));
        gCtx.beginPath();
        gCtx.arc(x, y, Math.max(1, lw / 2), 0, Math.PI * 2);
        gCtx.fill();
        gCtx.restore();
      }
    }
    function replicateStrokeToOtherFrames(prevX, prevY, x, y) {
      if (currentBrushType !== 'animationPath') return;
      const targets = getDrawingTargetFrames();
      for (const idx of targets) {
        if (idx === currentFrame) continue;
        const base = canvases[idx];
        if (!base) continue;
        let gCanvas = guideCanvases[idx];
        let gCtx = guideContexts[idx];
        if (!gCanvas || !gCtx || gCanvas.width !== base.width || gCanvas.height !== base.height || !gCanvas.parentElement) {
          const container = base.parentElement;
          if (!container) continue;
          if (gCanvas && gCanvas.parentElement) gCanvas.parentElement.removeChild(gCanvas);
          gCanvas = document.createElement('canvas');
          gCanvas.id = `guides-${idx}`;
          gCanvas.width = base.width;
          gCanvas.height = base.height;
          gCanvas.style.position = 'absolute';
          gCanvas.style.top = '0';
          gCanvas.style.left = '0';
          gCanvas.style.width = '100%';
          gCanvas.style.height = '100%';
          gCanvas.style.pointerEvents = 'none';
          gCanvas.style.zIndex = '1001';
          gCtx = gCanvas.getContext('2d', { willReadFrequently: true });
          container.style.position = 'relative';
          container.appendChild(gCanvas);
          guideCanvases[idx] = gCanvas;
          guideContexts[idx] = gCtx;
        }
        gCtx.save();
        gCtx.globalAlpha = 0.28;
        gCtx.strokeStyle = '#40E0D0';
        gCtx.lineWidth = Math.max(1, Math.round(brushSize * 0.8));
        gCtx.lineCap = 'round';
        gCtx.lineJoin = 'round';
        gCtx.beginPath();
        gCtx.moveTo(prevX, prevY);
        gCtx.lineTo(x, y);
        gCtx.stroke();
        gCtx.restore();
      }
    }

    function getCanvasCoordinates(canvas, clientX, clientY) {
      const rect = canvas.getBoundingClientRect();
      // Calculate the scale factor between displayed size and actual canvas size
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      
      // Get position relative to canvas and scale to actual canvas coordinates
      const x = (clientX - rect.left) * scaleX;
      const y = (clientY - rect.top) * scaleY;
      
      return { x, y };
    }

    function startDrawing(e) {
      const canvas = e.target;
      const frameIndex = canvases.indexOf(canvas);
      if (frameIndex !== currentFrame) return;

      isDrawing = true;
      const coords = getCanvasCoordinates(canvas, e.clientX, e.clientY);
      lastX = coords.x;
      lastY = coords.y;

      // Draw initial dot to prevent delay/burst effect
      if (currentTool === 'brush' || currentTool === 'pencil') {
        const layer = frameLayers[currentFrame][currentLayer];
        const ctx = layer.ctx;
        ctx.globalAlpha = brushOpacity;
        ctx.strokeStyle = currentColor;
        
        if (currentTool === 'pencil') {
          ctx.lineWidth = Math.max(1, brushSize / 2);
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';
          ctx.beginPath();
          ctx.arc(lastX, lastY, ctx.lineWidth / 2, 0, Math.PI * 2);
          ctx.fill();
        } else {
          // Draw initial brush dot
          drawWithBrushType(ctx, lastX, lastY, lastX, lastY);
        }
        
        ctx.globalAlpha = 1;
      } else if (currentTool === 'eraser') {
        const layer = frameLayers[currentFrame][currentLayer];
        const ctx = layer.ctx;
        ctx.globalCompositeOperation = 'destination-out';
        ctx.lineWidth = brushSize;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.beginPath();
        ctx.arc(lastX, lastY, brushSize / 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalCompositeOperation = 'source-over';
        // Also erase animation path overlay if present
        const gCtx = guideContexts[currentFrame];
        const gCanvas = guideCanvases[currentFrame];
        if (gCtx && gCanvas) {
          gCtx.save();
          gCtx.globalCompositeOperation = 'destination-out';
          gCtx.beginPath();
          gCtx.arc(lastX, lastY, brushSize / 2, 0, Math.PI * 2);
          gCtx.fill();
          gCtx.restore();
        }
      }

      // Replicate initial animation path dot to other frames
      if (currentTool === 'brush' && currentBrushType === 'animationPath') {
        replicateInitialDotToOtherFrames(lastX, lastY);
      }

      // GLOBAL IMAGE SELECTION/MANIPULATION (works across all tools)
      const layer = frameLayers[currentFrame][currentLayer];
      
      // First priority: check if clicking on handles of currently selected image
      if (selectedImageObject && currentTool !== 'bones') {
        // Validate the selection is still valid
        if (!validateSelectedImage()) {
          selectedImageObject = null;
          activeTransformHandle = null;
          endImageDrag();
          isDraggingImage = false;
          isResizingImage = false;
          isRotatingImage = false;
        } else {
          const handle = currentTool === 'select' ? getResizeHandleAtPoint(selectedImageObject, lastX, lastY) : null;
          if (handle) {
            // Clicking on a handle - always handle this regardless of tool
          if (handle === 'rotation') {
              // Begin rotation
            const geom = calculateSelectionHandleGeometry(selectedImageObject);
            const pv = geom.pivot || geom.center;
            rotationCenterX = pv.x;
            rotationCenterY = pv.y;
              rotationStartAngle = Math.atan2(lastY - rotationCenterY, lastX - rotationCenterX);
              rotationCurrentAngle = selectedImageObject.rotation || 0;
              // If this image is attached to a bone, compute pinned local offset to keep start node fixed during rotation
              try {
                let linked = null;
                for (let i = 0; i < bones.length; i++) {
                  const bb = bones[i];
                  if (!bb || bb.frameIndex !== currentFrame) continue;
                  if (bb.imageObj === selectedImageObject) { linked = bb; break; }
                }
                if (linked) {
                  const obj = selectedImageObject;
                  const baseW = (obj && obj.drawW != null) ? obj.drawW : ((obj && obj.img && (obj.img.naturalWidth || obj.img.width || obj.img.videoWidth)) || 0);
                  const baseH = (obj && obj.drawH != null) ? obj.drawH : ((obj && obj.img && (obj.img.naturalHeight || obj.img.height || obj.img.videoHeight)) || 0);
                  const effScaleX = (typeof obj.scaleX === 'number' ? obj.scaleX : 1);
                  const effScaleY = (typeof obj.scaleY === 'number' ? obj.scaleY : 1);
                  const w0 = baseW * (obj.scale || 1) * effScaleX;
                  const h0 = baseH * (obj.scale || 1) * effScaleY;
                  const cX = obj.x + w0 / 2;
                  const cY = obj.y + h0 / 2;
                  const rot = obj.rotation || 0;
                  const dx = linked.startX - cX;
                  const dy = linked.startY - cY;
                  const cos = Math.cos(rot), sin = Math.sin(rot);
                  linked.pinnedLocalX = dx * cos + dy * sin;
                  linked.pinnedLocalY = -dx * sin + dy * cos;
                }
              } catch (_e) {}
              saveState();
              beginImageDrag();
              isRotatingImage = true;
              activeTransformHandle = 'rotation';
              isDraggingImage = false;
              isResizingImage = false;
              return; // Don't continue to tool-specific logic
            } else if (handle === 'pivot') {
              // Begin pivot drag (no base redraw needed)
              saveState();
              isDraggingPivot = true;
              activeTransformHandle = 'pivot';
              refreshSelectionOverlay();
              return;
            } else {
              // Begin resize
              resizeCorner = handle;
              activeTransformHandle = handle;
              const baseW1 = (selectedImageObject && selectedImageObject.drawW != null)
                ? selectedImageObject.drawW
                : ((selectedImageObject && selectedImageObject.img && (selectedImageObject.img.naturalWidth || selectedImageObject.img.width || selectedImageObject.img.videoWidth)) || 0);
              const baseH1 = (selectedImageObject && selectedImageObject.drawH != null)
                ? selectedImageObject.drawH
                : ((selectedImageObject && selectedImageObject.img && (selectedImageObject.img.naturalHeight || selectedImageObject.img.height || selectedImageObject.img.videoHeight)) || 0);
              const w = baseW1 * (selectedImageObject.scale || 1) * (typeof selectedImageObject.scaleX === 'number' ? selectedImageObject.scaleX : 1);
              const h = baseH1 * (selectedImageObject.scale || 1) * (typeof selectedImageObject.scaleY === 'number' ? selectedImageObject.scaleY : 1);
              const centerX = selectedImageObject.x + w / 2;
              const centerY = selectedImageObject.y + h / 2;
              const rotation = selectedImageObject.rotation || 0;
              
              // Store initial state for relative resize calculations
              resizeStartX = lastX;
              resizeStartY = lastY;
              // Capture effective uniform scale at start (average of X/Y, including legacy 'scale')
              {
                const baseScale = (typeof selectedImageObject.scale === 'number') ? selectedImageObject.scale : 1;
                const sx0 = (typeof selectedImageObject.scaleX === 'number') ? selectedImageObject.scaleX : 1;
                const sy0 = (typeof selectedImageObject.scaleY === 'number') ? selectedImageObject.scaleY : 1;
                const effX0 = baseScale * sx0;
                const effY0 = baseScale * sy0;
                resizeStartScale = (effX0 + effY0) / 2;
              }
              resizeStartWidth = w;
              resizeStartHeight = h;
              resizeStartPosX = selectedImageObject.x;
              resizeStartPosY = selectedImageObject.y;
              
              // Calculate anchor point (opposite corner) accounting for rotation
              const rotatePoint = (px, py) => {
                const dx = px - centerX;
                const dy = py - centerY;
                return {
                  x: centerX + dx * Math.cos(rotation) - dy * Math.sin(rotation),
                  y: centerY + dx * Math.sin(rotation) + dy * Math.cos(rotation)
                };
              };
              
              if (handle === 'tl') { 
                const anchor = rotatePoint(selectedImageObject.x + w, selectedImageObject.y + h);
                resizeAnchorX = anchor.x; 
                resizeAnchorY = anchor.y; 
              }
              if (handle === 'tr') { 
                const anchor = rotatePoint(selectedImageObject.x, selectedImageObject.y + h);
                resizeAnchorX = anchor.x; 
                resizeAnchorY = anchor.y; 
              }
              if (handle === 'br') { 
                const anchor = rotatePoint(selectedImageObject.x, selectedImageObject.y);
                resizeAnchorX = anchor.x; 
                resizeAnchorY = anchor.y; 
              }
              if (handle === 'bl') { 
                const anchor = rotatePoint(selectedImageObject.x + w, selectedImageObject.y);
                resizeAnchorX = anchor.x; 
                resizeAnchorY = anchor.y; 
              }
              saveState();
              beginImageDrag();
              isResizingImage = true;
              isDraggingImage = false;
              isRotatingImage = false;
              return; // Don't continue to tool-specific logic
            }
          }
        }
      }
      
      // Second priority: check if clicking on any image (for selection or dragging)
      const hit = hitTestImage(layer, lastX, lastY);
      if (hit) {
        // Clicking on an image
        selectedImageObject = hit;
        if (currentTool === 'select') {
          // Only allow dragging images when select tool is active
          imageDragOffsetX = lastX - hit.x;
          imageDragOffsetY = lastY - hit.y;
          saveState();
          beginImageDrag();
          isDraggingImage = true;
          activeTransformHandle = null;
          isResizingImage = false;
          isRotatingImage = false;
          return; // Don't continue to tool-specific logic
        }
        // If not select tool, just select the image but continue with tool logic
      } else {
        // Clicked on empty space - clear selection
        selectedImageObject = null;
        endImageDrag();
        isDraggingImage = false;
        isResizingImage = false;
        isRotatingImage = false;
        activeTransformHandle = null;
      }

      // TOOL-SPECIFIC LOGIC (only executed if no image manipulation is happening)
      if (currentTool === 'lasso') {
        lassoPoints = [[lastX, lastY]];
        isLassoActive = true;
        
        // Create overlay canvas for lasso trail
        const canvas = canvases[currentFrame];
        const container = canvas.parentElement;
        
        if (lassoOverlayCanvas) {
          lassoOverlayCanvas.remove();
        }
        
        lassoOverlayCanvas = document.createElement('canvas');
        lassoOverlayCanvas.width = canvas.width;
        lassoOverlayCanvas.height = canvas.height;
        lassoOverlayCanvas.style.position = 'absolute';
        lassoOverlayCanvas.style.top = '0';
        lassoOverlayCanvas.style.left = '0';
        lassoOverlayCanvas.style.width = '100%';
        lassoOverlayCanvas.style.height = '100%';
        lassoOverlayCanvas.style.pointerEvents = 'none';
        lassoOverlayCanvas.style.zIndex = '9';
        lassoOverlayCtx = lassoOverlayCanvas.getContext('2d');
        
        container.style.position = 'relative';
        container.appendChild(lassoOverlayCanvas);
      } else if ((currentTool === 'select' && selectLassoEnabled) || currentTool === 'select-lasso') {
        // Start a freeform selection path (lasso-like) for select tool
        selectLassoPoints = [[lastX, lastY]];
        isSelectLassoActive = true;
        const canvas = canvases[currentFrame];
        const container = canvas.parentElement;
        if (lassoOverlayCanvas) {
          lassoOverlayCanvas.remove();
        }
        lassoOverlayCanvas = document.createElement('canvas');
        lassoOverlayCanvas.width = canvas.width;
        lassoOverlayCanvas.height = canvas.height;
        lassoOverlayCanvas.style.position = 'absolute';
        lassoOverlayCanvas.style.top = '0';
        lassoOverlayCanvas.style.left = '0';
        lassoOverlayCanvas.style.width = '100%';
        lassoOverlayCanvas.style.height = '100%';
        lassoOverlayCanvas.style.pointerEvents = 'none';
        lassoOverlayCanvas.style.zIndex = '9';
        lassoOverlayCtx = lassoOverlayCanvas.getContext('2d');
        container.style.position = 'relative';
        container.appendChild(lassoOverlayCanvas);
      } else if (currentTool === 'bones') {
        // First: try to grab an existing bone handle
        const handle = getBoneHandleAtPoint(lastX, lastY);
        if (handle) {
          saveState();
          boneDrag = handle;
          isDraggingBoneHandle = true;
          selectedBoneIndex = handle.boneIndex;
          // If rotating from end handle, capture pinned local offset so start node stays pinned during rotation
          try {
            if (handle.handle === 'end') {
              const b = bones[handle.boneIndex];
              if (b && b.imageObj) {
                const obj = b.imageObj;
                const baseW = (obj && obj.drawW != null) ? obj.drawW : ((obj && obj.img && (obj.img.naturalWidth || obj.img.width || obj.img.videoWidth)) || 0);
                const baseH = (obj && obj.drawH != null) ? obj.drawH : ((obj && obj.img && (obj.img.naturalHeight || obj.img.height || obj.img.videoHeight)) || 0);
                const effScaleX = (typeof obj.scaleX === 'number' ? obj.scaleX : 1);
                const effScaleY = (typeof obj.scaleY === 'number' ? obj.scaleY : 1);
                const w = baseW * (obj.scale || 1) * effScaleX;
                const h = baseH * (obj.scale || 1) * effScaleY;
                const centerX = obj.x + w / 2;
                const centerY = obj.y + h / 2;
                const rot = obj.rotation || 0;
                const dx = b.startX - centerX;
                const dy = b.startY - centerY;
                const cos = Math.cos(rot), sin = Math.sin(rot);
                b.pinnedLocalX = dx * cos + dy * sin;
                b.pinnedLocalY = -dx * sin + dy * cos;
              }
            }
          } catch (_e) {}
          ensureBonesOverlay();
          return;
        }
        // Otherwise start a lasso to define the piece for a new bone
        saveState();
        boneLassoPoints = [[lastX, lastY]];
        isBoneLassoActive = true;
        const canvas = canvases[currentFrame];
        const container = canvas.parentElement;
        if (lassoOverlayCanvas) {
          lassoOverlayCanvas.remove();
        }
        lassoOverlayCanvas = document.createElement('canvas');
        lassoOverlayCanvas.width = canvas.width;
        lassoOverlayCanvas.height = canvas.height;
        lassoOverlayCanvas.style.position = 'absolute';
        lassoOverlayCanvas.style.top = '0';
        lassoOverlayCanvas.style.left = '0';
        lassoOverlayCanvas.style.width = '100%';
        lassoOverlayCanvas.style.height = '100%';
        lassoOverlayCanvas.style.pointerEvents = 'none';
        lassoOverlayCanvas.style.zIndex = '9';
        lassoOverlayCtx = lassoOverlayCanvas.getContext('2d');
        container.style.position = 'relative';
        container.appendChild(lassoOverlayCanvas);
      } else if (currentTool === 'inbetween' || currentTool === 'detail' || currentTool === 'extend-lasso') {
        // Start a lasso to define the region for magic tool
        saveState();
        magicLassoMode = currentTool;
        magicLassoPoints = [[lastX, lastY]];
        isMagicLassoActive = true;
        const canvas = canvases[currentFrame];
        const container = canvas.parentElement;
        if (lassoOverlayCanvas) {
          lassoOverlayCanvas.remove();
        }
        lassoOverlayCanvas = document.createElement('canvas');
        lassoOverlayCanvas.width = canvas.width;
        lassoOverlayCanvas.height = canvas.height;
        lassoOverlayCanvas.style.position = 'absolute';
        lassoOverlayCanvas.style.top = '0';
        lassoOverlayCanvas.style.left = '0';
        lassoOverlayCanvas.style.width = '100%';
        lassoOverlayCanvas.style.height = '100%';
        lassoOverlayCanvas.style.pointerEvents = 'none';
        lassoOverlayCanvas.style.zIndex = '1000';
        lassoOverlayCtx = lassoOverlayCanvas.getContext('2d');
        container.style.position = 'relative';
        container.appendChild(lassoOverlayCanvas);
      } else if (currentTool === 'fill') {
        floodFill(lastX, lastY);
        composeLayers(currentFrame);
        updateThumbnail(currentFrame);
      } else if (currentTool === 'inner-fill') {
        innerFill(lastX, lastY);
        composeLayers(currentFrame);
        updateThumbnail(currentFrame);
      } else if (currentTool === 'color-picker') {
        pickColorFromCanvas(lastX, lastY);
      } else if (currentTool !== 'select') {
        saveState();
      }
    }

    function draw(e) {
      if (!isDrawing) return;

      const layer = frameLayers[currentFrame][currentLayer];
      const ctx = layer.ctx;
      const canvas = canvases[currentFrame];
      const coords = getCanvasCoordinates(canvas, e.clientX, e.clientY);
      const x = coords.x;
      const y = coords.y;

      // Bones handle drag (independent of image manipulation flags)
      if (currentTool === 'bones' && isDraggingBoneHandle && boneDrag) {
        const b = bones[boneDrag.boneIndex];
        if (b) {
          const dx = x - lastX;
          const dy = y - lastY;
          // Determine if the dragged handle is a joint (either attached to parent or has children attached)
          const isHandleAttachedToParent = (b.attachedAt === boneDrag.handle);
          let hasChildrenOnHandle = false;
          for (let i = 0; i < bones.length; i++) {
            const c = bones[i];
            if (!c || c.frameIndex !== currentFrame) continue;
            if (c.parentBoneIndex === boneDrag.boneIndex && c.parentAttach === boneDrag.handle) { hasChildrenOnHandle = true; break; }
          }
          const isJointDrag = isHandleAttachedToParent || hasChildrenOnHandle;

          if (isJointDrag) {
            if (boneDrag.handle === 'start') {
              // Translate entire connected component (no rotation) â€” do not move attached images
              const comp = getConnectedComponent(boneDrag.boneIndex);
              for (const idx of comp) {
                const n = bones[idx];
                if (!n || n.frameIndex !== currentFrame) continue;
                n.startX += dx; n.startY += dy;
                n.endX += dx; n.endY += dy;
              }
            } else {
              // End handle: rotate around start (no scaling)
              moveJointWithParentRotation(boneDrag.boneIndex, boneDrag.handle, x, y);
            }
          } else {
            // Normal handle move with new rules
            if (boneDrag.handle === 'start') {
              // Move only the start endpoint (no rotation); do not move the image or end
              b.startX += dx; b.startY += dy;
              // Clamp start to canvas
              try {
                const canvas = canvases && canvases[currentFrame];
                const cw = canvas ? canvas.width : 0;
                const ch = canvas ? canvas.height : 0;
                if (cw && ch) {
                  b.startX = Math.max(0, Math.min(cw, b.startX));
                  b.startY = Math.max(0, Math.min(ch, b.startY));
                }
              } catch (_e) {}
            } else {
              // End-handle drag: axial length adjust vs perpendicular rotation
              let ax = b.endX - b.startX, ay = b.endY - b.startY;
              let alen = Math.hypot(ax, ay);
              if (alen < 1e-6) { ax = (x - b.startX); ay = (y - b.startY); alen = Math.hypot(ax, ay) || 1; }
              const ux = ax / alen, uy = ay / alen;
              const ds = dx * ux + dy * uy;        // movement along axis
              const dp = -dx * uy + dy * ux;       // movement perpendicular
              if (Math.abs(ds) >= Math.abs(dp)) {
                // Adjust length along axis (no rotation)
                b.endX += ux * ds;
                b.endY += uy * ds;
                b.restLength = Math.hypot(b.endX - b.startX, b.endY - b.startY);
                // Clamp end to canvas
                try {
                  const canvas = canvases && canvases[currentFrame];
                  const cw = canvas ? canvas.width : 0;
                  const ch = canvas ? canvas.height : 0;
                  if (cw && ch) {
                    b.endX = Math.max(0, Math.min(cw, b.endX));
                    b.endY = Math.max(0, Math.min(ch, b.endY));
                  }
                } catch (_e) {}
              } else {
                // Rotate with fixed length around start
                const L = Math.max(0.0001, b.restLength || Math.hypot(b.endX - b.startX, b.endY - b.startY));
                const vx = x - b.startX, vy = y - b.startY;
                const len = Math.hypot(vx, vy) || 1;
                b.endX = b.startX + (vx / len) * L;
                b.endY = b.startY + (vy / len) * L;
                // Clamp end to canvas
                try {
                  const canvas = canvases && canvases[currentFrame];
                  const cw = canvas ? canvas.width : 0;
                  const ch = canvas ? canvas.height : 0;
                  if (cw && ch) {
                    b.endX = Math.max(0, Math.min(cw, b.endX));
                    b.endY = Math.max(0, Math.min(ch, b.endY));
                  }
                } catch (_e) {}
                if (b.imageObj) {
                  const rawAngle = Math.atan2(b.endY - b.startY, b.endX - b.startX);
                  const angle = unwrapAngle(b.prevAngle || rawAngle, rawAngle);
                  b.prevAngle = angle;
                  b.imageObj.rotation = (b.imageRotationOffset || 0) + angle;
                  const baseW = (b.imageObj && b.imageObj.drawW != null) ? b.imageObj.drawW : ((b.imageObj && b.imageObj.img && (b.imageObj.img.naturalWidth || b.imageObj.img.width || b.imageObj.img.videoWidth)) || 0);
                  const baseH = (b.imageObj && b.imageObj.drawH != null) ? b.imageObj.drawH : ((b.imageObj && b.imageObj.img && (b.imageObj.img.naturalHeight || b.imageObj.img.height || b.imageObj.img.videoHeight)) || 0);
                  const effScaleX = (typeof b.imageObj.scaleX === 'number' ? b.imageObj.scaleX : 1);
                  const effScaleY = (typeof b.imageObj.scaleY === 'number' ? b.imageObj.scaleY : 1);
                  const w = baseW * (b.imageObj.scale || 1) * effScaleX;
                  const h = baseH * (b.imageObj.scale || 1) * effScaleY;
                  // Keep start node pinned using pinned local offset if available
                  const px = (typeof b.pinnedLocalX === 'number') ? b.pinnedLocalX : 0;
                  const py = (typeof b.pinnedLocalY === 'number') ? b.pinnedLocalY : 0;
                  const cos = Math.cos(b.imageObj.rotation || 0), sin = Math.sin(b.imageObj.rotation || 0);
                  const rx = px * cos - py * sin;
                  const ry = px * sin + py * cos;
                  const centerX = b.startX - rx;
                  const centerY = b.startY - ry;
                  b.imageObj.x = centerX - w / 2;
                  b.imageObj.y = centerY - h / 2;
                }
              }
            }
          }

          // Throttle composition and overlay drawing to once per frame
          if (!composeRafScheduled) {
            composeRafScheduled = true;
            requestAnimationFrame(() => {
              composeRafScheduled = false;
              composeLayers(currentFrame);
              updateThumbnail(currentFrame);
            });
          }
          scheduleDrawBonesOverlay();
        }
        lastX = x; lastY = y;
        return;
      }

      // GLOBAL IMAGE MANIPULATION (works across all tools)
      if (selectedImageObject && isRotatingImage) {
        // Handle rotation
        const currentAngle = Math.atan2(y - rotationCenterY, x - rotationCenterX);
        const angleDelta = currentAngle - rotationStartAngle;
        selectedImageObject.rotation = rotationCurrentAngle + angleDelta;
        // If attached to a bone, shift position to keep start node pinned; else keep pivot fixed
        let hadLinked = false;
        try {
          let linked = null;
          for (let i = 0; i < bones.length; i++) {
            const bb = bones[i];
            if (!bb || bb.frameIndex !== currentFrame) continue;
            if (bb.imageObj === selectedImageObject) { linked = bb; break; }
          }
          if (linked) {
            const obj = selectedImageObject;
            const baseW = (obj && obj.drawW != null) ? obj.drawW : ((obj && obj.img && (obj.img.naturalWidth || obj.img.width || obj.img.videoWidth)) || 0);
            const baseH = (obj && obj.drawH != null) ? obj.drawH : ((obj && obj.img && (obj.img.naturalHeight || obj.img.height || obj.img.videoHeight)) || 0);
            const effScaleX = (typeof obj.scaleX === 'number' ? obj.scaleX : 1);
            const effScaleY = (typeof obj.scaleY === 'number' ? obj.scaleY : 1);
            const w = baseW * (obj.scale || 1) * effScaleX;
            const h = baseH * (obj.scale || 1) * effScaleY;
            const px = (typeof linked.pinnedLocalX === 'number') ? linked.pinnedLocalX : 0;
            const py = (typeof linked.pinnedLocalY === 'number') ? linked.pinnedLocalY : 0;
            const rot = obj.rotation || 0;
            const cos = Math.cos(rot), sin = Math.sin(rot);
            const rx = px * cos - py * sin;
            const ry = px * sin + py * cos;
            const centerX = linked.startX - rx;
            const centerY = linked.startY - ry;
            obj.x = centerX - w / 2;
            obj.y = centerY - h / 2;
            hadLinked = true;
          }
        } catch (_e) {}
        if (!hadLinked) {
          // Keep pivot fixed by adjusting position when rotating
          const obj = selectedImageObject;
          const objScaleX = (obj && typeof obj.scaleX === 'number') ? obj.scaleX : 1;
          const objScaleY = (obj && typeof obj.scaleY === 'number') ? obj.scaleY : 1;
          const baseW = (obj && obj.drawW != null) ? obj.drawW : ((obj && obj.img && (obj.img.naturalWidth || obj.img.width || obj.img.videoWidth)) || 0);
          const baseH = (obj && obj.drawH != null) ? obj.drawH : ((obj && obj.img && (obj.img.naturalHeight || obj.img.height || obj.img.videoHeight)) || 0);
          const w = baseW * (obj.scale || 1) * objScaleX;
          const h = baseH * (obj.scale || 1) * objScaleY;
          const dpx = ((typeof obj.pivotLocalX === 'number') ? obj.pivotLocalX : (w / 2)) - (w / 2);
          const dpy = ((typeof obj.pivotLocalY === 'number') ? obj.pivotLocalY : (h / 2)) - (h / 2);
          const rot = obj.rotation || 0;
          const cx = rotationCenterX - (dpx * Math.cos(rot) - dpy * Math.sin(rot));
          const cy = rotationCenterY - (dpx * Math.sin(rot) + dpy * Math.cos(rot));
          obj.x = cx - w / 2;
          obj.y = cy - h / 2;
        }
        const geometry = calculateSelectionHandleGeometry(selectedImageObject);
        if (geometry && geometry.direction) {
          const relX = x - rotationCenterX;
          const relY = y - rotationCenterY;
          const projection = relX * geometry.direction.x + relY * geometry.direction.y;
          selectedImageObject.rotationHandleDistance = Math.max(0, projection);
        }
        renderImageDrag(selectedImageObject.x, selectedImageObject.y);
        lastX = x;
        lastY = y;
        return; // Don't continue to tool-specific logic
      } else if (selectedImageObject && isDraggingPivot) {
        const obj = selectedImageObject;
        const objScaleX = (obj && typeof obj.scaleX === 'number') ? obj.scaleX : 1;
        const objScaleY = (obj && typeof obj.scaleY === 'number') ? obj.scaleY : 1;
        const baseW = (obj && obj.drawW != null) ? obj.drawW : ((obj && obj.img && (obj.img.naturalWidth || obj.img.width || obj.img.videoWidth)) || 0);
        const baseH = (obj && obj.drawH != null) ? obj.drawH : ((obj && obj.img && (obj.img.naturalHeight || obj.img.height || obj.img.videoHeight)) || 0);
        const w = baseW * (obj.scale || 1) * objScaleX;
        const h = baseH * (obj.scale || 1) * objScaleY;
        const centerX = obj.x + w / 2;
        const centerY = obj.y + h / 2;
        const rot = obj.rotation || 0;
        const dx = x - centerX;
        const dy = y - centerY;
        const localX = centerX + dx * Math.cos(-rot) - dy * Math.sin(-rot);
        const localY = centerY + dx * Math.sin(-rot) + dy * Math.cos(-rot);
        obj.pivotLocalX = Math.max(0, Math.min(w, localX - obj.x));
        obj.pivotLocalY = Math.max(0, Math.min(h, localY - obj.y));
        try {
          const geom = calculateSelectionHandleGeometry(obj);
          const baseLen = Math.hypot(geom.topMid.x - geom.pivot.x, geom.topMid.y - geom.pivot.y);
          obj.rotationHandleDistance = baseLen + ROTATION_HANDLE_OFFSET;
        } catch (_e) {}
        refreshSelectionOverlay();
        lastX = x;
        lastY = y;
        return;
      } else if (selectedImageObject && isResizingImage) {
        // Only start resizing after mouse has moved a minimum distance (prevents jumps on click)
        const dragDistance = Math.sqrt(
          Math.pow(x - resizeStartX, 2) + Math.pow(y - resizeStartY, 2)
        );
        if (dragDistance < 3) {
          // Too small movement, don't resize yet
          lastX = x;
          lastY = y;
          return;
        }
        
        // Compute resize based on distance from anchor point along rotated axis
        const rotation = selectedImageObject.rotation || 0;
        
        // Calculate current distance from anchor
        const currentDist = Math.sqrt(
          Math.pow(x - resizeAnchorX, 2) + Math.pow(y - resizeAnchorY, 2)
        );
        
        // Calculate initial distance from anchor
        const initialDist = Math.sqrt(
          Math.pow(resizeStartX - resizeAnchorX, 2) + Math.pow(resizeStartY - resizeAnchorY, 2)
        );
        
        // Avoid division by zero and jumps from near-zero distances
        if (initialDist < 5) {
          lastX = x;
          lastY = y;
          return;
        }
        
        // Calculate scale factor based on distance ratio
        const scaleFactor = currentDist / initialDist;
        const newScale = Math.max(0.01, resizeStartScale * scaleFactor);
        
        const baseW = (selectedImageObject && selectedImageObject.drawW != null)
          ? selectedImageObject.drawW
          : ((selectedImageObject && selectedImageObject.img && (selectedImageObject.img.naturalWidth || selectedImageObject.img.width || selectedImageObject.img.videoWidth)) || 0);
        const baseH = (selectedImageObject && selectedImageObject.drawH != null)
          ? selectedImageObject.drawH
          : ((selectedImageObject && selectedImageObject.img && (selectedImageObject.img.naturalHeight || selectedImageObject.img.height || selectedImageObject.img.videoHeight)) || 0);
        const drawW = baseW * newScale;
        const drawH = baseH * newScale;
        // Centered scaling (extend all corners equally): keep the center fixed like in Cut Out mode
        const startCenterX = resizeStartPosX + resizeStartWidth / 2;
        const startCenterY = resizeStartPosY + resizeStartHeight / 2;
        const newX = startCenterX - drawW / 2;
        const newY = startCenterY - drawH / 2;
        
        // Render and update live (use per-axis uniform scale; keep legacy 'scale' neutral to avoid double-multiplying)
        selectedImageObject.scale = 1;
        selectedImageObject.scaleX = newScale;
        selectedImageObject.scaleY = newScale;
        selectedImageObject.x = newX;
        selectedImageObject.y = newY;
        renderImageDrag(newX, newY);
        lastX = x;
        lastY = y;
        return; // Don't continue to tool-specific logic
      } else if (selectedImageObject && isDraggingImage) {
        const newX = x - imageDragOffsetX;
        const newY = y - imageDragOffsetY;
        const dx = newX - selectedImageObject.x;
        const dy = newY - selectedImageObject.y;
        renderImageDrag(newX, newY);
        selectedImageObject.x = newX;
        selectedImageObject.y = newY;
        // Move any bones attached to this image along with it
        try {
          for (let i = 0; i < bones.length; i++) {
            const b = bones[i];
            if (!b || b.frameIndex !== currentFrame) continue;
            if (b.imageObj === selectedImageObject) {
              b.startX += dx; b.startY += dy;
              b.endX += dx; b.endY += dy;
              // Clamp to canvas
              try {
                const canvas = canvases && canvases[currentFrame];
                const cw = canvas ? canvas.width : 0;
                const ch = canvas ? canvas.height : 0;
                if (cw && ch) {
                  b.startX = Math.max(0, Math.min(cw, b.startX));
                  b.startY = Math.max(0, Math.min(ch, b.startY));
                  b.endX = Math.max(0, Math.min(cw, b.endX));
                  b.endY = Math.max(0, Math.min(ch, b.endY));
                }
              } catch (_e) {}
            }
          }
        } catch (_e) {}
        lastX = x;
        lastY = y;
        return; // Don't continue to tool-specific logic
      }

      // TOOL-SPECIFIC LOGIC (only executed if no image manipulation is happening)
      if (currentTool === 'lasso') {
        lassoPoints.push([x, y]);
        // Redraw the entire lasso path each move for precise following
        if (lassoOverlayCtx) {
          const w = lassoOverlayCanvas.width;
          const h = lassoOverlayCanvas.height;
          lassoOverlayCtx.clearRect(0, 0, w, h);
          lassoOverlayCtx.strokeStyle = '#ffffff';
          lassoOverlayCtx.lineWidth = 2;
          lassoOverlayCtx.setLineDash([8, 4]);
          lassoOverlayCtx.beginPath();
          lassoOverlayCtx.moveTo(lassoPoints[0][0], lassoPoints[0][1]);
          for (let i = 1; i < lassoPoints.length; i++) {
            lassoOverlayCtx.lineTo(lassoPoints[i][0], lassoPoints[i][1]);
          }
          lassoOverlayCtx.stroke();
          lassoOverlayCtx.setLineDash([]);
        }
      } else if ((currentTool === 'select' && isSelectLassoActive) || (currentTool === 'select-lasso' && isSelectLassoActive)) {
        selectLassoPoints.push([x, y]);
        if (lassoOverlayCtx) {
          const w = lassoOverlayCanvas.width;
          const h = lassoOverlayCanvas.height;
          lassoOverlayCtx.clearRect(0, 0, w, h);
          lassoOverlayCtx.strokeStyle = '#ffffff';
          lassoOverlayCtx.lineWidth = 2;
          lassoOverlayCtx.setLineDash([8, 4]);
          lassoOverlayCtx.beginPath();
          lassoOverlayCtx.moveTo(selectLassoPoints[0][0], selectLassoPoints[0][1]);
          for (let i = 1; i < selectLassoPoints.length; i++) {
            lassoOverlayCtx.lineTo(selectLassoPoints[i][0], selectLassoPoints[i][1]);
          }
          lassoOverlayCtx.stroke();
          lassoOverlayCtx.setLineDash([]);
        }
      } else if (currentTool === 'bones' && isBoneLassoActive) {
        boneLassoPoints.push([x, y]);
        if (lassoOverlayCtx) {
          const w = lassoOverlayCanvas.width;
          const h = lassoOverlayCanvas.height;
          lassoOverlayCtx.clearRect(0, 0, w, h);
          lassoOverlayCtx.strokeStyle = '#ffffff';
          lassoOverlayCtx.lineWidth = 2;
          lassoOverlayCtx.setLineDash([8, 4]);
          lassoOverlayCtx.beginPath();
          lassoOverlayCtx.moveTo(boneLassoPoints[0][0], boneLassoPoints[0][1]);
          for (let i = 1; i < boneLassoPoints.length; i++) {
            lassoOverlayCtx.lineTo(boneLassoPoints[i][0], boneLassoPoints[i][1]);
          }
          lassoOverlayCtx.stroke();
          lassoOverlayCtx.setLineDash([]);
        }
      } else if ((currentTool === 'inbetween' || currentTool === 'detail' || currentTool === 'extend-lasso') && isMagicLassoActive) {
        magicLassoPoints.push([x, y]);
        if (lassoOverlayCtx) {
          const w = lassoOverlayCanvas.width;
          const h = lassoOverlayCanvas.height;
          lassoOverlayCtx.clearRect(0, 0, w, h);
          lassoOverlayCtx.strokeStyle = 'rgba(16,185,129,0.95)';
          lassoOverlayCtx.lineWidth = 2;
          lassoOverlayCtx.setLineDash([8, 4]);
          lassoOverlayCtx.beginPath();
          lassoOverlayCtx.moveTo(magicLassoPoints[0][0], magicLassoPoints[0][1]);
          for (let i = 1; i < magicLassoPoints.length; i++) {
            lassoOverlayCtx.lineTo(magicLassoPoints[i][0], magicLassoPoints[i][1]);
          }
          lassoOverlayCtx.stroke();
          lassoOverlayCtx.setLineDash([]);
        }
      } else if (currentTool === 'brush' || currentTool === 'pencil') {
        ctx.globalAlpha = brushOpacity;
        ctx.strokeStyle = currentColor;
        
        if (currentTool === 'pencil') {
          ctx.lineWidth = Math.max(1, brushSize / 2);
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';
        } else {
          // Handle different brush types
          drawWithBrushType(ctx, lastX, lastY, x, y);
        }
        
        if (currentTool === 'pencil') {
          ctx.beginPath();
          ctx.moveTo(lastX, lastY);
          ctx.lineTo(x, y);
          ctx.stroke();
        }
        
        ctx.globalAlpha = 1;

        // Replicate the animation path stroke segment to other frames
        if (currentBrushType === 'animationPath') {
          replicateStrokeToOtherFrames(lastX, lastY, x, y);
        }
      } else if (currentTool === 'eraser') {
        ctx.globalCompositeOperation = 'destination-out';
        ctx.lineWidth = brushSize;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.beginPath();
        ctx.moveTo(lastX, lastY);
        ctx.lineTo(x, y);
        ctx.stroke();
        ctx.globalCompositeOperation = 'source-over';
        // Also erase animation path overlay if present
        const gCtx = guideContexts[currentFrame];
        const gCanvas = guideCanvases[currentFrame];
        if (gCtx && gCanvas) {
          gCtx.save();
          gCtx.globalCompositeOperation = 'destination-out';
          gCtx.lineWidth = brushSize;
          gCtx.lineCap = 'round';
          gCtx.lineJoin = 'round';
          gCtx.beginPath();
          gCtx.moveTo(lastX, lastY);
          gCtx.lineTo(x, y);
          gCtx.stroke();
          gCtx.restore();
        }
      }

      lastX = x;
      lastY = y;
      
      if (currentTool !== 'select') {
        if (!composeRafScheduled) {
          composeRafScheduled = true;
          requestAnimationFrame(() => {
            composeRafScheduled = false;
            // Compose all affected frames for consistent thumbnails and onion skin
            const targets = getDrawingTargetFrames();
            for (const idx of targets) {
              composeLayers(idx);
              updateThumbnail(idx);
            }
          });
        }
      }
    }

    function stopDrawing() {
      if (!isDrawing) return;
      isDrawing = false;

      if (currentTool === 'lasso' && isLassoActive) {
        // Snapshot before erase so undo removes only this lasso
        try { saveState(); } catch (_e) {}
        // Perform the lasso erase operation
        eraseLassoSelection();
        
        // Remove the overlay canvas immediately
        if (lassoOverlayCanvas) {
          lassoOverlayCanvas.remove();
          lassoOverlayCanvas = null;
          lassoOverlayCtx = null;
        }
        
        isLassoActive = false;
        lassoPoints = [];
        // Post-action snapshot for redo
        saveState();
      } else if ((currentTool === 'select' && isSelectLassoActive) || (currentTool === 'select-lasso' && isSelectLassoActive)) {
        // Create a transformable selection from the polygon
        createSelectionFromPolygon();
        if (lassoOverlayCanvas) {
          lassoOverlayCanvas.remove();
          lassoOverlayCanvas = null;
          lassoOverlayCtx = null;
        }
        isSelectLassoActive = false;
        selectLassoPoints = [];
        // Post-action snapshot for redo
        saveState();
      } else if (currentTool === 'bones' && isBoneLassoActive) {
        // Create a transformable selection and attach a bone to it
        createSelectionFromPolygonForBones().then((res) => {
          if (res && res.obj) {
            // Compute principal axis from the lasso polygon for precise alignment
            const { cx, cy, angle, minProj, maxProj, vx, vy } = computePrincipalAxis(boneLassoPoints);
            const startX = cx + vx * minProj;
            const startY = cy + vy * minProj;
            const endX   = cx + vx * maxProj;
            const endY   = cy + vy * maxProj;
            const restLength = Math.hypot(endX - startX, endY - startY);
            const initialScale = res.obj.scale;
            const initialAngle = Math.atan2(endY - startY, endX - startX);
              // Clamp endpoints to canvas bounds before creating
              try {
                const canvas = canvases && canvases[currentFrame];
                const cw = canvas ? canvas.width : 0;
                const ch = canvas ? canvas.height : 0;
                if (cw && ch) {
                  startX = Math.max(0, Math.min(cw, startX));
                  startY = Math.max(0, Math.min(ch, startY));
                  endX = Math.max(0, Math.min(cw, endX));
                  endY = Math.max(0, Math.min(ch, endY));
                }
              } catch (_e) {}
              bones.push({
              frameIndex: currentFrame,
              layerIndex: currentLayer,
              imageObj: res.obj,
              startX, startY, endX, endY,
              restLength,
              initialScale,
              restAngle: initialAngle,
              prevAngle: initialAngle,
              imageRotationOffset: (res.obj.rotation || 0) - initialAngle
            });
            // Post-action snapshot for redo
            saveState();
            ensureBonesOverlay();
            drawBonesOverlay();
          }
        }).finally(() => {
          if (lassoOverlayCanvas) {
            lassoOverlayCanvas.remove();
            lassoOverlayCanvas = null;
            lassoOverlayCtx = null;
          }
          isBoneLassoActive = false;
          boneLassoPoints = [];
        });
      } else if ((currentTool === 'inbetween' || currentTool === 'mirror' || currentTool === 'detail' || currentTool === 'extend-lasso') && isMagicLassoActive) {
        const layer = frameLayers[currentFrame][currentLayer];
        const baseCtx = layer.ctx;
        const baseCanvas = layer.canvas;
        if (magicLassoPoints.length >= 3) {
          // Compute bbox
          let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
          for (const p of magicLassoPoints) { if (p[0] < minX) minX = p[0]; if (p[1] < minY) minY = p[1]; if (p[0] > maxX) maxX = p[0]; if (p[1] > maxY) maxY = p[1]; }
          const w = baseCanvas.width, h = baseCanvas.height;

          if (magicLassoMode === 'inbetween') {
            // Build blended adjacent frames
            const prevIndex = currentFrame - 1;
            const nextIndex = currentFrame + 1;
            const hasPrev = prevIndex >= 0 && frameLayers[prevIndex] && frameLayers[prevIndex].length > 0;
            const hasNext = nextIndex < frameLayers.length && frameLayers[nextIndex] && frameLayers[nextIndex].length > 0;
            if (hasPrev || hasNext) {
              const mixCanvas = document.createElement('canvas');
              mixCanvas.width = w; mixCanvas.height = h;
              const mixCtx = mixCanvas.getContext('2d', { willReadFrequently: true });
              const renderFrameInto = (ctx, frameIdx, alpha = 1) => {
                const layers = frameLayers[frameIdx] || [];
                ctx.save();
                for (const l of layers) {
                  if (!l || !l.visible) continue;
                  ctx.globalAlpha = alpha * (l.opacity != null ? l.opacity : 1);
                  ctx.drawImage(l.canvas, 0, 0);
                  if (Array.isArray(l.images)) {
                    for (const obj of l.images) drawRotatedImage(ctx, obj);
                  }
                }
                ctx.restore();
              };
              if (hasPrev && hasNext) { renderFrameInto(mixCtx, prevIndex, 0.5); renderFrameInto(mixCtx, nextIndex, 0.5); }
              else if (hasPrev) { renderFrameInto(mixCtx, prevIndex, 1); }
              else if (hasNext) { renderFrameInto(mixCtx, nextIndex, 1); }

              // Clip and draw into current layer
              baseCtx.save();
              baseCtx.beginPath();
              baseCtx.moveTo(magicLassoPoints[0][0], magicLassoPoints[0][1]);
              for (let i = 1; i < magicLassoPoints.length; i++) baseCtx.lineTo(magicLassoPoints[i][0], magicLassoPoints[i][1]);
              baseCtx.closePath();
              baseCtx.clip();
              baseCtx.drawImage(mixCanvas, 0, 0);
              baseCtx.restore();
              composeLayers(currentFrame);
              updateThumbnail(currentFrame);
            } else {
              if (typeof showCopyPasteFeedback === 'function') showCopyPasteFeedback('No adjacent frames to blend');
            }
          } else if (magicLassoMode === 'detail') {
            const selW = Math.max(1, Math.ceil(maxX) - Math.floor(minX));
            const selH = Math.max(1, Math.ceil(maxY) - Math.floor(minY));
            const bx = Math.max(0, Math.floor(minX));
            const by = Math.max(0, Math.floor(minY));
            const srcData = baseCtx.getImageData(bx, by, selW, selH);
            const data = srcData.data;
            const total = selW * selH;
            // Create blurred copy (box blur radius 1, separable)
            const blur = new Uint8ClampedArray(data.length);
            const tmp = new Uint8ClampedArray(data.length);
            // Horizontal
            for (let y = 0; y < selH; y++) {
              for (let x = 0; x < selW; x++) {
                let r = 0, g = 0, b = 0;
                for (let k = -1; k <= 1; k++) {
                  const xx = Math.min(selW - 1, Math.max(0, x + k));
                  const idx = (y * selW + xx) * 4;
                  r += data[idx]; g += data[idx + 1]; b += data[idx + 2];
                }
                const di = (y * selW + x) * 4;
                tmp[di] = r / 3; tmp[di + 1] = g / 3; tmp[di + 2] = b / 3; tmp[di + 3] = data[di + 3];
              }
            }
            // Vertical
            for (let y = 0; y < selH; y++) {
              for (let x = 0; x < selW; x++) {
                let r = 0, g = 0, b = 0;
                for (let k = -1; k <= 1; k++) {
                  const yy = Math.min(selH - 1, Math.max(0, y + k));
                  const idx = (yy * selW + x) * 4;
                  r += tmp[idx]; g += tmp[idx + 1]; b += tmp[idx + 2];
                }
                const di = (y * selW + x) * 4;
                blur[di] = r / 3; blur[di + 1] = g / 3; blur[di + 2] = b / 3; blur[di + 3] = data[di + 3];
              }
            }
            // Grayscale for Sobel
            const gray = new Float32Array(selW * selH);
            for (let i = 0; i < total; i++) {
              const di = i * 4;
              gray[i] = 0.299 * data[di] + 0.587 * data[di + 1] + 0.114 * data[di + 2];
            }
            const sobel = new Float32Array(selW * selH);
            const gxField = new Float32Array(selW * selH);
            const gyField = new Float32Array(selW * selH);
            const gxK = [-1, 0, 1, -2, 0, 2, -1, 0, 1];
            const gyK = [-1, -2, -1, 0, 0, 0, 1, 2, 1];
            for (let y = 1; y < selH - 1; y++) {
              for (let x = 1; x < selW - 1; x++) {
                let gx = 0, gy = 0, ki = 0;
                for (let ky = -1; ky <= 1; ky++) {
                  for (let kx = -1; kx <= 1; kx++) {
                    const v = gray[(y + ky) * selW + (x + kx)];
                    gx += v * gxK[ki];
                    gy += v * gyK[ki];
                    ki++;
                  }
                }
                const mag = Math.min(255, Math.hypot(gx, gy));
                sobel[y * selW + x] = mag;
                gxField[y * selW + x] = gx;
                gyField[y * selW + x] = gy;
              }
            }
            // Apply unsharp mask + edge darken + style-specific color and grain
            let amount = 0.6;
            let edgeBoost = 0.6;
            let desat = 0.12;
            let grain = 12;
            let tintR = 0, tintG = 0, tintB = 0;

            switch (detailStyle) {
              case 'comic':
                amount = 0.8;
                edgeBoost = 0.9;
                desat = 0.2;
                grain = 4;
                break;
              case 'sketch':
                amount = 0.7;
                edgeBoost = 0.7;
                desat = 0.25;
                grain = 14;
                break;
              case 'slender':
                amount = 0.85;
                edgeBoost = 0.9;
                desat = 0.6;
                grain = 14;
                break;
              case 'oil':
                amount = -0.1;
                edgeBoost = 0.2;
                desat = 0.1;
                grain = 3;
                tintR = 8; tintG = 6; tintB = 0;
                break;
              default:
                break;
            }
            for (let y = 0; y < selH; y++) {
              for (let x = 0; x < selW; x++) {
                const i = y * selW + x;
                const di = i * 4;
                let r = data[di], g = data[di + 1], b = data[di + 2];
                const br = blur[di], bg = blur[di + 1], bb = blur[di + 2];
                // Unsharp
                r = r + amount * (r - br);
                g = g + amount * (g - bg);
                b = b + amount * (b - bb);
                // Edge darkening (multiply-like)
                const e = sobel[i] / 255;
                const factor = 1 - edgeBoost * e;
                r *= factor; g *= factor; b *= factor;
                // Base desaturation
                const lum = 0.299 * r + 0.587 * g + 0.114 * b;
                r = r * (1 - desat) + lum * desat;
                g = g * (1 - desat) + lum * desat;
                b = b * (1 - desat) + lum * desat;
                // Style specifics
                if (detailStyle === 'comic') {
                  const q = (v) => Math.round(v / 36) * 36;
                  r = q(r); g = q(g); b = q(b);
                  let nseed = Math.sin(x * 12.9898 + y * 78.233) * 43758.5453;
                  const n = nseed - Math.floor(nseed);
                  const shade = 0.85 + 0.3 * (n - 0.5) * (0.5 + 0.5 * e);
                  r *= shade; g *= shade; b *= shade;
                } else if (detailStyle === 'sketch') {
                  const mono = lum;
                  r = r * 0.2 + mono * 0.8;
                  g = g * 0.2 + mono * 0.8;
                  b = b * 0.2 + mono * 0.8;
                  let nseed = Math.sin((x + 0.5) * 12.9898 + (y - 0.5) * 78.233) * 43758.5453;
                  const n = nseed - Math.floor(nseed);
                  const grainShade = 0.9 + 0.2 * (n - 0.5);
                  const edge2 = 0.85 + 0.15 * e;
                  r *= grainShade * edge2;
                  g *= grainShade * edge2;
                  b *= grainShade * edge2;
                } else if (detailStyle === 'slender') {
                  if (lum < 60) { r += 10; g += 8; }
                  const jy = Math.max(0, y - 1);
                  const j = (jy * selW + x) * 4;
                  r = r * 0.9 + srcData.data[j] * 0.1;
                  g = g * 0.9 + srcData.data[j + 1] * 0.1;
                  b = b * 0.9 + srcData.data[j + 2] * 0.1;
                  const edgeVignette = Math.min(x / selW, y / selH, (selW - 1 - x) / selW, (selH - 1 - y) / selH);
                  const darken = 0.8 + 0.2 * edgeVignette;
                  r *= darken; g *= darken; b *= darken;
                } else if (detailStyle === 'oil') {
                  let ar = 0, ag = 0, ab = 0, cnt = 0;
                  for (let oy = -1; oy <= 1; oy++) {
                    for (let ox = -1; ox <= 1; ox++) {
                      const nx = Math.max(0, Math.min(selW - 1, x + ox));
                      const ny = Math.max(0, Math.min(selH - 1, y + oy));
                      const ni = (ny * selW + nx) * 4;
                      ar += srcData.data[ni];
                      ag += srcData.data[ni + 1];
                      ab += srcData.data[ni + 2];
                      cnt++;
                    }
                  }
                  ar /= cnt; ag /= cnt; ab /= cnt;
                  r = r * 0.3 + ar * 0.7;
                  g = g * 0.3 + ag * 0.7;
                  b = b * 0.3 + ab * 0.7;
                  const step = 12;
                  r = Math.round(r / step) * step;
                  g = Math.round(g / step) * step;
                  b = Math.round(b / step) * step;
                  let nseed2 = Math.sin(x * 2.0 + y * 3.0) * 43758.5453;
                  const n2 = nseed2 - Math.floor(nseed2);
                  const tex = 1 + 0.03 * (n2 - 0.5);
                  r *= tex; g *= tex; b *= tex;
                }
                // Style tints
                r += tintR; g += tintG; b += tintB;
                // Grain
                r += (Math.random() * 2 - 1) * grain;
                g += (Math.random() * 2 - 1) * grain;
                b += (Math.random() * 2 - 1) * grain;
                // Clamp
                data[di] = Math.max(0, Math.min(255, r));
                data[di + 1] = Math.max(0, Math.min(255, g));
                data[di + 2] = Math.max(0, Math.min(255, b));
              }
            }
            // No post overlay for current styles
            // Draw processed region clipped to polygon
            const proc = document.createElement('canvas');
            proc.width = selW; proc.height = selH;
            const pctx = proc.getContext('2d');
            pctx.putImageData(srcData, 0, 0);
            baseCtx.save();
            baseCtx.beginPath();
            baseCtx.moveTo(magicLassoPoints[0][0], magicLassoPoints[0][1]);
            for (let i = 1; i < magicLassoPoints.length; i++) baseCtx.lineTo(magicLassoPoints[i][0], magicLassoPoints[i][1]);
            baseCtx.closePath();
            baseCtx.clip();
            baseCtx.drawImage(proc, bx, by);
            baseCtx.restore();
            composeLayers(currentFrame);
            updateThumbnail(currentFrame);
          } else if (magicLassoMode === 'extend-lasso') {
            try {
              applyExtendLasso(baseCtx, magicLassoPoints);
            } catch (_e) { /* ignore */ }
            composeLayers(currentFrame);
            updateThumbnail(currentFrame);
          } 
        }
        // Cleanup overlay and state
        if (lassoOverlayCanvas) {
          lassoOverlayCanvas.remove();
          lassoOverlayCanvas = null;
          lassoOverlayCtx = null;
        }
        isMagicLassoActive = false;
        magicLassoPoints = [];
        magicLassoMode = null;
        // Post snapshot
        saveState();
      }
      
      // GLOBAL: Always handle image manipulation end, regardless of current tool
      if (isDraggingImage || isResizingImage || isRotatingImage || isDraggingPivot) {
        // Validate selection before finishing
        if (selectedImageObject && !validateSelectedImage()) {
          selectedImageObject = null;
        }
        
        endImageDrag();
        isDraggingImage = false;
        isResizingImage = false;
        isRotatingImage = false;
        isDraggingPivot = false;
        activeTransformHandle = null;
        
        if (selectedImageObject) {
          // keep selection active and show handles persistently
          // Force refresh of the overlay with current position
          refreshSelectionOverlay();
          updateThumbnail(currentFrame);
        }
        // Post-action snapshot for redo
        saveState();
      }

      if (isDraggingBoneHandle) {
        // Post-action snapshot for redo of bone drag/rotate
        saveState();
        // On drop, if near another bone handle, create a connection (snap)
        if (boneDrag) {
          const draggedIndex = boneDrag.boneIndex;
          const draggedBone = bones[draggedIndex];
          if (draggedBone && draggedBone.frameIndex === currentFrame) {
            const hx = boneDrag.handle === 'start' ? draggedBone.startX : draggedBone.endX;
            const hy = boneDrag.handle === 'start' ? draggedBone.startY : draggedBone.endY;
            const target = getBoneHandleNearForConnection(hx, hy, draggedIndex);
            if (target) {
              const parent = bones[target.boneIndex];
              if (parent && parent.frameIndex === currentFrame) {
                draggedBone.parentBoneIndex = target.boneIndex;
                draggedBone.attachedAt = boneDrag.handle; // which endpoint on child is attached
                draggedBone.parentAttach = target.handle;  // which endpoint on parent is used
                const px = target.handle === 'start' ? parent.startX : parent.endX;
                const py = target.handle === 'start' ? parent.startY : parent.endY;
                if (draggedBone.attachedAt === 'start') { draggedBone.startX = px; draggedBone.startY = py; }
                else { draggedBone.endX = px; draggedBone.endY = py; }
                enforceBoneConnections();
              }
            }
          }
        }

        isDraggingBoneHandle = false;
        boneDrag = null;
        refreshSelectionOverlay();
        drawBonesOverlay();
      }

      composeLayers(currentFrame);
      updateThumbnail(currentFrame);
      
      /* Automatically show onion skin on next frame after drawing */
      if (onionSkinEnabled && currentFrame < 5) {
        updateOnionSkin();
      }

      // Brush/Pencil/Eraser: end-of-stroke snapshot for redo
      if (currentTool === 'brush' || currentTool === 'pencil' || currentTool === 'eraser') {
        saveState();
      }
    }

    function composeLayers(frameIndex) {
      /* Made composeLayers accept optional frameIndex parameter */
      const idx = frameIndex !== undefined ? frameIndex : currentFrame;
      const ctx = contexts[idx];
      const canvas = canvases[idx];
      
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      // Use dark background
      fillCheckerboard(ctx, canvas.width, canvas.height);
      
      frameLayers[idx].forEach(layer => {
        if (layer.visible) {
          ctx.save();
          ctx.globalAlpha = layer.opacity;
          ctx.drawImage(layer.canvas, 0, 0);
          if (Array.isArray(layer.images)) {
            for (const obj of layer.images) {
              // During selection/move, draw the selected image only on the overlay to avoid duplication
              if (selectedImageObject && moveOverlayCanvas && moveOverlayCtx && obj === selectedImageObject) {
                continue;
              }
              ctx.imageSmoothingEnabled = true;
              ctx.imageSmoothingQuality = 'high';
              drawRotatedImage(ctx, obj);
            }
          }
          ctx.restore();
        }
      });
      
      if (frameIndex === undefined) {
        updateThumbnail(idx);
      }
    }

    function refreshAllFrameCanvases() {
      const doRefresh = () => {
        initializeCanvases();
        for (let i = 0; i < frameLayers.length; i++) {
          composeLayers(i);
          updateThumbnail(i);
        }
        if (typeof updateOnionSkin === 'function') {
          updateOnionSkin();
        }
        updateFrameLabel();
      };
      if (typeof requestAnimationFrame === 'function') {
        requestAnimationFrame(doRefresh);
      } else {
        setTimeout(doRefresh, 0);
      }
    }

    function eraseLassoSelection() {
      const layer = frameLayers[currentFrame][currentLayer];
      const ctx = layer.ctx;
      const canvas = layer.canvas;
      
      if (lassoPoints.length < 3) return;

      // Save state before lasso operation
      saveState();
      
      ctx.save();
      ctx.beginPath();
      ctx.moveTo(lassoPoints[0][0], lassoPoints[0][1]);
      for (let i = 1; i < lassoPoints.length; i++) {
        ctx.lineTo(lassoPoints[i][0], lassoPoints[i][1]);
      }
      ctx.closePath();
      ctx.clip();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.restore();

      // Also erase the lassoed area from image objects by segmenting away the breakaway piece
      if (Array.isArray(layer.images) && layer.images.length) {
        // Pre-build polygon path drawer (world coords)
        const drawPolyPath = (g, ox = 0, oy = 0) => {
          g.beginPath();
          g.moveTo(lassoPoints[0][0] - ox, lassoPoints[0][1] - oy);
          for (let i = 1; i < lassoPoints.length; i++) g.lineTo(lassoPoints[i][0] - ox, lassoPoints[i][1] - oy);
          g.closePath();
        };
        const keep = [];
        for (let idx = 0; idx < layer.images.length; idx++) {
          const obj = layer.images[idx];
          if (!obj || !obj.img) { keep.push(obj); continue; }
          // Quick AABB reject using polygon bbox
          let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
          for (const p of lassoPoints) { if (p[0] < minX) minX = p[0]; if (p[1] < minY) minY = p[1]; if (p[0] > maxX) maxX = p[0]; if (p[1] > maxY) maxY = p[1]; }
          const baseW = (obj && obj.drawW != null) ? obj.drawW : ((obj && obj.img && (obj.img.naturalWidth || obj.img.width || obj.img.videoWidth)) || 0);
          const baseH = (obj && obj.drawH != null) ? obj.drawH : ((obj && obj.img && (obj.img.naturalHeight || obj.img.height || obj.img.videoHeight)) || 0);
          const objScaleX = (obj && typeof obj.scaleX === 'number') ? obj.scaleX : 1;
          const objScaleY = (obj && typeof obj.scaleY === 'number') ? obj.scaleY : 1;
          const ow = baseW * (obj.scale || 1) * objScaleX;
          const oh = baseH * (obj.scale || 1) * objScaleY;
          const objAABB = { x: Math.floor(obj.x), y: Math.floor(obj.y), r: Math.ceil(obj.x + ow), b: Math.ceil(obj.y + oh) };
          const polyAABB = { x: Math.floor(minX), y: Math.floor(minY), r: Math.ceil(maxX), b: Math.ceil(maxY) };
          const overlaps = !(objAABB.r < polyAABB.x || objAABB.x > polyAABB.r || objAABB.b < polyAABB.y || objAABB.y > polyAABB.b);
          if (!overlaps) { keep.push(obj); continue; }
          // Compute rotated object AABB in world coordinates
          const objScaleX2 = (obj && typeof obj.scaleX === 'number') ? obj.scaleX : 1;
          const objScaleY2 = (obj && typeof obj.scaleY === 'number') ? obj.scaleY : 1;
          const wDraw = baseW * (obj.scale || 1) * objScaleX2;
          const hDraw = baseH * (obj.scale || 1) * objScaleY2;
          const cx = obj.x + wDraw / 2;
          const cy = obj.y + hDraw / 2;
          const rot = obj.rotation || 0;
          const cosR = Math.cos(rot), sinR = Math.sin(rot);
          const corners = [
            { x: obj.x,           y: obj.y },
            { x: obj.x + wDraw,   y: obj.y },
            { x: obj.x + wDraw,   y: obj.y + hDraw },
            { x: obj.x,           y: obj.y + hDraw }
          ].map(p => {
            const dx = p.x - cx, dy = p.y - cy;
            return { x: cx + dx * cosR - dy * sinR, y: cy + dx * sinR + dy * cosR };
          });
          let ax = Infinity, ay = Infinity, ar = -Infinity, ab = -Infinity;
          for (const c of corners) { if (c.x < ax) ax = c.x; if (c.y < ay) ay = c.y; if (c.x > ar) ar = c.x; if (c.y > ab) ab = c.y; }
          ax = Math.floor(ax); ay = Math.floor(ay); ar = Math.ceil(ar); ab = Math.ceil(ab);
          const offW = Math.max(1, ar - ax), offH = Math.max(1, ab - ay);
          // Eraser Lasso: do not create a separate selected piece; only remove selected pixels from the object
          // Rasterize object to object-bounds offscreen, subtract polygon translated by (-ax, -ay)
          const off = document.createElement('canvas'); off.width = offW; off.height = offH;
          const octx = off.getContext('2d', { willReadFrequently: true });
          drawRotatedImage(octx, obj, 1, 1, -ax, -ay);
          octx.save();
          drawPolyPath(octx, ax, ay);
          octx.globalCompositeOperation = 'destination-out';
          octx.fillStyle = '#fff';
          octx.fill();
          octx.restore();
          // Find bbox of remaining pixels
          const id = octx.getImageData(0, 0, offW, offH);
          const data = id.data;
          let rx = offW, ry = offH, rr = -1, rb = -1;
          for (let y = 0; y < offH; y++) {
            for (let x = 0; x < offW; x++) {
              const a = data[(y * offW + x) * 4 + 3];
              if (a > 0) {
                if (x < rx) rx = x;
                if (y < ry) ry = y;
                if (x > rr) rr = x;
                if (y > rb) rb = y;
              }
            }
          }
          if (rr < rx || rb < ry) {
            // Entire object erased
            continue;
          }
          const cw = Math.max(1, rr - rx + 1);
          const ch = Math.max(1, rb - ry + 1);
          const crop = document.createElement('canvas');
          crop.width = cw; crop.height = ch;
          const cctx = crop.getContext('2d');
          cctx.drawImage(off, rx, ry, cw, ch, 0, 0, cw, ch);
          const dataUrl = crop.toDataURL('image/png');
          const img = new Image();
          img.onload = () => {
            // Preserve the object's reported top-left by padding remainder into an aligned canvas
            const oldX = obj.x, oldY = obj.y;
            const baseW0 = (obj && obj.drawW != null)
              ? obj.drawW
              : ((obj && obj.img && (obj.img.naturalWidth || obj.img.width || obj.img.videoWidth)) || 0);
            const baseH0 = (obj && obj.drawH != null)
              ? obj.drawH
              : ((obj && obj.img && (obj.img.naturalHeight || obj.img.height || obj.img.videoHeight)) || 0);
            const effScaleX0 = (obj && typeof obj.scaleX === 'number') ? obj.scaleX : 1;
            const effScaleY0 = (obj && typeof obj.scaleY === 'number') ? obj.scaleY : 1;
            const oldDrawW = Math.max(1, Math.round(baseW0 * (obj.scale || 1) * effScaleX0));
            const oldDrawH = Math.max(1, Math.round(baseH0 * (obj.scale || 1) * effScaleY0));
            const aligned = document.createElement('canvas');
            aligned.width = oldDrawW;
            aligned.height = oldDrawH;
            const actx = aligned.getContext('2d');
            // rx,ry are relative to offscreen origin (ax,ay) in world coords
            const offsetX = Math.max(0, Math.round((ax + rx) - oldX));
            const offsetY = Math.max(0, Math.round((ay + ry) - oldY));
            actx.drawImage(img, offsetX, offsetY);
            obj.img = aligned;
            obj.src = aligned.toDataURL('image/png');
            // Keep original top-left; bake transforms
            obj.x = oldX; obj.y = oldY;
            obj.scale = 1; obj.scaleX = 1; obj.scaleY = 1; obj.rotation = 0;
            obj.drawW = aligned.width; obj.drawH = aligned.height;
            obj.isImage = true;
            composeLayers(currentFrame);
            updateThumbnail(currentFrame);
          };
          img.src = dataUrl;
          keep.push(obj);
        }
        layer.images = keep;
        try { updateLayersList(); } catch (_e) {}
      }
    }

    function createSelectionFromPolygon() {
      const layer = frameLayers[currentFrame][currentLayer];
      const baseCtx = layer.ctx;
      const baseCanvas = layer.canvas;
      if (selectLassoPoints.length < 3) return;
      // First try to fragment from image objects (topmost first). If none selected, fall back to raster.
      try {
        if (Array.isArray(layer.images) && layer.images.length) {
          // Compute polygon bbox
          let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
          for (const p of selectLassoPoints) {
            if (p[0] < minX) minX = p[0];
            if (p[1] < minY) minY = p[1];
            if (p[0] > maxX) maxX = p[0];
            if (p[1] > maxY) maxY = p[1];
          }
          minX = Math.max(0, Math.floor(minX));
          minY = Math.max(0, Math.floor(minY));
          maxX = Math.min(baseCanvas.width, Math.ceil(maxX));
          maxY = Math.min(baseCanvas.height, Math.ceil(maxY));
          const selW = Math.max(1, maxX - minX);
          const selH = Math.max(1, maxY - minY);
          // Helper to draw polygon path with offset
          const drawPolyPath = (g, ox = 0, oy = 0) => {
            g.beginPath();
            g.moveTo(selectLassoPoints[0][0] - ox, selectLassoPoints[0][1] - oy);
            for (let i = 1; i < selectLassoPoints.length; i++) g.lineTo(selectLassoPoints[i][0] - ox, selectLassoPoints[i][1] - oy);
            g.closePath();
          };
          // Iterate topmost first (end of array drawn last)
          for (let idx = layer.images.length - 1; idx >= 0; idx--) {
            const obj = layer.images[idx];
            if (!obj || !obj.img) continue;
            // Quick overlap check against polygon bbox using rotated bounds
            const baseW = (obj.drawW != null) ? obj.drawW : ((obj.img.naturalWidth || obj.img.width || obj.img.videoWidth) || 0);
            const baseH = (obj.drawH != null) ? obj.drawH : ((obj.img.naturalHeight || obj.img.height || obj.img.videoHeight) || 0);
            const effScaleX = (typeof obj.scaleX === 'number') ? obj.scaleX : 1;
            const effScaleY = (typeof obj.scaleY === 'number') ? obj.scaleY : 1;
            const wDraw = baseW * (obj.scale || 1) * effScaleX;
            const hDraw = baseH * (obj.scale || 1) * effScaleY;
            const cx = obj.x + wDraw / 2;
            const cy = obj.y + hDraw / 2;
            const rot = obj.rotation || 0;
            const cosR = Math.cos(rot), sinR = Math.sin(rot);
            const corners = [
              { x: obj.x,           y: obj.y },
              { x: obj.x + wDraw,   y: obj.y },
              { x: obj.x + wDraw,   y: obj.y + hDraw },
              { x: obj.x,           y: obj.y + hDraw }
            ].map(p => {
              const dx = p.x - cx, dy = p.y - cy;
              return { x: cx + dx * cosR - dy * sinR, y: cy + dx * sinR + dy * cosR };
            });
            let ax = Infinity, ay = Infinity, ar = -Infinity, ab = -Infinity;
            for (const c of corners) { if (c.x < ax) ax = c.x; if (c.y < ay) ay = c.y; if (c.x > ar) ar = c.x; if (c.y > ab) ab = c.y; }
            ax = Math.floor(ax); ay = Math.floor(ay); ar = Math.ceil(ar); ab = Math.ceil(ab);
            const intersects = !(ar < minX || ax > maxX || ab < minY || ay > maxY);
            if (!intersects) continue;
            // Build selection offscreen within polygon bbox
            const selOff = document.createElement('canvas'); selOff.width = selW; selOff.height = selH;
            const sctx = selOff.getContext('2d', { willReadFrequently: true });
            drawRotatedImage(sctx, obj, 1, 1, -minX, -minY);
            // Keep only polygon region
            sctx.save();
            drawPolyPath(sctx, minX, minY);
            sctx.globalCompositeOperation = 'destination-in';
            sctx.fillStyle = '#fff';
            sctx.fill();
            sctx.restore();
            // Tight crop selection
            const idSel = sctx.getImageData(0, 0, selW, selH);
            const dataSel = idSel.data;
            let rx = selW, ry = selH, rr = -1, rb = -1;
            for (let y = 0; y < selH; y++) {
              for (let x = 0; x < selW; x++) {
                const a = dataSel[(y * selW + x) * 4 + 3];
                if (a > 0) { if (x < rx) rx = x; if (y < ry) ry = y; if (x > rr) rr = x; if (y > rb) rb = y; }
              }
            }
            if (rr < rx || rb < ry) continue; // nothing selected from this object
            const cw = Math.max(1, rr - rx + 1);
            const ch = Math.max(1, rb - ry + 1);
            const cropSel = document.createElement('canvas'); cropSel.width = cw; cropSel.height = ch;
            const csCtx = cropSel.getContext('2d');
            csCtx.drawImage(selOff, rx, ry, cw, ch, 0, 0, cw, ch);
            const selSrc = cropSel.toDataURL('image/png');
            // Subtract polygon from original object (remainder)
            const offW = Math.max(1, ar - ax), offH = Math.max(1, ab - ay);
            const off = document.createElement('canvas'); off.width = offW; off.height = offH;
            const octx = off.getContext('2d', { willReadFrequently: true });
            drawRotatedImage(octx, obj, 1, 1, -ax, -ay);
            octx.save();
            octx.beginPath();
            octx.moveTo(selectLassoPoints[0][0] - ax, selectLassoPoints[0][1] - ay);
            for (let k = 1; k < selectLassoPoints.length; k++) octx.lineTo(selectLassoPoints[k][0] - ax, selectLassoPoints[k][1] - ay);
            octx.closePath();
            octx.globalCompositeOperation = 'destination-out';
            octx.fillStyle = '#fff';
            octx.fill();
            octx.restore();
            const idRem = octx.getImageData(0, 0, offW, offH);
            const dataRem = idRem.data;
            let rx2 = offW, ry2 = offH, rr2 = -1, rb2 = -1;
            for (let y = 0; y < offH; y++) {
              for (let x = 0; x < offW; x++) {
                const a = dataRem[(y * offW + x) * 4 + 3];
                if (a > 0) { if (x < rx2) rx2 = x; if (y < ry2) ry2 = y; if (x > rr2) rr2 = x; if (y > rb2) rb2 = y; }
              }
            }
            // Create selected piece as a new image object
            const selImg = new Image();
            selImg.onload = () => {
              const newObj = {
                img: selImg,
                src: selSrc,
                x: minX + rx, y: minY + ry,
                scale: 1, scaleX: 1, scaleY: 1, rotation: 0,
                drawW: cw, drawH: ch,
                isImage: true,
                color: (Array.isArray(cutoutObjectPalette) && cutoutObjectPalette.length)
                  ? cutoutObjectPalette[(Array.isArray(layer.images) ? layer.images.length : 0) % cutoutObjectPalette.length]
                  : '#6366f1'
              };
              // Update or remove original object with remainder
              if (rr2 < rx2 || rb2 < ry2) {
                // Entire object moved into selection; remove original
                const i = layer.images.indexOf(obj);
                if (i >= 0) layer.images.splice(i, 1);
              } else {
                const cw2 = Math.max(1, rr2 - rx2 + 1);
                const ch2 = Math.max(1, rb2 - ry2 + 1);
                const cropRem = document.createElement('canvas'); cropRem.width = cw2; cropRem.height = ch2;
                const crCtx = cropRem.getContext('2d');
                crCtx.drawImage(off, rx2, ry2, cw2, ch2, 0, 0, cw2, ch2);
                // Preserve the object's reported top-left by padding remainder into an aligned canvas
                const oldX = obj.x, oldY = obj.y;
                const oldDrawW = Math.max(1, Math.round(baseW * (obj.scale || 1) * effScaleX));
                const oldDrawH = Math.max(1, Math.round(baseH * (obj.scale || 1) * effScaleY));
                const aligned = document.createElement('canvas'); aligned.width = oldDrawW; aligned.height = oldDrawH;
                const actx = aligned.getContext('2d');
                const offsetX = Math.max(0, Math.round((ax + rx2) - oldX));
                const offsetY = Math.max(0, Math.round((ay + ry2) - oldY));
                actx.drawImage(cropRem, offsetX, offsetY);
                obj.img = aligned;
                obj.src = aligned.toDataURL('image/png');
                obj.x = oldX; obj.y = oldY;
                obj.scale = 1; obj.scaleX = 1; obj.scaleY = 1; obj.rotation = 0;
                obj.drawW = aligned.width; obj.drawH = aligned.height;
              }
              // Push the new selected piece and select it for manipulation
              layer.images.push(newObj);
              composeLayers(currentFrame);
              updateThumbnail(currentFrame);
              updateLayersList();
              selectedImageObject = newObj;
              // Switch to Select/Move and begin overlay drag for the new piece
              try { setTool('select'); } catch (_e) {}
              beginImageDrag();
            };
            selImg.src = selSrc;
            return; // selection handled from image object; do not fall back to raster
          }
        }
      } catch (_e) { /* fall through to raster path */ }
      // Build mask on an intermediate canvas
      const maskCanvas = document.createElement('canvas');
      maskCanvas.width = baseCanvas.width;
      maskCanvas.height = baseCanvas.height;
      const maskCtx = maskCanvas.getContext('2d');
      // Clip to polygon and draw from the base canvas
      maskCtx.save();
      maskCtx.beginPath();
      maskCtx.moveTo(selectLassoPoints[0][0], selectLassoPoints[0][1]);
      for (let i = 1; i < selectLassoPoints.length; i++) {
        maskCtx.lineTo(selectLassoPoints[i][0], selectLassoPoints[i][1]);
      }
      maskCtx.closePath();
      maskCtx.clip();
      maskCtx.drawImage(baseCanvas, 0, 0);
      maskCtx.restore();
      // Compute polygon bounding box
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      for (const p of selectLassoPoints) {
        if (p[0] < minX) minX = p[0];
        if (p[1] < minY) minY = p[1];
        if (p[0] > maxX) maxX = p[0];
        if (p[1] > maxY) maxY = p[1];
      }
      minX = Math.max(0, Math.floor(minX));
      minY = Math.max(0, Math.floor(minY));
      maxX = Math.min(baseCanvas.width, Math.ceil(maxX));
      maxY = Math.min(baseCanvas.height, Math.ceil(maxY));
      const selW = Math.max(1, maxX - minX);
      const selH = Math.max(1, maxY - minY);
      // Crop selection to bounding box
      const cropped = document.createElement('canvas');
      cropped.width = selW;
      cropped.height = selH;
      const croppedCtx = cropped.getContext('2d');
      croppedCtx.drawImage(maskCanvas, minX, minY, selW, selH, 0, 0, selW, selH);
      // Clear original pixels from the base within polygon
      baseCtx.save();
      baseCtx.beginPath();
      baseCtx.moveTo(selectLassoPoints[0][0], selectLassoPoints[0][1]);
      for (let i = 1; i < selectLassoPoints.length; i++) baseCtx.lineTo(selectLassoPoints[i][0], selectLassoPoints[i][1]);
      baseCtx.closePath();
      baseCtx.clip();
      baseCtx.clearRect(0, 0, baseCanvas.width, baseCanvas.height);
      baseCtx.restore();
      // Create image object from cropped canvas
      const src = cropped.toDataURL('image/png');
      const img = new Image();
      img.onload = () => {
        const obj = { img, src, x: minX, y: minY, scale: 1, scaleX: 1, scaleY: 1, rotation: 0 };
        if (!Array.isArray(layer.images)) layer.images = [];
        layer.images.push(obj);
        composeLayers(currentFrame);
        updateThumbnail(currentFrame);
      // Always switch to Select/Move after segmentation so the breakaway piece is immediately manipulable
      setTool('select');
        selectedImageObject = obj;
        beginImageDrag();
      };
      img.src = src;
    }

    // --- Cut Out Mode: Bones helpers and serialization ---
    function ensureCutoutBonesOverlay() {
      const container = document.getElementById('cutout-canvas-container');
      if (!container || !cutoutCanvas) return;
      if (cutoutBonesOverlayCanvas && cutoutBonesOverlayCanvas.parentElement !== container) {
        cutoutBonesOverlayCanvas.remove();
        cutoutBonesOverlayCanvas = null;
        cutoutBonesOverlayCtx = null;
      }
      if (!cutoutBonesOverlayCanvas) {
        cutoutBonesOverlayCanvas = document.createElement('canvas');
        cutoutBonesOverlayCanvas.width = cutoutCanvas.width;
        cutoutBonesOverlayCanvas.height = cutoutCanvas.height;
        cutoutBonesOverlayCanvas.style.position = 'absolute';
        cutoutBonesOverlayCanvas.style.top = '0';
        cutoutBonesOverlayCanvas.style.left = '0';
        cutoutBonesOverlayCanvas.style.width = '100%';
        cutoutBonesOverlayCanvas.style.height = '100%';
        cutoutBonesOverlayCanvas.style.pointerEvents = 'none';
        cutoutBonesOverlayCanvas.style.zIndex = '1002';
        cutoutBonesOverlayCtx = cutoutBonesOverlayCanvas.getContext('2d');
        const computed = window.getComputedStyle(container);
        if (computed.position === 'static') container.style.position = 'relative';
        container.appendChild(cutoutBonesOverlayCanvas);
        // Ensure overlay follows current zoom/pan immediately
        if (typeof applyCutoutZoomTransforms === 'function') applyCutoutZoomTransforms();
      }
    }
    function getActiveCutoutClipIndex() {
      return (typeof selectedCutoutClipIndex === 'number' && selectedCutoutClipIndex >= 0)
        ? selectedCutoutClipIndex
        : getActiveCutoutClipIndexAt(cutoutCurrentTime);
    }
    function drawCutoutBonesOverlay() {
      if (!cutoutBonesOverlayCanvas) ensureCutoutBonesOverlay();
      if (!cutoutBonesOverlayCtx) return;
      const w = cutoutBonesOverlayCanvas.width, h = cutoutBonesOverlayCanvas.height;
      cutoutBonesOverlayCtx.clearRect(0, 0, w, h);
      enforceCutoutBoneConnections();
      const jointOuter = 17;
      const jointInner = 9;
      const activeClip = getActiveCutoutClipIndex();
      for (let bi = 0; bi < cutoutBones.length; bi++) {
        const bone = cutoutBones[bi];
        if (!bone || bone.clipIndex !== activeClip) continue;
        cutoutBonesOverlayCtx.save();
        const dx = bone.endX - bone.startX;
        const dy = bone.endY - bone.startY;
        const length = Math.hypot(dx, dy) || 1;
        const ux = dx / length;
        const uy = dy / length;
        const px = -uy;
        const py = ux;
        const baseRadius = 12;
        const tipRadius = 3;
        const bulgeT = 0.12;
        const bulgeRadius = baseRadius + 2;
        const startLeftX = bone.startX + px * baseRadius;
        const startLeftY = bone.startY + py * baseRadius;
        const startRightX = bone.startX - px * baseRadius;
        const startRightY = bone.startY - py * baseRadius;
        const endLeftX = bone.endX + px * tipRadius;
        const endLeftY = bone.endY + py * tipRadius;
        const endRightX = bone.endX - px * tipRadius;
        const endRightY = bone.endY - py * tipRadius;
        const bulgeCX = bone.startX + ux * (length * bulgeT);
        const bulgeCY = bone.startY + uy * (length * bulgeT);
        const bulgeLeftX = bulgeCX + px * bulgeRadius;
        const bulgeLeftY = bulgeCY + py * bulgeRadius;
        const bulgeRightX = bulgeCX - px * bulgeRadius;
        const bulgeRightY = bulgeCY - py * bulgeRadius;
        // Grey 70% opacity styling
        const anglePerp = Math.atan2(py, px);
        const anglePerpOpp = Math.atan2(-py, -px);
        cutoutBonesOverlayCtx.beginPath();
        cutoutBonesOverlayCtx.moveTo(startLeftX, startLeftY);
        cutoutBonesOverlayCtx.quadraticCurveTo(bulgeLeftX, bulgeLeftY, endLeftX, endLeftY);
        cutoutBonesOverlayCtx.arc(bone.endX, bone.endY, tipRadius, anglePerp, anglePerpOpp);
        cutoutBonesOverlayCtx.quadraticCurveTo(bulgeRightX, bulgeRightY, startRightX, startRightY);
        cutoutBonesOverlayCtx.arc(bone.startX, bone.startY, baseRadius, anglePerpOpp, anglePerp);
        cutoutBonesOverlayCtx.closePath();
        cutoutBonesOverlayCtx.fillStyle = 'rgba(157, 157, 157, 0.8)';
        cutoutBonesOverlayCtx.fill();
        cutoutBonesOverlayCtx.strokeStyle = 'rgba(0,0,0,0.12)';
        cutoutBonesOverlayCtx.lineWidth = 1.25;
        cutoutBonesOverlayCtx.stroke();
        const drawJoint = (x, y, connected) => {
          cutoutBonesOverlayCtx.beginPath();
          cutoutBonesOverlayCtx.fillStyle = 'rgba(157, 157, 157, 0.8)';
          cutoutBonesOverlayCtx.arc(x, y, jointOuter, 0, Math.PI * 2);
          cutoutBonesOverlayCtx.fill();
          cutoutBonesOverlayCtx.beginPath();
          cutoutBonesOverlayCtx.fillStyle = 'rgba(157, 157, 157, 0.8)';
          cutoutBonesOverlayCtx.arc(x, y, jointInner, 0, Math.PI * 2);
          cutoutBonesOverlayCtx.fill();
          // Outline around inner hexagon (replacing circle outline)
          cutoutBonesOverlayCtx.beginPath();
          const sidesC = 6;
          const rC = jointInner;
          for (let i = 0; i < sidesC; i++) {
            const ang = Math.PI / 6 + (i * (Math.PI * 2 / sidesC));
            const vx = x + rC * Math.cos(ang);
            const vy = y + rC * Math.sin(ang);
            if (i === 0) cutoutBonesOverlayCtx.moveTo(vx, vy); else cutoutBonesOverlayCtx.lineTo(vx, vy);
          }
          cutoutBonesOverlayCtx.closePath();
          cutoutBonesOverlayCtx.fillStyle = 'rgba(65, 65, 65, 0.8)';
          cutoutBonesOverlayCtx.fill();
          cutoutBonesOverlayCtx.strokeStyle = 'rgba(65, 65, 65, 0.8)';
          cutoutBonesOverlayCtx.lineWidth = 1.0;
          cutoutBonesOverlayCtx.stroke();
        };
        const hasParentAt = (handle) => (bone.parentBoneIndex != null && bone.attachedAt === handle);
        const hasChildAt = (handle) => {
          for (let i = 0; i < cutoutBones.length; i++) {
            const c = cutoutBones[i];
            if (!c || c.clipIndex !== activeClip) continue;
            if (c.parentBoneIndex === bi && c.parentAttach === handle) return true;
          }
          return false;
        };
        drawJoint(bone.startX, bone.startY, hasParentAt('start') || hasChildAt('start'));
        drawJoint(bone.endX, bone.endY, hasParentAt('end') || hasChildAt('end'));
        
        // Draw rotation handle with dotted circle around start node
        const rotHandleOffset = 45; // Distance from start to rotation handle
        const boneAngle = Math.atan2(dy, dx);
        // Rotation handle perpendicular to bone direction (above the start)
        const rotHandleAngle = boneAngle - Math.PI / 2;
        const rotHandleX = bone.startX + Math.cos(rotHandleAngle) * rotHandleOffset;
        const rotHandleY = bone.startY + Math.sin(rotHandleAngle) * rotHandleOffset;
        
        // Draw dotted circle around start node (pivot indicator)
        cutoutBonesOverlayCtx.beginPath();
        cutoutBonesOverlayCtx.arc(bone.startX, bone.startY, 28, 0, Math.PI * 2);
        cutoutBonesOverlayCtx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
        cutoutBonesOverlayCtx.lineWidth = 1.5;
        cutoutBonesOverlayCtx.setLineDash([4, 4]);
        cutoutBonesOverlayCtx.stroke();
        cutoutBonesOverlayCtx.setLineDash([]);
        
        // Draw line from start to rotation handle
        cutoutBonesOverlayCtx.beginPath();
        cutoutBonesOverlayCtx.moveTo(bone.startX, bone.startY);
        cutoutBonesOverlayCtx.lineTo(rotHandleX, rotHandleY);
        cutoutBonesOverlayCtx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
        cutoutBonesOverlayCtx.lineWidth = 1.5;
        cutoutBonesOverlayCtx.stroke();
        
        // Draw rotation handle node
        const rotNodeRadius = 10;
        cutoutBonesOverlayCtx.beginPath();
        cutoutBonesOverlayCtx.arc(rotHandleX, rotHandleY, rotNodeRadius, 0, Math.PI * 2);
        cutoutBonesOverlayCtx.fillStyle = 'rgba(100, 200, 255, 0.9)';
        cutoutBonesOverlayCtx.fill();
        cutoutBonesOverlayCtx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
        cutoutBonesOverlayCtx.lineWidth = 2;
        cutoutBonesOverlayCtx.stroke();
        
        // Draw rotation icon (curved arrow) inside the handle
        cutoutBonesOverlayCtx.beginPath();
        cutoutBonesOverlayCtx.arc(rotHandleX, rotHandleY, 5, -Math.PI * 0.7, Math.PI * 0.5);
        cutoutBonesOverlayCtx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
        cutoutBonesOverlayCtx.lineWidth = 1.5;
        cutoutBonesOverlayCtx.stroke();
        // Arrowhead
        const arrowAngle = Math.PI * 0.5;
        const arrowX = rotHandleX + 5 * Math.cos(arrowAngle);
        const arrowY = rotHandleY + 5 * Math.sin(arrowAngle);
        cutoutBonesOverlayCtx.beginPath();
        cutoutBonesOverlayCtx.moveTo(arrowX + 3, arrowY - 2);
        cutoutBonesOverlayCtx.lineTo(arrowX, arrowY);
        cutoutBonesOverlayCtx.lineTo(arrowX + 3, arrowY + 2);
        cutoutBonesOverlayCtx.stroke();
        
        cutoutBonesOverlayCtx.restore();
      }
    }
    function scheduleDrawCutoutBonesOverlay() {
      if (cutoutBonesOverlayRafScheduled) return;
      cutoutBonesOverlayRafScheduled = true;
      requestAnimationFrame(() => {
        cutoutBonesOverlayRafScheduled = false;
        enforceCutoutBoneConnections();
        ensureCutoutBonesOverlay();
        drawCutoutBonesOverlay();
      });
    }
    function deleteCutoutBoneAtIndex(boneIndex) {
      if (boneIndex < 0 || boneIndex >= cutoutBones.length) return;
      try { saveState(); } catch (_e) {}
      // Before removal, bake the current pose of any attached object so it keeps its world position/rotation
      try {
        const b = cutoutBones[boneIndex];
        if (b && b.objectRef) {
          const obj = b.objectRef;
          // Use the same math as renderCutoutPreviewForTime to compute world-aligned position from pinnedLocal
          if (typeof b.pinnedLocalX === 'number' && typeof b.pinnedLocalY === 'number') {
            const baseW = (obj && obj.drawW != null) ? obj.drawW : ((obj && obj.img && (obj.img.naturalWidth || obj.img.width || obj.img.videoWidth)) || 0);
            const baseH = (obj && obj.drawH != null) ? obj.drawH : ((obj && obj.img && (obj.img.naturalHeight || obj.img.height || obj.img.videoHeight)) || 0);
            const effScaleX = (typeof obj.scaleX === 'number') ? obj.scaleX : 1;
            const effScaleY = (typeof obj.scaleY === 'number') ? obj.scaleY : 1;
            const w = baseW * (obj.scale || 1) * effScaleX;
            const h = baseH * (obj.scale || 1) * effScaleY;
            const rot = obj.rotation || 0;
            const cosR = Math.cos(rot), sinR = Math.sin(rot);
            const rx = b.pinnedLocalX * cosR - b.pinnedLocalY * sinR;
            const ry = b.pinnedLocalX * sinR + b.pinnedLocalY * cosR;
            const centerX = b.startX - rx;
            const centerY = b.startY - ry;
            obj.x = centerX - w / 2;
            obj.y = centerY - h / 2;
          }
          // Detach bone reference so future renders don't try to re-pin
          b.objectRef = null;
        }
      } catch (_e) {}
      cutoutBones.splice(boneIndex, 1);
      // Re-index children parentBoneIndex references
      for (let i = 0; i < cutoutBones.length; i++) {
        const b = cutoutBones[i];
        if (!b) continue;
        if (b.parentBoneIndex === boneIndex) {
          b.parentBoneIndex = null;
          b.attachedAt = null;
          b.parentAttach = null;
        } else if (typeof b.parentBoneIndex === 'number' && b.parentBoneIndex > boneIndex) {
          b.parentBoneIndex -= 1;
        }
      }
      cutoutSelectedBoneIndex = -1;
      cutoutIsDraggingBoneHandle = false;
      cutoutBoneDrag = null;
      // Ensure lasso states are reset so new bones can be drawn immediately
      cutoutIsBoneLassoActive = false;
      cutoutBoneLassoPoints = [];
      if (lassoOverlayCanvas) {
        try { lassoOverlayCanvas.remove(); } catch (_e) {}
        lassoOverlayCanvas = null;
        lassoOverlayCtx = null;
      }
      scheduleDrawCutoutBonesOverlay();
      scheduleCutoutPreviewForTime();
    }
    function getCutoutBoneHandleAtPoint(x, y) {
      const hitRadius = 20;
      const rotHitRadius = 15;
      const rotHandleOffset = 45;
      const activeClip = getActiveCutoutClipIndex();
      for (let i = cutoutBones.length - 1; i >= 0; i--) {
        const b = cutoutBones[i];
        if (!b || b.clipIndex !== activeClip) continue;
        // Check rotation handle first (higher priority)
        const dx = b.endX - b.startX;
        const dy = b.endY - b.startY;
        const boneAngle = Math.atan2(dy, dx);
        const rotHandleAngle = boneAngle - Math.PI / 2;
        const rotHandleX = b.startX + Math.cos(rotHandleAngle) * rotHandleOffset;
        const rotHandleY = b.startY + Math.sin(rotHandleAngle) * rotHandleOffset;
        const dRot = Math.hypot(x - rotHandleX, y - rotHandleY);
        if (dRot <= rotHitRadius) return { boneIndex: i, handle: 'rotation' };
        // Then check start and end handles
        const dStart = Math.hypot(x - b.startX, y - b.startY);
        if (dStart <= hitRadius) return { boneIndex: i, handle: 'start' };
        const dEnd = Math.hypot(x - b.endX, y - b.endY);
        if (dEnd <= hitRadius) return { boneIndex: i, handle: 'end' };
      }
      return null;
    }
    function getCutoutBoneHandleNearForConnection(x, y, excludeIndex, draggedHandle) {
      // Connection rules: ONLY end nodes can connect to start nodes
      // - If dragging an END handle, can only connect to a START handle
      // - If dragging a START handle, cannot form new connections
      if (draggedHandle === 'start') return null; // Start nodes cannot initiate connections
      
      const hitRadius = 16;
      const activeClip = getActiveCutoutClipIndex();
      for (let i = cutoutBones.length - 1; i >= 0; i--) {
        if (i === excludeIndex) continue;
        const b = cutoutBones[i];
        if (!b || b.clipIndex !== activeClip) continue;
        // Only check START handles as valid connection targets for END handles
        const dStart = Math.hypot(x - b.startX, y - b.startY);
        if (dStart <= hitRadius) return { boneIndex: i, handle: 'start' };
        // END-to-END connections are not allowed
      }
      return null;
    }
    function enforceCutoutBoneConnections() {
      const activeClip = getActiveCutoutClipIndex();
      for (let pass = 0; pass < cutoutBones.length; pass++) {
        let any = false;
        for (let i = 0; i < cutoutBones.length; i++) {
          const c = cutoutBones[i];
          if (!c || c.clipIndex !== activeClip) continue;
          if (c.parentBoneIndex == null) continue;
          const p = cutoutBones[c.parentBoneIndex];
          if (!p || p.clipIndex !== activeClip) continue;
          const px = c.parentAttach === 'start' ? p.startX : p.endX;
          const py = c.parentAttach === 'start' ? p.startY : p.endY;
          if (c.attachedAt === 'start') {
            const dx = px - c.startX;
            const dy = py - c.startY;
            if (dx !== 0 || dy !== 0) {
              c.startX = px; c.startY = py;
              c.endX += dx; c.endY += dy;
              any = true;
              // Clamp to canvas
              try {
                const cw = cutoutCanvas ? cutoutCanvas.width : 0;
                const ch = cutoutCanvas ? cutoutCanvas.height : 0;
                if (cw && ch) {
                  c.startX = Math.max(0, Math.min(cw, c.startX));
                  c.startY = Math.max(0, Math.min(ch, c.startY));
                  c.endX = Math.max(0, Math.min(cw, c.endX));
                  c.endY = Math.max(0, Math.min(ch, c.endY));
                }
              } catch (_e) {}
            }
          } else if (c.attachedAt === 'end') {
            const dx = px - c.endX;
            const dy = py - c.endY;
            if (dx !== 0 || dy !== 0) {
              c.endX = px; c.endY = py;
              c.startX += dx; c.startY += dy;
              any = true;
              // Clamp to canvas
              try {
                const cw = cutoutCanvas ? cutoutCanvas.width : 0;
                const ch = cutoutCanvas ? cutoutCanvas.height : 0;
                if (cw && ch) {
                  c.startX = Math.max(0, Math.min(cw, c.startX));
                  c.startY = Math.max(0, Math.min(ch, c.startY));
                  c.endX = Math.max(0, Math.min(cw, c.endX));
                  c.endY = Math.max(0, Math.min(ch, c.endY));
                }
              } catch (_e) {}
            }
          }
        }
        if (!any) break;
      }
    }
    function moveCutoutJointWithParentRotation(boneIndex, handle, targetX, targetY) {
      const activeClip = getActiveCutoutClipIndex();
      const b = cutoutBones[boneIndex];
      if (!b || b.clipIndex !== activeClip) return;
      let parentIndex = boneIndex;
      let parent = b;
      let parentJointSide = handle;
      if (b.parentBoneIndex != null && b.attachedAt === handle) {
        parentIndex = b.parentBoneIndex;
        parent = cutoutBones[parentIndex];
        if (!parent || parent.clipIndex !== activeClip) return;
        parentJointSide = b.parentAttach;
      }
      const pivotX = parentJointSide === 'start' ? parent.endX : parent.startX;
      const pivotY = parentJointSide === 'start' ? parent.endY : parent.startY;
      const oldJointX = parentJointSide === 'start' ? parent.startX : parent.endX;
      const oldJointY = parentJointSide === 'start' ? parent.startY : parent.endY;
      const L = Math.max(0.0001, parent.restLength || Math.hypot(parent.endX - parent.startX, parent.endY - parent.startY));
      let vx = targetX - pivotX;
      let vy = targetY - pivotY;
      const len = Math.hypot(vx, vy) || 1;
      vx /= len; vy /= len;
      const newJointX = pivotX + vx * L;
      const newJointY = pivotY + vy * L;
      if (parentJointSide === 'start') { parent.startX = newJointX; parent.startY = newJointY; }
      else { parent.endX = newJointX; parent.endY = newJointY; }
      // Clamp parent endpoints
      try {
        const cw = cutoutCanvas ? cutoutCanvas.width : 0;
        const ch = cutoutCanvas ? cutoutCanvas.height : 0;
        if (cw && ch) {
          parent.startX = Math.max(0, Math.min(cw, parent.startX));
          parent.startY = Math.max(0, Math.min(ch, parent.startY));
          parent.endX = Math.max(0, Math.min(cw, parent.endX));
          parent.endY = Math.max(0, Math.min(ch, parent.endY));
        }
      } catch (_e) {}
      if (parent.objectRef) {
        // No longer apply rotation or position changes directly to the attached object
      }
      const djx = newJointX - oldJointX;
      const djy = newJointY - oldJointY;
      for (let i = 0; i < cutoutBones.length; i++) {
        const c = cutoutBones[i];
        if (!c || c.clipIndex !== activeClip) continue;
        if (c.parentBoneIndex === parentIndex && c.parentAttach === parentJointSide) {
          c.startX += djx; c.startY += djy;
          c.endX += djx; c.endY += djy;
          // Clamp child endpoints
          try {
            const cw = cutoutCanvas ? cutoutCanvas.width : 0;
            const ch = cutoutCanvas ? cutoutCanvas.height : 0;
            if (cw && ch) {
              c.startX = Math.max(0, Math.min(cw, c.startX));
              c.startY = Math.max(0, Math.min(ch, c.startY));
              c.endX = Math.max(0, Math.min(cw, c.endX));
              c.endY = Math.max(0, Math.min(ch, c.endY));
            }
          } catch (_e) {}
          // Do not move any attached objects when bones move
        }
      }
      enforceCutoutBoneConnections();
    }
    function cutoutCreateSelectionFromPolygonForBones() {
      const activeIdx = getActiveCutoutClipIndex();
      if (activeIdx < 0) return Promise.resolve(null);
      const clip = cutoutClips[activeIdx];
      if (!clip || !clip.canvas || cutoutBoneLassoPoints.length < 3) return Promise.resolve(null);
      const baseCanvas = clip.canvas;
      const baseCtx = clip.ctx;
      // Compute polygon bbox
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      for (const p of cutoutBoneLassoPoints) {
        if (p[0] < minX) minX = p[0];
        if (p[1] < minY) minY = p[1];
        if (p[0] > maxX) maxX = p[0];
        if (p[1] > maxY) maxY = p[1];
      }
      minX = Math.max(0, Math.floor(minX));
      minY = Math.max(0, Math.floor(minY));
      maxX = Math.min(baseCanvas.width, Math.ceil(maxX));
      maxY = Math.min(baseCanvas.height, Math.ceil(maxY));
      const selW = Math.max(1, maxX - minX);
      const selH = Math.max(1, maxY - minY);
      // Try to extract from imported cutout objects first (topmost first by layer then id)
      try {
        const objs = Array.isArray(clip.objects) ? clip.objects.slice() : [];
        // Sort by layer descending then id ascending for draw order consistency
        objs.sort((a, b) => {
          const ai = Number.isFinite(a && a.layerIndex) ? a.layerIndex : 0;
          const bi = Number.isFinite(b && b.layerIndex) ? b.layerIndex : 0;
          if (ai !== bi) return bi - ai;
          const aid = (a && a.id != null) ? a.id : 0;
          const bid = (b && b.id != null) ? b.id : 0;
          return bid - aid; // topmost first
        });
        for (let idx = 0; idx < objs.length; idx++) {
          const obj = objs[idx];
          if (!obj || !obj.img) continue;
          // Quick AABB overlap against polygon bbox using rotated bounds
          const baseW0 = (obj && obj.drawW != null)
            ? obj.drawW
            : ((obj && obj.img && (obj.img.naturalWidth || obj.img.width || obj.img.videoWidth)) || 0);
          const baseH0 = (obj && obj.drawH != null)
            ? obj.drawH
            : ((obj && obj.img && (obj.img.naturalHeight || obj.img.height || obj.img.videoHeight)) || 0);
          const effScaleX0 = (obj && typeof obj.scaleX === 'number') ? obj.scaleX : 1;
          const effScaleY0 = (obj && typeof obj.scaleY === 'number') ? obj.scaleY : 1;
          const wDraw0 = baseW0 * (obj.scale || 1) * effScaleX0;
          const hDraw0 = baseH0 * (obj.scale || 1) * effScaleY0;
          const cx0 = obj.x + wDraw0 / 2;
          const cy0 = obj.y + hDraw0 / 2;
          const rot0 = obj.rotation || 0;
          const cosR = Math.cos(rot0), sinR = Math.sin(rot0);
          const corners = [
            { x: obj.x,           y: obj.y },
            { x: obj.x + wDraw0,  y: obj.y },
            { x: obj.x + wDraw0,  y: obj.y + hDraw0 },
            { x: obj.x,           y: obj.y + hDraw0 }
          ].map(p => {
            const dx = p.x - cx0, dy = p.y - cy0;
            return { x: cx0 + dx * cosR - dy * sinR, y: cy0 + dx * sinR + dy * cosR };
          });
          let ax = Infinity, ay = Infinity, ar = -Infinity, ab = -Infinity;
          for (const c of corners) { if (c.x < ax) ax = c.x; if (c.y < ay) ay = c.y; if (c.x > ar) ar = c.x; if (c.y > ab) ab = c.y; }
          ax = Math.floor(ax); ay = Math.floor(ay); ar = Math.ceil(ar); ab = Math.ceil(ab);
          const intersects = !(ar < minX || ax > maxX || ab < minY || ay > maxY);
          if (!intersects) continue;
          // Build selection offscreen within polygon bbox
          const selOff = document.createElement('canvas'); selOff.width = selW; selOff.height = selH;
          const sctx = selOff.getContext('2d', { willReadFrequently: true });
          drawRotatedImage(sctx, obj, 1, 1, -minX, -minY);
          // Keep only polygon region
          sctx.save();
          sctx.beginPath();
          sctx.moveTo(cutoutBoneLassoPoints[0][0] - minX, cutoutBoneLassoPoints[0][1] - minY);
          for (let k = 1; k < cutoutBoneLassoPoints.length; k++) sctx.lineTo(cutoutBoneLassoPoints[k][0] - minX, cutoutBoneLassoPoints[k][1] - minY);
          sctx.closePath();
          sctx.globalCompositeOperation = 'destination-in';
          sctx.fillStyle = '#fff';
          sctx.fill();
          sctx.restore();
          // Tight crop selection
          const idSel = sctx.getImageData(0, 0, selW, selH);
          const dataSel = idSel.data;
          let rx = selW, ry = selH, rr = -1, rb = -1;
          for (let y = 0; y < selH; y++) {
            for (let x = 0; x < selW; x++) {
              const a = dataSel[(y * selW + x) * 4 + 3];
              if (a > 0) { if (x < rx) rx = x; if (y < ry) ry = y; if (x > rr) rr = x; if (y > rb) rb = y; }
            }
          }
          if (rr < rx || rb < ry) continue;
          const cw = Math.max(1, rr - rx + 1);
          const ch = Math.max(1, rb - ry + 1);
          const cropSel = document.createElement('canvas'); cropSel.width = cw; cropSel.height = ch;
          const csCtx = cropSel.getContext('2d');
          csCtx.drawImage(selOff, rx, ry, cw, ch, 0, 0, cw, ch);
          const selSrc = cropSel.toDataURL('image/png');
          // Subtract polygon from original object (remainder)
          const offW = Math.max(1, ar - ax), offH = Math.max(1, ab - ay);
          const off = document.createElement('canvas'); off.width = offW; off.height = offH;
          const octx = off.getContext('2d', { willReadFrequently: true });
          drawRotatedImage(octx, obj, 1, 1, -ax, -ay);
          octx.save();
          octx.beginPath();
          octx.moveTo(cutoutBoneLassoPoints[0][0] - ax, cutoutBoneLassoPoints[0][1] - ay);
          for (let k = 1; k < cutoutBoneLassoPoints.length; k++) octx.lineTo(cutoutBoneLassoPoints[k][0] - ax, cutoutBoneLassoPoints[k][1] - ay);
          octx.closePath();
          octx.globalCompositeOperation = 'destination-out';
          octx.fillStyle = '#fff';
          octx.fill();
          octx.restore();
          const idRem = octx.getImageData(0, 0, offW, offH);
          const dataRem = idRem.data;
          let rx2 = offW, ry2 = offH, rr2 = -1, rb2 = -1;
          for (let y = 0; y < offH; y++) {
            for (let x = 0; x < offW; x++) {
              const a = dataRem[(y * offW + x) * 4 + 3];
              if (a > 0) { if (x < rx2) rx2 = x; if (y < ry2) ry2 = y; if (x > rr2) rr2 = x; if (y > rb2) rb2 = y; }
            }
          }
          return new Promise((resolve) => {
            const selImg = new Image();
            selImg.onload = () => {
              if (!Array.isArray(clip.objects)) clip.objects = [];
              const objId = (++cutoutObjectCounter);
              const color = cutoutObjectPalette[clip.objects.length % cutoutObjectPalette.length];
              const newObj = {
                id: objId,
                name: `Object ${objId}`,
                color,
                src: selSrc,
                img: selImg,
                layerIndex: Number.isFinite(cutoutActiveLayerIndex) ? cutoutActiveLayerIndex : 0,
                x: minX + rx, y: minY + ry,
                scale: 1, scaleX: 1, scaleY: 1,
                rotation: 0, opacity: 1,
                drawW: cw, drawH: ch,
                keys: { position: [], zoom: [], rotation: [], opacity: [] }
              };
              clip.objects.push(newObj);
              cutoutActiveObject = newObj;
              cutoutSelectedObject = newObj;
              // Update or remove original object
              if (rr2 < rx2 || rb2 < ry2) {
                const idx0 = clip.objects.indexOf(obj);
                if (idx0 >= 0) clip.objects.splice(idx0, 1);
              } else {
                const cw2 = Math.max(1, rr2 - rx2 + 1);
                const ch2 = Math.max(1, rb2 - ry2 + 1);
                const cropRem = document.createElement('canvas'); cropRem.width = cw2; cropRem.height = ch2;
                const crCtx = cropRem.getContext('2d');
                crCtx.drawImage(off, rx2, ry2, cw2, ch2, 0, 0, cw2, ch2);
                const remImg = new Image();
                remImg.onload = () => {
                  // Preserve object's top-left by padding remainder into an aligned canvas
                  const oldX = obj.x, oldY = obj.y;
                  const oldDrawW = Math.max(1, Math.round(baseW0 * (obj.scale || 1) * effScaleX0));
                  const oldDrawH = Math.max(1, Math.round(baseH0 * (obj.scale || 1) * effScaleY0));
                  const aligned = document.createElement('canvas'); aligned.width = oldDrawW; aligned.height = oldDrawH;
                  const actx = aligned.getContext('2d');
                  const offsetX = Math.max(0, Math.round((ax + rx2) - oldX));
                  const offsetY = Math.max(0, Math.round((ay + ry2) - oldY));
                  actx.drawImage(remImg, offsetX, offsetY);
                  obj.img = aligned;
                  obj.src = aligned.toDataURL('image/png');
                  obj.x = oldX; obj.y = oldY;
                  obj.scale = 1; obj.scaleX = 1; obj.scaleY = 1; obj.rotation = 0;
                  obj.drawW = aligned.width; obj.drawH = aligned.height;
                  // We baked transforms into pixels; clear zoom/rotation keys to avoid reapplying scale/rotation
                  if (obj.keys) {
                    if (Array.isArray(obj.keys.zoom)) obj.keys.zoom = [];
                    if (Array.isArray(obj.keys.rotation)) obj.keys.rotation = [];
                  }
                  resolve({ obj: newObj, minX: newObj.x, minY: newObj.y, maxX: newObj.x + newObj.drawW, maxY: newObj.y + newObj.drawH });
                };
                remImg.src = cropRem.toDataURL('image/png');
                return;
              }
              resolve({ obj: newObj, minX: newObj.x, minY: newObj.y, maxX: newObj.x + newObj.drawW, maxY: newObj.y + newObj.drawH });
            };
            selImg.src = selSrc;
          });
        }
      } catch (_e) { /* fall back to raster */ }
      // Fallback: extract from clip raster
      const maskCanvas = document.createElement('canvas');
      maskCanvas.width = baseCanvas.width;
      maskCanvas.height = baseCanvas.height;
      const maskCtx = maskCanvas.getContext('2d');
      maskCtx.save();
      maskCtx.beginPath();
      maskCtx.moveTo(cutoutBoneLassoPoints[0][0], cutoutBoneLassoPoints[0][1]);
      for (let i = 1; i < cutoutBoneLassoPoints.length; i++) {
        maskCtx.lineTo(cutoutBoneLassoPoints[i][0], cutoutBoneLassoPoints[i][1]);
      }
      maskCtx.closePath();
      maskCtx.clip();
      maskCtx.drawImage(baseCanvas, 0, 0);
      maskCtx.restore();
      const cropped = document.createElement('canvas');
      cropped.width = selW; cropped.height = selH;
      const croppedCtx = cropped.getContext('2d');
      croppedCtx.drawImage(maskCanvas, minX, minY, selW, selH, 0, 0, selW, selH);
      // Clear original within polygon
      baseCtx.save();
      baseCtx.beginPath();
      baseCtx.moveTo(cutoutBoneLassoPoints[0][0], cutoutBoneLassoPoints[0][1]);
      for (let i = 1; i < cutoutBoneLassoPoints.length; i++) baseCtx.lineTo(cutoutBoneLassoPoints[i][0], cutoutBoneLassoPoints[i][1]);
      baseCtx.closePath();
      baseCtx.clip();
      baseCtx.clearRect(0, 0, baseCanvas.width, baseCanvas.height);
      baseCtx.restore();
      const src = cropped.toDataURL('image/png');
      const img = new Image();
      return new Promise((resolve) => {
        img.onload = () => {
          if (!Array.isArray(clip.objects)) clip.objects = [];
          const objId = (++cutoutObjectCounter);
          const color = cutoutObjectPalette[clip.objects.length % cutoutObjectPalette.length];
          const newObj = {
            id: objId,
            name: `Object ${objId}`,
            color,
            src,
            img,
            layerIndex: Number.isFinite(cutoutActiveLayerIndex) ? cutoutActiveLayerIndex : 0,
            x: minX, y: minY,
            scale: 1, scaleX: 1, scaleY: 1,
            rotation: 0, opacity: 1,
            drawW: cropped.width, drawH: cropped.height,
            keys: { position: [], zoom: [], rotation: [], opacity: [] }
          };
          clip.objects.push(newObj);
          cutoutActiveObject = newObj;
          cutoutSelectedObject = newObj;
          resolve({ obj: newObj, minX, minY, maxX, maxY });
        };
        img.src = src;
      });
    }
    // Bones Tool helpers
    function ensureBonesOverlay() {
      const canvas = canvases[currentFrame];
      const container = canvas.parentElement;
      if (bonesOverlayCanvas && bonesOverlayCanvas.parentElement !== container) {
        bonesOverlayCanvas.remove();
        bonesOverlayCanvas = null;
        bonesOverlayCtx = null;
      }
      if (!bonesOverlayCanvas) {
        bonesOverlayCanvas = document.createElement('canvas');
        bonesOverlayCanvas.width = canvas.width;
        bonesOverlayCanvas.height = canvas.height;
        bonesOverlayCanvas.style.position = 'absolute';
        bonesOverlayCanvas.style.top = '0';
        bonesOverlayCanvas.style.left = '0';
        bonesOverlayCanvas.style.width = '100%';
        bonesOverlayCanvas.style.height = '100%';
        bonesOverlayCanvas.style.pointerEvents = 'none';
        bonesOverlayCanvas.style.zIndex = '1002';
        bonesOverlayCtx = bonesOverlayCanvas.getContext('2d');
        container.style.position = 'relative';
        container.appendChild(bonesOverlayCanvas);
      }
    }

    function computePrincipalAxis(points) {
      // Compute centroid
      let cx = 0, cy = 0;
      for (const [x, y] of points) { cx += x; cy += y; }
      cx /= points.length; cy /= points.length;
      // Covariance components
      let sxx = 0, syy = 0, sxy = 0;
      for (const [x, y] of points) {
        const dx = x - cx, dy = y - cy;
        sxx += dx * dx; syy += dy * dy; sxy += dx * dy;
      }
      // Angle of principal component (eigenvector of largest eigenvalue)
      const angle = 0.5 * Math.atan2(2 * sxy, (sxx - syy));
      const vx = Math.cos(angle), vy = Math.sin(angle);
      // Project all points onto axis to get span
      let minProj = Infinity, maxProj = -Infinity;
      for (const [x, y] of points) {
        const proj = (x - cx) * vx + (y - cy) * vy;
        if (proj < minProj) minProj = proj;
        if (proj > maxProj) maxProj = proj;
      }
      return { cx, cy, angle, minProj, maxProj, vx, vy };
    }

    function unwrapAngle(prev, angle) {
      // Adjust angle by +/- 2Ï€ so it's closest to prev
      const TWO_PI = Math.PI * 2;
      while (angle - prev > Math.PI) angle -= TWO_PI;
      while (prev - angle > Math.PI) angle += TWO_PI;
      return angle;
    }

    function drawBonesOverlay() {
      if (!bonesOverlayCanvas) ensureBonesOverlay();
      if (!bonesOverlayCtx) return;
      const w = bonesOverlayCanvas.width, h = bonesOverlayCanvas.height;
      bonesOverlayCtx.clearRect(0, 0, w, h);
      // Ensure connected endpoints remain snapped to their parent joints
      enforceBoneConnections();
    const jointOuter = 17;
    const jointInner = 9;

    // Helper: determine if a given endpoint is a connection point between bones
    function endpointIsConnected(boneIndex, handle) {
      const b = bones[boneIndex];
      if (!b || b.frameIndex !== currentFrame) return false;
      if (b.parentBoneIndex !== undefined && b.parentBoneIndex !== null && b.attachedAt === handle) return true;
      for (let i = 0; i < bones.length; i++) {
        const c = bones[i];
        if (!c || c.frameIndex !== currentFrame) continue;
        if (c.parentBoneIndex === boneIndex && c.parentAttach === handle) return true;
      }
      return false;
    }

    for (let bi = 0; bi < bones.length; bi++) {
      const bone = bones[bi];
      if (!bone || bone.frameIndex !== currentFrame) continue;

      // Pear-like tapered shaft with a subtle bulge ~20% from the base and rounded tips
      bonesOverlayCtx.save();
      const dx = bone.endX - bone.startX;
      const dy = bone.endY - bone.startY;
      const length = Math.hypot(dx, dy) || 1;
      const ux = dx / length;
      const uy = dy / length;
      const px = -uy;
      const py = ux;
      const baseRadius = 12; // wider base belly right at start
      const tipRadius = 3;   // thinner tip
      const bulgeT = 0.12;   // belly close to start (~12% from start)
      const bulgeRadius = baseRadius + 2; // subtle extra belly beyond base
      const startLeftX = bone.startX + px * baseRadius;
      const startLeftY = bone.startY + py * baseRadius;
      const startRightX = bone.startX - px * baseRadius;
      const startRightY = bone.startY - py * baseRadius;
      const endLeftX = bone.endX + px * tipRadius;
      const endLeftY = bone.endY + py * tipRadius;
      const endRightX = bone.endX - px * tipRadius;
      const endRightY = bone.endY - py * tipRadius;

      // Bulge control points along centerline at ~20% from the start
      const bulgeCX = bone.startX + ux * (length * bulgeT);
      const bulgeCY = bone.startY + uy * (length * bulgeT);
      const bulgeLeftX = bulgeCX + px * bulgeRadius;
      const bulgeLeftY = bulgeCY + py * bulgeRadius;
      const bulgeRightX = bulgeCX - px * bulgeRadius;
      const bulgeRightY = bulgeCY - py * bulgeRadius;

      // Grey 70% opacity styling

      const anglePerp = Math.atan2(py, px);
      const anglePerpOpp = Math.atan2(-py, -px);

      bonesOverlayCtx.beginPath();
      bonesOverlayCtx.moveTo(startLeftX, startLeftY);
      // Left side: gently bowed outward using the bulge point as the quadratic control
      bonesOverlayCtx.quadraticCurveTo(bulgeLeftX, bulgeLeftY, endLeftX, endLeftY);
      // Rounded tip arc at end
      bonesOverlayCtx.arc(bone.endX, bone.endY, tipRadius, anglePerp, anglePerpOpp);
      // Right side: return using mirrored bulge for smooth symmetric shape
      bonesOverlayCtx.quadraticCurveTo(bulgeRightX, bulgeRightY, startRightX, startRightY);
      // Rounded base arc at start
      bonesOverlayCtx.arc(bone.startX, bone.startY, baseRadius, anglePerpOpp, anglePerp);
      bonesOverlayCtx.closePath();
      bonesOverlayCtx.fillStyle = 'rgba(157, 157, 157, 0.8)';
      bonesOverlayCtx.fill();
      bonesOverlayCtx.strokeStyle = 'rgba(0,0,0,0.12)';
      bonesOverlayCtx.lineWidth = 1.25;
      bonesOverlayCtx.stroke();

      // Joints: only connection points are orange; others use the prior styling
      const drawJoint = (x, y, connected) => {
      bonesOverlayCtx.beginPath();
      bonesOverlayCtx.fillStyle = 'rgba(157, 157, 157, 0.8)';
      bonesOverlayCtx.arc(x, y, jointOuter, 0, Math.PI * 2);
      bonesOverlayCtx.fill();
      bonesOverlayCtx.beginPath();
      bonesOverlayCtx.fillStyle = 'rgba(157, 157, 157, 0.8)';
      bonesOverlayCtx.arc(x, y, jointInner, 0, Math.PI * 2);
      bonesOverlayCtx.fill();
      // Outline around inner hexagon (replacing circle outline)
      bonesOverlayCtx.beginPath();
      const sides = 6;
      const r = jointInner;
      for (let i = 0; i < sides; i++) {
        const ang = Math.PI / 6 + (i * (Math.PI * 2 / sides));
        const vx = x + r * Math.cos(ang);
        const vy = y + r * Math.sin(ang);
        if (i === 0) bonesOverlayCtx.moveTo(vx, vy); else bonesOverlayCtx.lineTo(vx, vy);
      }
      bonesOverlayCtx.closePath();
      bonesOverlayCtx.fillStyle = 'rgba(65, 65, 65, 0.8)';
      bonesOverlayCtx.fill();
      bonesOverlayCtx.strokeStyle = 'rgba(65, 65, 65, 0.8)';
      bonesOverlayCtx.lineWidth = 1.0;
      bonesOverlayCtx.stroke();
      };

      const startConnected = endpointIsConnected(bi, 'start');
      const endConnected = endpointIsConnected(bi, 'end');
      drawJoint(bone.startX, bone.startY, startConnected);
      drawJoint(bone.endX, bone.endY, endConnected);

      bonesOverlayCtx.restore();
    }
    }

    // Schedule bones overlay redraw (throttled per animation frame)
    function scheduleDrawBonesOverlay() {
      if (bonesOverlayRafScheduled) return;
      bonesOverlayRafScheduled = true;
      requestAnimationFrame(() => {
        bonesOverlayRafScheduled = false;
        // Re-enforce connections once per frame before drawing
        enforceBoneConnections();
        ensureBonesOverlay();
        drawBonesOverlay();
      });
    }

    // Delete a bone by index and maintain tree indices
    function deleteBoneAtIndex(boneIndex) {
      if (boneIndex < 0 || boneIndex >= bones.length) return;
      saveState();
      bones.splice(boneIndex, 1);
      // Re-index children parentBoneIndex references
      for (let i = 0; i < bones.length; i++) {
        const b = bones[i];
        if (!b) continue;
        if (b.parentBoneIndex === boneIndex) {
          b.parentBoneIndex = null;
          b.attachedAt = null;
          b.parentAttach = null;
        } else if (typeof b.parentBoneIndex === 'number' && b.parentBoneIndex > boneIndex) {
          b.parentBoneIndex -= 1;
        }
      }
      selectedBoneIndex = -1;
      isDraggingBoneHandle = false;
      boneDrag = null;
      // Ensure lasso states are reset so we can draw new bones immediately
      isBoneLassoActive = false;
      boneLassoPoints = [];
      if (lassoOverlayCanvas) {
        try { lassoOverlayCanvas.remove(); } catch (_e) {}
        lassoOverlayCanvas = null;
        lassoOverlayCtx = null;
      }
      scheduleDrawBonesOverlay();
    }

    function getBoneHandleAtPoint(x, y) {
      const hitRadius = 20;
      for (let i = bones.length - 1; i >= 0; i--) {
        const b = bones[i];
        if (b.frameIndex !== currentFrame) continue;
        const dStart = Math.hypot(x - b.startX, y - b.startY);
        if (dStart <= hitRadius) return { boneIndex: i, handle: 'start' };
        const dEnd = Math.hypot(x - b.endX, y - b.endY);
        if (dEnd <= hitRadius) return { boneIndex: i, handle: 'end' };
      }
      return null;
    }

    // Bones connections helpers
    function getBoneHandleNearForConnection(x, y, excludeIndex, draggedHandle) {
      // Connection rules: ONLY end nodes can connect to start nodes
      // - If dragging an END handle, can only connect to a START handle
      // - If dragging a START handle, cannot form new connections
      if (draggedHandle === 'start') return null; // Start nodes cannot initiate connections
      
      const hitRadius = 16;
      for (let i = bones.length - 1; i >= 0; i--) {
        if (i === excludeIndex) continue;
        const b = bones[i];
        if (!b || b.frameIndex !== currentFrame) continue;
        // Only check START handles as valid connection targets for END handles
        const dStart = Math.hypot(x - b.startX, y - b.startY);
        if (dStart <= hitRadius) return { boneIndex: i, handle: 'start' };
        // END-to-END connections are not allowed
      }
      return null;
    }

    function getChildrenOfBone(boneIndex) {
      const kids = [];
      for (let i = 0; i < bones.length; i++) {
        const c = bones[i];
        if (!c || c.frameIndex !== currentFrame) continue;
        if (c.parentBoneIndex === boneIndex) kids.push(i);
      }
      return kids;
    }

    function getConnectedComponent(rootIndex) {
      const visited = new Set();
      const queue = [rootIndex];
      while (queue.length) {
        const idx = queue.shift();
        if (visited.has(idx)) continue;
        visited.add(idx);
        const b = bones[idx];
        if (!b) continue;
        if (b.parentBoneIndex !== undefined && b.parentBoneIndex !== null) queue.push(b.parentBoneIndex);
        const kids = getChildrenOfBone(idx);
        for (const k of kids) queue.push(k);
      }
      return Array.from(visited);
    }

    function enforceBoneConnections() {
      // Multiple passes to propagate constraints through chains
      for (let pass = 0; pass < bones.length; pass++) {
        let any = false;
        for (let i = 0; i < bones.length; i++) {
          const c = bones[i];
          if (!c || c.frameIndex !== currentFrame) continue;
          if (c.parentBoneIndex === undefined || c.parentBoneIndex === null) continue;
          const p = bones[c.parentBoneIndex];
          if (!p || p.frameIndex !== currentFrame) continue;
          const px = c.parentAttach === 'start' ? p.startX : p.endX;
          const py = c.parentAttach === 'start' ? p.startY : p.endY;
          if (c.attachedAt === 'start') {
            const dx = px - c.startX;
            const dy = py - c.startY;
            if (dx !== 0 || dy !== 0) {
              c.startX = px; c.startY = py;
              c.endX += dx; c.endY += dy;
              any = true;
              // Clamp to canvas
              try {
                const canvas = canvases && canvases[currentFrame];
                const cw = canvas ? canvas.width : 0;
                const ch = canvas ? canvas.height : 0;
                if (cw && ch) {
                  c.startX = Math.max(0, Math.min(cw, c.startX));
                  c.startY = Math.max(0, Math.min(ch, c.startY));
                  c.endX = Math.max(0, Math.min(cw, c.endX));
                  c.endY = Math.max(0, Math.min(ch, c.endY));
                }
              } catch (_e) {}
            }
          } else if (c.attachedAt === 'end') {
            const dx = px - c.endX;
            const dy = py - c.endY;
            if (dx !== 0 || dy !== 0) {
              c.endX = px; c.endY = py;
              c.startX += dx; c.startY += dy;
              any = true;
              // Clamp to canvas
              try {
                const canvas = canvases && canvases[currentFrame];
                const cw = canvas ? canvas.width : 0;
                const ch = canvas ? canvas.height : 0;
                if (cw && ch) {
                  c.startX = Math.max(0, Math.min(cw, c.startX));
                  c.startY = Math.max(0, Math.min(ch, c.startY));
                  c.endX = Math.max(0, Math.min(cw, c.endX));
                  c.endY = Math.max(0, Math.min(ch, c.endY));
                }
              } catch (_e) {}
            }
          }
        }
        if (!any) break;
      }
    }

    function moveJointWithParentRotation(boneIndex, handle, targetX, targetY) {
      const b = bones[boneIndex];
      if (!b || b.frameIndex !== currentFrame) return;

      // Determine which bone is the parent to rotate and which joint on it
      let parentIndex = boneIndex;
      let parent = b;
      let parentJointSide = handle; // 'start' | 'end' on parent
      // If this handle is attached to an upstream parent, rotate that parent instead
      if (b.parentBoneIndex !== undefined && b.parentBoneIndex !== null && b.attachedAt === handle) {
        parentIndex = b.parentBoneIndex;
        parent = bones[parentIndex];
        if (!parent || parent.frameIndex !== currentFrame) return;
        parentJointSide = b.parentAttach; // joint side on parent
      }

      // Compute pivot at the parent's opposite endpoint and current joint position
      const pivotX = parentJointSide === 'start' ? parent.endX : parent.startX;
      const pivotY = parentJointSide === 'start' ? parent.endY : parent.startY;
      const oldJointX = parentJointSide === 'start' ? parent.startX : parent.endX;
      const oldJointY = parentJointSide === 'start' ? parent.startY : parent.endY;

      // Constrain the joint onto the circle around pivot with radius = parent.restLength
      const L = Math.max(0.0001, parent.restLength || Math.hypot(parent.endX - parent.startX, parent.endY - parent.startY));
      let vx = targetX - pivotX;
      let vy = targetY - pivotY;
      const len = Math.hypot(vx, vy) || 1;
      vx /= len; vy /= len;
      const newJointX = pivotX + vx * L;
      const newJointY = pivotY + vy * L;

      // Apply rotation to parent by setting its joint endpoint; keep pivot fixed
      if (parentJointSide === 'start') { parent.startX = newJointX; parent.startY = newJointY; }
      else { parent.endX = newJointX; parent.endY = newJointY; }
      // Clamp parent endpoints to canvas
      try {
        const canvas = canvases && canvases[currentFrame];
        const cw = canvas ? canvas.width : 0;
        const ch = canvas ? canvas.height : 0;
        if (cw && ch) {
          parent.startX = Math.max(0, Math.min(cw, parent.startX));
          parent.startY = Math.max(0, Math.min(ch, parent.startY));
          parent.endX = Math.max(0, Math.min(cw, parent.endX));
          parent.endY = Math.max(0, Math.min(ch, parent.endY));
        }
      } catch (_e) {}

      // Update parent's image orientation (no scaling)
      if (parent.imageObj) {
        const rawAngle = Math.atan2(parent.endY - parent.startY, parent.endX - parent.startX);
        const angle = unwrapAngle(parent.prevAngle || rawAngle, rawAngle);
        parent.prevAngle = angle;
        parent.imageObj.rotation = (parent.imageRotationOffset || 0) + angle;
        const baseW = (parent.imageObj && parent.imageObj.drawW != null) ? parent.imageObj.drawW : ((parent.imageObj && parent.imageObj.img && (parent.imageObj.img.naturalWidth || parent.imageObj.img.width || parent.imageObj.img.videoWidth)) || 0);
        const baseH = (parent.imageObj && parent.imageObj.drawH != null) ? parent.imageObj.drawH : ((parent.imageObj && parent.imageObj.img && (parent.imageObj.img.naturalHeight || parent.imageObj.img.height || parent.imageObj.img.videoHeight)) || 0);
        const effScaleX = (typeof parent.imageObj.scaleX === 'number' ? parent.imageObj.scaleX : 1);
        const effScaleY = (typeof parent.imageObj.scaleY === 'number' ? parent.imageObj.scaleY : 1);
        const drawW = baseW * (parent.imageObj.scale || 1) * effScaleX;
        const drawH = baseH * (parent.imageObj.scale || 1) * effScaleY;
        // Ensure pinned local exists; if absent, compute from current position to keep start pinned
        if (typeof parent.pinnedLocalX !== 'number' || typeof parent.pinnedLocalY !== 'number') {
          const centerX0 = parent.imageObj.x + drawW / 2;
          const centerY0 = parent.imageObj.y + drawH / 2;
          const rot0 = parent.imageObj.rotation || 0;
          const dx0 = parent.startX - centerX0;
          const dy0 = parent.startY - centerY0;
          const c0 = Math.cos(rot0), s0 = Math.sin(rot0);
          parent.pinnedLocalX = dx0 * c0 + dy0 * s0;
          parent.pinnedLocalY = -dx0 * s0 + dy0 * c0;
        }
        const c = Math.cos(parent.imageObj.rotation || 0), s = Math.sin(parent.imageObj.rotation || 0);
        const rx = parent.pinnedLocalX * c - parent.pinnedLocalY * s;
        const ry = parent.pinnedLocalX * s + parent.pinnedLocalY * c;
        const centerX = parent.startX - rx;
        const centerY = parent.startY - ry;
        parent.imageObj.x = centerX - drawW / 2;
        parent.imageObj.y = centerY - drawH / 2;
      }

      // Delta of the joint motion
      const djx = newJointX - oldJointX;
      const djy = newJointY - oldJointY;

      // Translate all children connected at this joint (no rotation)
      for (let i = 0; i < bones.length; i++) {
        const c = bones[i];
        if (!c || c.frameIndex !== currentFrame) continue;
        if (c.parentBoneIndex === parentIndex && c.parentAttach === parentJointSide) {
          c.startX += djx; c.startY += djy;
          c.endX += djx; c.endY += djy;
          // Clamp child endpoints
          try {
            const canvas = canvases && canvases[currentFrame];
            const cw = canvas ? canvas.width : 0;
            const ch = canvas ? canvas.height : 0;
            if (cw && ch) {
              c.startX = Math.max(0, Math.min(cw, c.startX));
              c.startY = Math.max(0, Math.min(ch, c.startY));
              c.endX = Math.max(0, Math.min(cw, c.endX));
              c.endY = Math.max(0, Math.min(ch, c.endY));
            }
          } catch (_e) {}
          if (c.imageObj) { c.imageObj.x += djx; c.imageObj.y += djy; }
        }
      }

      // If the dragged handle belonged to a child attached at this joint, ensure its attached point snaps
      enforceBoneConnections();
    }

    function createSelectionFromPolygonForBones() {
      const layer = frameLayers[currentFrame][currentLayer];
      if (boneLassoPoints.length < 3) return null;
      // Compute polygon bbox
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      for (const p of boneLassoPoints) {
        if (p[0] < minX) minX = p[0];
        if (p[1] < minY) minY = p[1];
        if (p[0] > maxX) maxX = p[0];
        if (p[1] > maxY) maxY = p[1];
      }
      minX = Math.max(0, Math.floor(minX));
      minY = Math.max(0, Math.floor(minY));
      maxX = Math.ceil(maxX);
      maxY = Math.ceil(maxY);
      const selW = Math.max(1, maxX - minX);
      const selH = Math.max(1, maxY - minY);
      // Try to extract from imported images first (topmost first)
      try {
        const objs = Array.isArray(layer.images) ? layer.images : [];
        for (let i = objs.length - 1; i >= 0; i--) {
          const obj = objs[i];
          if (!obj || !obj.img) continue;
          // Quick AABB overlap against polygon bbox
          const baseW0 = (obj && obj.drawW != null)
            ? obj.drawW
            : ((obj && obj.img && (obj.img.naturalWidth || obj.img.width || obj.img.videoWidth)) || 0);
          const baseH0 = (obj && obj.drawH != null)
            ? obj.drawH
            : ((obj && obj.img && (obj.img.naturalHeight || obj.img.height || obj.img.videoHeight)) || 0);
          const effScaleX0 = (obj && typeof obj.scaleX === 'number') ? obj.scaleX : 1;
          const effScaleY0 = (obj && typeof obj.scaleY === 'number') ? obj.scaleY : 1;
          const wDraw0 = baseW0 * (obj.scale || 1) * effScaleX0;
          const hDraw0 = baseH0 * (obj.scale || 1) * effScaleY0;
          const cx0 = obj.x + wDraw0 / 2;
          const cy0 = obj.y + hDraw0 / 2;
          const rot0 = obj.rotation || 0;
          const cosR = Math.cos(rot0), sinR = Math.sin(rot0);
          const corners = [
            { x: obj.x,           y: obj.y },
            { x: obj.x + wDraw0,  y: obj.y },
            { x: obj.x + wDraw0,  y: obj.y + hDraw0 },
            { x: obj.x,           y: obj.y + hDraw0 }
          ].map(p => {
            const dx = p.x - cx0, dy = p.y - cy0;
            return { x: cx0 + dx * cosR - dy * sinR, y: cy0 + dx * sinR + dy * cosR };
          });
          let ax = Infinity, ay = Infinity, ar = -Infinity, ab = -Infinity;
          for (const c of corners) { if (c.x < ax) ax = c.x; if (c.y < ay) ay = c.y; if (c.x > ar) ar = c.x; if (c.y > ab) ab = c.y; }
          ax = Math.floor(ax); ay = Math.floor(ay); ar = Math.ceil(ar); ab = Math.ceil(ab);
          // AABB intersect?
          const intersects = !(ar < minX || ax > maxX || ab < minY || ay > maxY);
          if (!intersects) continue;
          // Build selection offscreen within polygon bbox
          const selOff = document.createElement('canvas');
          selOff.width = selW; selOff.height = selH;
          const sctx = selOff.getContext('2d', { willReadFrequently: true });
          drawRotatedImage(sctx, obj, 1, 1, -minX, -minY);
          // Keep only polygon region
          sctx.save();
          sctx.beginPath();
          sctx.moveTo(boneLassoPoints[0][0] - minX, boneLassoPoints[0][1] - minY);
          for (let k = 1; k < boneLassoPoints.length; k++) sctx.lineTo(boneLassoPoints[k][0] - minX, boneLassoPoints[k][1] - minY);
          sctx.closePath();
          sctx.globalCompositeOperation = 'destination-in';
          sctx.fillStyle = '#fff';
          sctx.fill();
          sctx.restore();
          // Tight crop selection
          const idSel = sctx.getImageData(0, 0, selW, selH);
          const dataSel = idSel.data;
          let rx = selW, ry = selH, rr = -1, rb = -1;
          for (let y = 0; y < selH; y++) {
            for (let x = 0; x < selW; x++) {
              const a = dataSel[(y * selW + x) * 4 + 3];
              if (a > 0) { if (x < rx) rx = x; if (y < ry) ry = y; if (x > rr) rr = x; if (y > rb) rb = y; }
            }
          }
          if (rr < rx || rb < ry) {
            // No pixels selected on this object, try next
            continue;
          }
          const cw = Math.max(1, rr - rx + 1);
          const ch = Math.max(1, rb - ry + 1);
          const cropSel = document.createElement('canvas'); cropSel.width = cw; cropSel.height = ch;
          const csCtx = cropSel.getContext('2d');
          csCtx.drawImage(selOff, rx, ry, cw, ch, 0, 0, cw, ch);
          const selSrc = cropSel.toDataURL('image/png');
          // Subtract polygon from original object to avoid duplication (similar to cutout eraser segmentation)
          const offW = Math.max(1, ar - ax), offH = Math.max(1, ab - ay);
          const off = document.createElement('canvas'); off.width = offW; off.height = offH;
          const octx = off.getContext('2d', { willReadFrequently: true });
          drawRotatedImage(octx, obj, 1, 1, -ax, -ay);
          octx.save();
          octx.beginPath();
          octx.moveTo(boneLassoPoints[0][0] - ax, boneLassoPoints[0][1] - ay);
          for (let k = 1; k < boneLassoPoints.length; k++) octx.lineTo(boneLassoPoints[k][0] - ax, boneLassoPoints[k][1] - ay);
          octx.closePath();
          octx.globalCompositeOperation = 'destination-out';
          octx.fillStyle = '#fff';
          octx.fill();
          octx.restore();
          const idRem = octx.getImageData(0, 0, offW, offH);
          const dataRem = idRem.data;
          let rx2 = offW, ry2 = offH, rr2 = -1, rb2 = -1;
          for (let y = 0; y < offH; y++) {
            for (let x = 0; x < offW; x++) {
              const a = dataRem[(y * offW + x) * 4 + 3];
              if (a > 0) { if (x < rx2) rx2 = x; if (y < ry2) ry2 = y; if (x > rr2) rr2 = x; if (y > rb2) rb2 = y; }
            }
          }
          // Prepare promise to load selection image, update original, and push new object
          return new Promise((resolve) => {
            const selImg = new Image();
            selImg.onload = () => {
              // Create new object for selected piece
              const newObj = { img: selImg, src: selSrc, x: minX + rx, y: minY + ry, scale: 1, scaleX: 1, scaleY: 1, rotation: 0, drawW: cw, drawH: ch };
              if (!Array.isArray(layer.images)) layer.images = [];
              layer.images.push(newObj);
              selectedImageObject = newObj;
              // Update or remove original object based on remainder
              if (rr2 < rx2 || rb2 < ry2) {
                // Entire object removed
                const idx = layer.images.indexOf(obj);
                if (idx >= 0) layer.images.splice(idx, 1);
              } else {
                const cw2 = Math.max(1, rr2 - rx2 + 1);
                const ch2 = Math.max(1, rb2 - ry2 + 1);
                const cropRem = document.createElement('canvas'); cropRem.width = cw2; cropRem.height = ch2;
                const crCtx = cropRem.getContext('2d');
                crCtx.drawImage(off, rx2, ry2, cw2, ch2, 0, 0, cw2, ch2);
                const remImg = new Image();
                remImg.onload = () => {
                  // Preserve object's top-left by padding remainder into an aligned canvas
                  const oldX = obj.x, oldY = obj.y;
                  const oldDrawW = Math.max(1, Math.round(baseW0 * (obj.scale || 1) * effScaleX0));
                  const oldDrawH = Math.max(1, Math.round(baseH0 * (obj.scale || 1) * effScaleY0));
                  const aligned = document.createElement('canvas'); aligned.width = oldDrawW; aligned.height = oldDrawH;
                  const actx = aligned.getContext('2d');
                  const offsetX = Math.max(0, Math.round((ax + rx2) - oldX));
                  const offsetY = Math.max(0, Math.round((ay + ry2) - oldY));
                  actx.drawImage(remImg, offsetX, offsetY);
                  obj.img = aligned;
                  obj.src = aligned.toDataURL('image/png');
                  obj.x = oldX; obj.y = oldY;
                  obj.scale = 1; obj.scaleX = 1; obj.scaleY = 1; obj.rotation = 0;
                  obj.drawW = aligned.width; obj.drawH = aligned.height;
                  composeLayers(currentFrame);
                  updateThumbnail(currentFrame);
                  resolve({ obj: newObj, minX: newObj.x, minY: newObj.y, maxX: newObj.x + newObj.drawW, maxY: newObj.y + newObj.drawH });
                };
                remImg.src = cropRem.toDataURL('image/png');
                return;
              }
              composeLayers(currentFrame);
              updateThumbnail(currentFrame);
              resolve({ obj: newObj, minX: newObj.x, minY: newObj.y, maxX: newObj.x + newObj.drawW, maxY: newObj.y + newObj.drawH });
            };
            selImg.src = selSrc;
          });
        }
      } catch (_e) { /* fall back to raster */ }
      // Fallback: extract from base raster (brush strokes)
      const baseCanvas = layer.canvas;
      const baseCtx = layer.ctx;
      const maskCanvas = document.createElement('canvas');
      maskCanvas.width = baseCanvas.width;
      maskCanvas.height = baseCanvas.height;
      const maskCtx = maskCanvas.getContext('2d');
      maskCtx.save();
      maskCtx.beginPath();
      maskCtx.moveTo(boneLassoPoints[0][0], boneLassoPoints[0][1]);
      for (let i = 1; i < boneLassoPoints.length; i++) maskCtx.lineTo(boneLassoPoints[i][0], boneLassoPoints[i][1]);
      maskCtx.closePath();
      maskCtx.clip();
      maskCtx.drawImage(baseCanvas, 0, 0);
      maskCtx.restore();
      const cropped = document.createElement('canvas');
      cropped.width = selW;
      cropped.height = selH;
      const croppedCtx = cropped.getContext('2d');
      croppedCtx.drawImage(maskCanvas, minX, minY, selW, selH, 0, 0, selW, selH);
      // Clear the selected pixels from the base layer
      baseCtx.save();
      baseCtx.beginPath();
      baseCtx.moveTo(boneLassoPoints[0][0], boneLassoPoints[0][1]);
      for (let i = 1; i < boneLassoPoints.length; i++) baseCtx.lineTo(boneLassoPoints[i][0], boneLassoPoints[i][1]);
      baseCtx.closePath();
      baseCtx.clip();
      baseCtx.clearRect(0, 0, baseCanvas.width, baseCanvas.height);
      baseCtx.restore();
      const src = cropped.toDataURL('image/png');
      const img = new Image();
      return new Promise((resolve) => {
        img.onload = () => {
          const obj = { img, src, x: minX, y: minY, scale: 1, scaleX: 1, scaleY: 1, rotation: 0, drawW: selW, drawH: selH };
          if (!Array.isArray(layer.images)) layer.images = [];
          layer.images.push(obj);
          selectedImageObject = obj;
          composeLayers(currentFrame);
          updateThumbnail(currentFrame);
          resolve({ obj, minX, minY, maxX, maxY });
        };
        img.src = src;
      });
    }

    function ensureFillLayer(frameIdx) {
      const layers = frameLayers[frameIdx] || [];
      const baseCanvas = canvases[frameIdx];
      if (!baseCanvas) return null;
      if (layers[0] && layers[0].__fillLayer) return layers[0];
      
      const fillCanvas = document.createElement('canvas');
      fillCanvas.width = baseCanvas.width;
      fillCanvas.height = baseCanvas.height;
      const fillCtx = fillCanvas.getContext('2d');
      fillCtx.clearRect(0, 0, fillCanvas.width, fillCanvas.height);
      const fillLayer = {
        canvas: fillCanvas,
        ctx: fillCtx,
        visible: true,
        name: 'Fill',
        opacity: 1,
        color: '#000000',
        images: [],
        __fillLayer: true
      };
      layers.unshift(fillLayer);
      frameLayers[frameIdx] = layers;
      if (typeof currentLayer === 'number') {
        currentLayer += 1; // preserve current selection by shifting once
      }
      return fillLayer;
    }

    function floodFill(startX, startY) {
      const layers = frameLayers[currentFrame] || [];
      const fillLayer = ensureFillLayer(currentFrame);
      if (!fillLayer) return;
      const ctx = fillLayer.ctx;
      const canvas = fillLayer.canvas;
      
      // Save state before fill operation
      saveState();
      
      // Fill the entire canvas with the selected color
      ctx.fillStyle = currentColor;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      composeLayers();
      updateThumbnail(currentFrame);
      // Post-action snapshot for redo
      saveState();
    }

    function innerFill(startX, startY) {
      const layer = frameLayers[currentFrame][currentLayer];
      const ctx = layer.ctx;
      const canvas = layer.canvas;
      
      // Save state before fill operation
      saveState();
      
      // Get the image data to analyze the canvas
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      const width = canvas.width;
      const height = canvas.height;
      
      // Convert start coordinates to integers
      const x = Math.floor(startX);
      const y = Math.floor(startY);
      
      // Check bounds
      if (x < 0 || x >= width || y < 0 || y >= height) return;
      
      // Get the color at the starting point
      const startIndex = (y * width + x) * 4;
      const startR = data[startIndex];
      const startG = data[startIndex + 1];
      const startB = data[startIndex + 2];
      const startA = data[startIndex + 3];
      
      // If the starting point is already the fill color, don't fill
      const fillColor = hexToRgb(currentColor);
      if (startR === fillColor.r && startG === fillColor.g && startB === fillColor.b && startA === 255) {
        return;
      }
      
      // Improved flood fill with color tolerance and 8-directional neighbors
      const stack = [{x, y}];
      const visited = new Set();
      const colorTolerance = 30; // Allow for slight color variations (anti-aliasing)
      
      // Helper function to check if colors are similar enough
      function colorsMatch(r1, g1, b1, a1, r2, g2, b2, a2) {
        if (a1 === 0 && a2 === 0) return true; // Both transparent
        if (a1 === 0 || a2 === 0) return false; // One transparent, one not
        
        const rDiff = Math.abs(r1 - r2);
        const gDiff = Math.abs(g1 - g2);
        const bDiff = Math.abs(b1 - b2);
        const aDiff = Math.abs(a1 - a2);
        
        return rDiff <= colorTolerance && gDiff <= colorTolerance && 
               bDiff <= colorTolerance && aDiff <= colorTolerance;
      }
      
      while (stack.length > 0) {
        const {x: currentX, y: currentY} = stack.pop();
        const key = `${currentX},${currentY}`;
        
        if (visited.has(key)) continue;
        if (currentX < 0 || currentX >= width || currentY < 0 || currentY >= height) continue;
        
        const index = (currentY * width + currentX) * 4;
        const r = data[index];
        const g = data[index + 1];
        const b = data[index + 2];
        const a = data[index + 3];
        
        // Check if this pixel matches the starting color (with tolerance)
        if (colorsMatch(r, g, b, a, startR, startG, startB, startA)) {
          visited.add(key);
          
          // Add 8-directional neighboring pixels to stack for better edge detection
          stack.push({x: currentX + 1, y: currentY});     // Right
          stack.push({x: currentX - 1, y: currentY});     // Left
          stack.push({x: currentX, y: currentY + 1});     // Down
          stack.push({x: currentX, y: currentY - 1});     // Up
          stack.push({x: currentX + 1, y: currentY + 1}); // Down-Right
          stack.push({x: currentX - 1, y: currentY + 1}); // Down-Left
          stack.push({x: currentX + 1, y: currentY - 1}); // Up-Right
          stack.push({x: currentX - 1, y: currentY - 1}); // Up-Left
        }
      }
      
      // Create a new image data with the fill applied
      const newImageData = ctx.createImageData(width, height);
      const newData = newImageData.data;
      
      // Copy original data
      for (let i = 0; i < data.length; i++) {
        newData[i] = data[i];
      }
      
      // Apply fill color to visited pixels
      for (const key of visited) {
        const [x, y] = key.split(',').map(Number);
        const index = (y * width + x) * 4;
        newData[index] = fillColor.r;
        newData[index + 1] = fillColor.g;
        newData[index + 2] = fillColor.b;
        newData[index + 3] = 255;
      }
      
      // Expand filled pixels by 1 pixel in all directions to overlap with outline and eliminate gaps
      const expandedPixels = new Set();
      for (const key of visited) {
        const [x, y] = key.split(',').map(Number);
        // Add neighboring pixels to fill gaps with anti-aliased edges
        for (let dx = -1; dx <= 1; dx++) {
          for (let dy = -1; dy <= 1; dy++) {
            const nx = x + dx;
            const ny = y + dy;
            if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
              const nKey = `${nx},${ny}`;
              const nIndex = (ny * width + nx) * 4;
              // Only expand into semi-transparent or similar colored pixels (edge pixels)
              const pixelAlpha = newData[nIndex + 3];
              if (pixelAlpha < 255 && pixelAlpha > 0) {
                expandedPixels.add(nKey);
              }
            }
          }
        }
      }
      
      // Fill the expanded edge pixels
      for (const key of expandedPixels) {
        const [x, y] = key.split(',').map(Number);
        const index = (y * width + x) * 4;
        newData[index] = fillColor.r;
        newData[index + 1] = fillColor.g;
        newData[index + 2] = fillColor.b;
        newData[index + 3] = 255;
      }
      
      // Put the modified image data back
      ctx.putImageData(newImageData, 0, 0);
      
      composeLayers();
      updateThumbnail(currentFrame);
      // Post-action snapshot for redo
      saveState();
    }

    function pickColorFromCanvas(x, y) {
      // Get the composed canvas (main canvas with all layers)
      const canvas = canvases[currentFrame];
      const ctx = canvas.getContext('2d');
      
      // Get image data at the clicked point
      const imageData = ctx.getImageData(x, y, 1, 1);
      const data = imageData.data;
      
      // Extract RGBA values
      const r = data[0];
      const g = data[1];
      const b = data[2];
      const a = data[3];
      
      // Convert to hex format
      const hex = rgbToHex(r, g, b);
      
      // Update global color
      currentColor = hex;
      
      // Update color picker input if it exists
      const colorInput = document.getElementById('color-picker');
      if (colorInput) {
        colorInput.value = hex;
      }
      
      // Update status text to show picked color
      document.getElementById('status-text').textContent = `Color picked: ${hex}`;
      
      // Visual feedback - briefly change cursor or show picked color
      showColorPickFeedback(hex);
    }

    function rgbToHex(r, g, b) {
      return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    }

    function showColorPickFeedback(color) {
      // Create a temporary visual feedback element
      const feedback = document.createElement('div');
      feedback.style.position = 'fixed';
      feedback.style.left = '50%';
      feedback.style.top = '50%';
      feedback.style.transform = 'translate(-50%, -50%)';
      feedback.style.backgroundColor = color;
      feedback.style.color = getContrastColor(color);
      feedback.style.padding = '8px 16px';
      feedback.style.borderRadius = '8px';
      feedback.style.fontSize = '14px';
      feedback.style.fontWeight = 'bold';
      feedback.style.zIndex = '10000';
      feedback.style.pointerEvents = 'none';
      feedback.textContent = `Picked: ${color}`;
      
      document.body.appendChild(feedback);
      
      // Remove after 1.5 seconds
      setTimeout(() => {
        if (feedback.parentNode) {
          feedback.parentNode.removeChild(feedback);
        }
      }, 1500);
    }

    function getContrastColor(hexColor) {
      // Convert hex to RGB
      const r = parseInt(hexColor.slice(1, 3), 16);
      const g = parseInt(hexColor.slice(3, 5), 16);
      const b = parseInt(hexColor.slice(5, 7), 16);
      
      // Calculate luminance
      const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
      
      // Return black for light colors, white for dark colors
      return luminance > 0.5 ? '#000000' : '#ffffff';
    }

    // Image import and selection helpers
    function handleImageFileInput(fileList) {
      if (!fileList || !fileList.length) return;
      const file = fileList[0];
      const reader = new FileReader();
      reader.onload = () => {
        addImageToCurrentLayerFromSrc(reader.result);
      };
      reader.readAsDataURL(file);
    }

    function addImageToCurrentLayerFromSrc(src) {
      const layer = frameLayers[currentFrame][currentLayer];
      const canvas = canvases[currentFrame];
      const img = new Image();
      img.onload = () => {
        const scaleX = canvas.width / img.naturalWidth;
        const scaleY = canvas.height / img.naturalHeight;
        const scale = Math.min(0.6, Math.min(scaleX, scaleY));
        const drawW = img.naturalWidth * scale;
        const drawH = img.naturalHeight * scale;
        const x = Math.max(0, (canvas.width - drawW) / 2);
        const y = Math.max(0, (canvas.height - drawH) / 2);
        if (!Array.isArray(layer.images)) layer.images = [];
        const color = (Array.isArray(cutoutObjectPalette) && cutoutObjectPalette.length)
          ? cutoutObjectPalette[layer.images.length % cutoutObjectPalette.length]
          : '#6366f1';
        const obj = { img, src, x, y, scale, scaleX: 1, scaleY: 1, rotation: 0, color };
        layer.images.push(obj);
        composeLayers();
        updateThumbnail(currentFrame);
        updateLayersList();
        // Auto-switch to select tool and select the new image
        setTool('select');
        selectedImageObject = obj;
        beginImageDrag();
      };
      img.src = src;
    }

    function addImageToLayerAtPosition(src, frameIndex, clientX, clientY) {
      if (frameIndex !== currentFrame) selectFrame(frameIndex);
      const canvas = canvases[frameIndex];
      const coords = getCanvasCoordinates(canvas, clientX, clientY);
      const layer = frameLayers[frameIndex][currentLayer];
      const img = new Image();
      img.onload = () => {
        const scaleX = canvas.width / img.naturalWidth;
        const scaleY = canvas.height / img.naturalHeight;
        const scale = Math.min(0.6, Math.min(scaleX, scaleY));
        const drawW = img.naturalWidth * scale;
        const drawH = img.naturalHeight * scale;
        let x = coords.x - drawW / 2;
        let y = coords.y - drawH / 2;
        x = Math.max(0, Math.min(x, canvas.width - drawW));
        y = Math.max(0, Math.min(y, canvas.height - drawH));
        if (!Array.isArray(layer.images)) layer.images = [];
        const color = (Array.isArray(cutoutObjectPalette) && cutoutObjectPalette.length)
          ? cutoutObjectPalette[layer.images.length % cutoutObjectPalette.length]
          : '#6366f1';
        const obj = { img, src, x, y, scale, scaleX: 1, scaleY: 1, rotation: 0, color };
        layer.images.push(obj);
        composeLayers(frameIndex);
        updateThumbnail(frameIndex);
        updateLayersList();
        // Auto-switch to select tool and select the new image
        setTool('select');
        selectedImageObject = obj;
        beginImageDrag();
      };
      img.src = src;
    }

    function handleDroppedFiles(fileList, frameIndex, clientX, clientY) {
      let file = null;
      for (let i = 0; i < fileList.length; i++) {
        if (fileList[i].type && fileList[i].type.startsWith('image/')) { file = fileList[i]; break; }
      }
      if (!file) return;
      const reader = new FileReader();
      reader.onload = () => addImageToLayerAtPosition(reader.result, frameIndex, clientX, clientY);
      reader.readAsDataURL(file);
    }

    function drawImagesOnContext(ctx, layer) {
      if (!layer || !Array.isArray(layer.images)) return;
      for (const obj of layer.images) {
        const objScaleX = (obj && typeof obj.scaleX === 'number') ? obj.scaleX : 1;
        const objScaleY = (obj && typeof obj.scaleY === 'number') ? obj.scaleY : 1;
        const w = obj.img.naturalWidth * obj.scale * objScaleX;
        const h = obj.img.naturalHeight * obj.scale * objScaleY;
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';
        ctx.drawImage(obj.img, obj.x, obj.y, w, h);
      }
    }

    function validateSelectedImage() {
      // Check if selectedImageObject still exists in the current layer
      if (!selectedImageObject) return false;
      const layer = frameLayers[currentFrame][currentLayer];
      if (!layer || !Array.isArray(layer.images)) {
        selectedImageObject = null;
        return false;
      }
      if (!layer.images.includes(selectedImageObject)) {
        selectedImageObject = null;
        return false;
      }
      return true;
    }

    function refreshSelectionOverlay() {
      // Ensure the selection overlay is properly displayed with current state
      if (selectedImageObject && moveOverlayCtx) {
        moveOverlayCtx.clearRect(0, 0, moveOverlayCanvas.width, moveOverlayCanvas.height);
        moveOverlayCtx.imageSmoothingEnabled = true;
        moveOverlayCtx.imageSmoothingQuality = 'high';
        drawRotatedImage(moveOverlayCtx, selectedImageObject);
        if (currentTool === 'select') {
          drawResizeHandles(moveOverlayCtx, selectedImageObject);
        }
      }
    }

    function hitTestImage(layer, x, y) {
      if (!layer || !Array.isArray(layer.images)) return null;
      // Test topmost first: within this layer, higher id (newer) should be on top
      const images = layer.images.slice().sort((a, b) => {
        const aid = (a && a.id != null) ? a.id : -Infinity;
        const bid = (b && b.id != null) ? b.id : -Infinity;
        return bid - aid; // higher id first (on top)
      });
      for (let i = 0; i < images.length; i++) {
        const obj = images[i];
        const objScaleX = (obj && typeof obj.scaleX === 'number') ? obj.scaleX : 1;
        const objScaleY = (obj && typeof obj.scaleY === 'number') ? obj.scaleY : 1;
        // Use same dimension logic as drawRotatedImage/calculateSelectionHandleGeometry to support Canvas-backed images
        const baseW = (obj && obj.drawW != null)
          ? obj.drawW
          : ((obj && obj.img && (obj.img.naturalWidth || obj.img.width || obj.img.videoWidth)) || 0);
        const baseH = (obj && obj.drawH != null)
          ? obj.drawH
          : ((obj && obj.img && (obj.img.naturalHeight || obj.img.height || obj.img.videoHeight)) || 0);
        const w = baseW * (obj.scale || 1) * objScaleX;
        const h = baseH * (obj.scale || 1) * objScaleY;
        const centerX = obj.x + w / 2;
        const centerY = obj.y + h / 2;
        const rotation = obj.rotation || 0;
        
        if (rotation !== 0) {
          // Transform click point to image's local coordinate system (inverse rotation)
          const dx = x - centerX;
          const dy = y - centerY;
          const localX = centerX + dx * Math.cos(-rotation) - dy * Math.sin(-rotation);
          const localY = centerY + dx * Math.sin(-rotation) + dy * Math.cos(-rotation);
          
          // Check if the transformed point is within the unrotated bounds
          if (localX >= obj.x && localX <= obj.x + w && localY >= obj.y && localY <= obj.y + h) {
            return obj;
          }
        } else {
          // No rotation, use simple bounding box check
          if (x >= obj.x && x <= obj.x + w && y >= obj.y && y <= obj.y + h) return obj;
        }
      }
      return null;
    }

    function calculateSelectionHandleGeometry(obj) {
      const objScaleX = (obj && typeof obj.scaleX === 'number') ? obj.scaleX : 1;
      const objScaleY = (obj && typeof obj.scaleY === 'number') ? obj.scaleY : 1;
      // Use the same base dimension logic as drawRotatedImage to support Canvas-backed images
      const baseW = (obj && obj.drawW != null)
        ? obj.drawW
        : ((obj && obj.img && (obj.img.naturalWidth || obj.img.width || obj.img.videoWidth)) || 0);
      const baseH = (obj && obj.drawH != null)
        ? obj.drawH
        : ((obj && obj.img && (obj.img.naturalHeight || obj.img.height || obj.img.videoHeight)) || 0);
      const w = baseW * (obj.scale || 1) * objScaleX;
      const h = baseH * (obj.scale || 1) * objScaleY;
      const centerX = obj.x + w / 2;
      const centerY = obj.y + h / 2;
      const rotation = obj.rotation || 0;
      // Pivot (draggable center): stored in unrotated local space relative to top-left
      const pivotLocalX = (typeof obj.pivotLocalX === 'number') ? obj.pivotLocalX : (w / 2);
      const pivotLocalY = (typeof obj.pivotLocalY === 'number') ? obj.pivotLocalY : (h / 2);
      const dpx = pivotLocalX - (w / 2);
      const dpy = pivotLocalY - (h / 2);
      const pivotX = centerX + dpx * Math.cos(rotation) - dpy * Math.sin(rotation);
      const pivotY = centerY + dpx * Math.sin(rotation) + dpy * Math.cos(rotation);
      
      // Helper function to rotate a point around the center
      const rotatePoint = (px, py) => {
        const dx = px - centerX;
        const dy = py - centerY;
        return {
          x: centerX + dx * Math.cos(rotation) - dy * Math.sin(rotation),
          y: centerY + dx * Math.sin(rotation) + dy * Math.cos(rotation)
        };
      };
      
      // Calculate corner positions accounting for rotation
      const tl = rotatePoint(obj.x, obj.y);
      const tr = rotatePoint(obj.x + w, obj.y);
      const br = rotatePoint(obj.x + w, obj.y + h);
      const bl = rotatePoint(obj.x, obj.y + h);
      
      const corners = [
        { name: 'tl', cx: tl.x, cy: tl.y },
        { name: 'tr', cx: tr.x, cy: tr.y },
        { name: 'br', cx: br.x, cy: br.y },
        { name: 'bl', cx: bl.x, cy: bl.y },
      ];

      const topMid = {
        x: (tl.x + tr.x) / 2,
        y: (tl.y + tr.y) / 2
      };

      let dirX = topMid.x - pivotX;
      let dirY = topMid.y - pivotY;
      let dirLen = Math.hypot(dirX, dirY);
      if (dirLen < 1) {
        dirX = Math.cos(rotation - Math.PI / 2);
        dirY = Math.sin(rotation - Math.PI / 2);
        dirLen = Math.hypot(dirX, dirY);
      }
      const baseLen = dirLen;
      if (dirLen !== 0) {
        dirX /= dirLen;
        dirY /= dirLen;
      }

      const defaultDistance = baseLen + ROTATION_HANDLE_OFFSET;
      if (typeof obj.rotationHandleDistance !== 'number' || !Number.isFinite(obj.rotationHandleDistance)) {
        obj.rotationHandleDistance = defaultDistance;
      }
      const rotationHandleDistance = Math.max(0, obj.rotationHandleDistance);
      const rotationHandle = {
        x: pivotX + dirX * rotationHandleDistance,
        y: pivotY + dirY * rotationHandleDistance
      };

      return {
        width: w,
        height: h,
        center: { x: centerX, y: centerY },
        pivot: { x: pivotX, y: pivotY },
        pivotLocal: { x: pivotLocalX, y: pivotLocalY },
        rotation,
        corners,
        topMid,
        rotationHandle,
        rotationHandleDistance,
        direction: { x: dirX, y: dirY }
      };
    }

    function getResizeHandleAtPoint(obj, x, y) {
      const geometry = calculateSelectionHandleGeometry(obj);
      const { corners, rotationHandle, pivot } = geometry;

      // Use circular hit detection radius (more forgiving and works with rotation)
      const hitRadius = (HANDLE_SIZE + HANDLE_HIT_EXTRA) / 2;

      // Check pivot handle (draggable center)
      if (pivot && Number.isFinite(pivot.x) && Number.isFinite(pivot.y)) {
        const distanceToPivot = Math.sqrt(
          Math.pow(x - pivot.x, 2) + Math.pow(y - pivot.y, 2)
        );
        if (distanceToPivot <= hitRadius) {
          return 'pivot';
        }
      }

      // Check rotation handle (center-connected node)
      const rotationRadius = hitRadius;
      const distanceToRotationHandle = Math.sqrt(
        Math.pow(x - rotationHandle.x, 2) + Math.pow(y - rotationHandle.y, 2)
      );
      if (distanceToRotationHandle <= rotationRadius) {
        return 'rotation';
      }

      // Check resize handles (corners) using circular hit detection
      // This works reliably regardless of rotation angle
      for (const c of corners) {
        const distance = Math.sqrt(
          Math.pow(x - c.cx, 2) + Math.pow(y - c.cy, 2)
        );
        if (distance <= hitRadius) {
          return c.name;
        }
      }
      return '';
    }

    // Hit test for clicks inside the rotated bounds of the selected object
    function isPointInsideSelectedObject(obj, x, y) {
      if (!obj || !obj.img) return false;
      const objScaleX = (obj && typeof obj.scaleX === 'number') ? obj.scaleX : 1;
      const objScaleY = (obj && typeof obj.scaleY === 'number') ? obj.scaleY : 1;
      // Match drawRotatedImage/calculateSelectionHandleGeometry base dimension logic
      const baseW = (obj && obj.drawW != null)
        ? obj.drawW
        : ((obj && obj.img && (obj.img.naturalWidth || obj.img.width || obj.img.videoWidth)) || 0);
      const baseH = (obj && obj.drawH != null)
        ? obj.drawH
        : ((obj && obj.img && (obj.img.naturalHeight || obj.img.height || obj.img.videoHeight)) || 0);
      const w = baseW * (obj.scale || 1) * objScaleX;
      const h = baseH * (obj.scale || 1) * objScaleY;
      const centerX = obj.x + w / 2;
      const centerY = obj.y + h / 2;
      const rot = obj.rotation || 0;
      // Rotate point by -rot around center to map into unrotated space
      const dx = x - centerX;
      const dy = y - centerY;
      const cosR = Math.cos(-rot);
      const sinR = Math.sin(-rot);
      const localX = centerX + dx * cosR - dy * sinR;
      const localY = centerY + dx * sinR + dy * cosR;
      return (localX >= obj.x && localX <= obj.x + w && localY >= obj.y && localY <= obj.y + h);
    }

    function drawRotatedImage(ctx, obj, scaleX = 1, scaleY = 1, offsetX = 0, offsetY = 0) {
      const baseW = (obj && obj.drawW != null) ? obj.drawW : ((obj && obj.img && (obj.img.naturalWidth || obj.img.width || obj.img.videoWidth)) || 0);
      const baseH = (obj && obj.drawH != null) ? obj.drawH : ((obj && obj.img && (obj.img.naturalHeight || obj.img.height || obj.img.videoHeight)) || 0);
      const effScaleX = (obj && typeof obj.scaleX === 'number' ? obj.scaleX : 1) * scaleX;
      const effScaleY = (obj && typeof obj.scaleY === 'number' ? obj.scaleY : 1) * scaleY;
      const w = baseW * (obj.scale || 1) * effScaleX;
      const h = baseH * (obj.scale || 1) * effScaleY;
      const centerX = (obj.x + offsetX) + w / 2;
      const centerY = (obj.y + offsetY) + h / 2;
      const opacity = (obj && typeof obj.opacity === 'number') ? obj.opacity : 1;
      // Determine pivot in local-unrotated coords; default to center
      const pivotLocalX = (typeof obj.pivotLocalX === 'number') ? obj.pivotLocalX : (w / 2);
      const pivotLocalY = (typeof obj.pivotLocalY === 'number') ? obj.pivotLocalY : (h / 2);
      const dpx = pivotLocalX - (w / 2);
      const dpy = pivotLocalY - (h / 2);
      const rot = obj.rotation || 0;
      const pivotX = centerX + dpx * Math.cos(rot) - dpy * Math.sin(rot);
      const pivotY = centerY + dpx * Math.sin(rot) + dpy * Math.cos(rot);
      ctx.save();
      const baseAlpha = ctx.globalAlpha;
      ctx.globalAlpha = baseAlpha * opacity;
      const drawCore = (dx = 0, dy = 0) => {
        if (rot && rot !== 0) {
          ctx.translate(pivotX, pivotY);
          ctx.rotate(rot);
          ctx.drawImage(obj.img, -pivotLocalX + dx, -pivotLocalY + dy, w, h);
          ctx.rotate(-rot);
          ctx.translate(-pivotX, -pivotY);
        } else {
          ctx.drawImage(obj.img, obj.x + offsetX + dx, obj.y + offsetY + dy, w, h);
        }
      };
      drawCore(0, 0);
      ctx.restore();
    }

    // Magic Tool: Auto Inbetween
    function runAutoInbetween() {
      const prevIndex = currentFrame - 1;
      const nextIndex = currentFrame + 1;
      const hasPrev = prevIndex >= 0 && frameLayers[prevIndex] && frameLayers[prevIndex].length > 0;
      const hasNext = nextIndex < frameLayers.length && frameLayers[nextIndex] && frameLayers[nextIndex].length > 0;
      if (!hasPrev && !hasNext) {
        if (typeof showCopyPasteFeedback === 'function') showCopyPasteFeedback('No adjacent frames to inbetween');
        return;
      }
      saveState();
      const baseCanvas = canvases[currentFrame];
      const w = baseCanvas.width, h = baseCanvas.height;
      const mixCanvas = document.createElement('canvas');
      mixCanvas.width = w; mixCanvas.height = h;
      const mixCtx = mixCanvas.getContext('2d', { willReadFrequently: true });

      const renderFrameInto = (ctx, frameIdx, alpha = 1) => {
        if (frameIdx < 0 || frameIdx >= frameLayers.length) return;
        const layers = frameLayers[frameIdx] || [];
        ctx.save();
        for (const layer of layers) {
          if (!layer || !layer.visible) continue;
          ctx.globalAlpha = alpha * (layer.opacity != null ? layer.opacity : 1);
          ctx.drawImage(layer.canvas, 0, 0);
          if (Array.isArray(layer.images)) {
            for (const obj of layer.images) {
              drawRotatedImage(ctx, obj);
            }
          }
        }
        ctx.restore();
      };

      if (hasPrev && hasNext) {
        renderFrameInto(mixCtx, prevIndex, 0.5);
        renderFrameInto(mixCtx, nextIndex, 0.5);
      } else if (hasPrev) {
        renderFrameInto(mixCtx, prevIndex, 1);
      } else if (hasNext) {
        renderFrameInto(mixCtx, nextIndex, 1);
      }

      const dataUrl = mixCanvas.toDataURL('image/png');
      const img = new Image();
      img.onload = () => {
        const layer = frameLayers[currentFrame][currentLayer];
        if (!Array.isArray(layer.images)) layer.images = [];
        layer.images.push({ img, src: dataUrl, x: 0, y: 0, scale: 1, rotation: 0 });
        composeLayers(currentFrame);
        updateThumbnail(currentFrame);
        if (typeof showCopyPasteFeedback === 'function') showCopyPasteFeedback('Auto Inbetween added to current layer');
        // Post snapshot for redo
        saveState();
      };
      img.src = dataUrl;
    }

    // Magic Tool: Mirror current frame horizontally
    function mirrorCurrentFrameHorizontally() {
      saveState();
      const baseCanvas = canvases[currentFrame];
      const w = baseCanvas.width, h = baseCanvas.height;
      const layers = frameLayers[currentFrame] || [];

      for (const layer of layers) {
        if (!layer) continue;
        // Flip raster pixels
        const tmp = document.createElement('canvas');
        tmp.width = w; tmp.height = h;
        const tctx = tmp.getContext('2d', { willReadFrequently: true });
        tctx.translate(w, 0);
        tctx.scale(-1, 1);
        tctx.drawImage(layer.canvas, 0, 0);
        layer.ctx.clearRect(0, 0, w, h);
        layer.ctx.drawImage(tmp, 0, 0);

        // Flip image objects
        if (Array.isArray(layer.images)) {
          for (const obj of layer.images) {
            const objScaleX = (obj && typeof obj.scaleX === 'number') ? obj.scaleX : 1;
            const drawW = obj.img.naturalWidth * obj.scale * objScaleX;
            // Mirror position horizontally
            obj.x = w - (obj.x + drawW);
            // Mirror rotation
            if (obj.rotation) obj.rotation = -obj.rotation;
          }
        }
      }

      composeLayers(currentFrame);
      updateThumbnail(currentFrame);
      if (typeof showCopyPasteFeedback === 'function') showCopyPasteFeedback('Mirrored current frame');
      saveState();
    }

    // Magic Tool: Between Frames (insert one between each pair, using first frame's first drawing at average position)
    function applyBetweenFrames() {
      if (!Array.isArray(frameLayers) || frameLayers.length < 2) {
        if (typeof showCopyPasteFeedback === 'function') showCopyPasteFeedback('Need at least 2 frames');
        return;
      }
      saveState();
      const removed = clearAllGeneratedInbetweens();
      const originalCount = frameLayers.length;
      const pairStarts = [];
      for (let i = 0; i + 1 < originalCount; i += 2) pairStarts.push(i);
      // Ensure composed canvases are current for bbox detection
      for (let i = 0; i < originalCount; i++) {
        if (typeof composeLayers === 'function') composeLayers(i);
      }
      // Build insertions first
      const inserts = [];
      for (const i of pairStarts) {
        const j = i + 1;
        const a = getPrimaryDrawingInfo(i);
        const b = getPrimaryDrawingInfo(j);
        if (!a || !b) continue; // skip if no drawings in either frame
        const avgX = (a.centerX + b.centerX) / 2;
        const avgY = (a.centerY + b.centerY) / 2;
        // Create image from first frame's drawing at averaged center
        const newImgInfo = a.type === 'image'
          ? { img: a.obj.img, src: a.obj.src, drawW: a.width, drawH: a.height, scale: a.obj.scale, rotation: a.obj.rotation || 0 }
          : createCroppedImageForFrame(i, a.bbox);
        if (!newImgInfo || !newImgInfo.img) continue;
        const placeX = Math.round(avgX - (newImgInfo.drawW || (newImgInfo.img.naturalWidth * (newImgInfo.scale || 1))) / 2);
        const placeY = Math.round(avgY - (newImgInfo.drawH || (newImgInfo.img.naturalHeight * (newImgInfo.scale || 1))) / 2);
        const newLayers = buildLayersForInbetween(i, a.layerIndex != null ? a.layerIndex : 0, newImgInfo, placeX, placeY);
        newLayers.__generatedInbetween = true;
        newLayers.__genTool = 'betweenFrames';
        inserts.push({ index: i + 1, layers: newLayers });
      }
      if (inserts.length === 0) {
        if (removed > 0) {
          rebuildCanvasGrid();
          updateTimelineDisplay();
          refreshAllFrameCanvases();
          if (typeof updateAllTimeScaleIndicators === 'function') updateAllTimeScaleIndicators();
        }
        if (typeof showCopyPasteFeedback === 'function') showCopyPasteFeedback('No drawings found to inbetween');
        return;
      }
      // Insert from back to front to preserve indices
      for (let k = inserts.length - 1; k >= 0; k--) {
        const ins = inserts[k];
        insertFrameWithLayersAt(ins.index, ins.layers, 1);
      }
      // Rebuild UI and update timing
      finalizeAfterGeneratedFramesChange();
    }

    // New Magic Frame Effects
    function renderFrameToCanvas(frameIdx, alpha = 1) {
      const baseCanvas = canvases[frameIdx];
      const w = baseCanvas.width, h = baseCanvas.height;
      const out = document.createElement('canvas');
      out.width = w; out.height = h;
      const ctx = out.getContext('2d', { willReadFrequently: true });
      ctx.fillStyle = '#1a1a1a';
      ctx.fillRect(0, 0, w, h);
      const layers = frameLayers[frameIdx] || [];
      ctx.save();
      for (const layer of layers) {
        if (!layer || !layer.visible) continue;
        ctx.globalAlpha = alpha * (layer.opacity != null ? layer.opacity : 1);
        ctx.drawImage(layer.canvas, 0, 0);
        if (Array.isArray(layer.images)) {
          for (const obj of layer.images) {
            drawRotatedImage(ctx, obj);
          }
        }
      }
      ctx.restore();
      return out;
    }

    function applyFrameBlendAcrossPairs() {
      if (!Array.isArray(frameLayers) || frameLayers.length < 2) {
        if (typeof showCopyPasteFeedback === 'function') showCopyPasteFeedback('Need at least 2 frames');
        return;
      }
      saveState();
      clearAllGeneratedInbetweens();
      const originalCount = frameLayers.length;
      const inserts = [];
      for (let i = 0; i + 1 < originalCount; i += 2) {
        const j = i + 1;
        const w = canvases[i].width, h = canvases[i].height;
        // Single blended in-between at 50/50
        const mix = document.createElement('canvas');
        mix.width = w; mix.height = h;
        const mctx = mix.getContext('2d', { willReadFrequently: true });
        const A = renderFrameToCanvas(i, 0.5);
        const B = renderFrameToCanvas(j, 0.5);
        mctx.drawImage(A, 0, 0);
        mctx.drawImage(B, 0, 0);
        const imgInfo = { img: mix, src: mix.toDataURL('image/png'), drawW: w, drawH: h, scale: 1, rotation: 0 };
        const newLayers = buildLayersForInbetween(i, 0, imgInfo, 0, 0);
        newLayers.__generatedInbetween = true;
        newLayers.__genTool = 'frameBlend';
        inserts.push({ index: j, layers: newLayers });
      }
      for (let k = inserts.length - 1; k >= 0; k--) {
        const ins = inserts[k];
        insertFrameWithLayersAt(ins.index, ins.layers, 1);
      }
      finalizeAfterGeneratedFramesChange();
    }

    function applySmearFrames() {
      if (!Array.isArray(frameLayers) || frameLayers.length < 2) {
        if (typeof showCopyPasteFeedback === 'function') showCopyPasteFeedback('Need at least 2 frames');
        return;
      }
      saveState();
      clearAllGeneratedInbetweens();
      const originalCount = frameLayers.length;
      // Ensure composed canvases for bbox
      for (let i = 0; i < originalCount; i++) {
        if (typeof composeLayers === 'function') composeLayers(i);
      }
      const inserts = [];
      for (let i = 0; i + 1 < originalCount; i += 2) {
        const j = i + 1;
        const a = getPrimaryDrawingInfo(i);
        const b = getPrimaryDrawingInfo(j);
        if (!a || !b) continue;
        const dx = b.centerX - a.centerX;
        const dy = b.centerY - a.centerY;
        const axTL = a.type === 'image' ? a.obj.x : a.bbox.minX;
        const ayTL = a.type === 'image' ? a.obj.y : a.bbox.minY;
        const srcInfo = a.type === 'image'
          ? { img: a.obj.img, drawW: a.width, drawH: a.height }
          : createCroppedImageForFrame(i, a.bbox);
        if (!srcInfo || !srcInfo.img) continue;
        const smearW = Math.max(1, Math.round((srcInfo.drawW || srcInfo.img.width) + Math.abs(dx) * 0.8));
        const smearH = Math.max(1, Math.round((srcInfo.drawH || srcInfo.img.height) + Math.abs(dy) * 0.8));
        const smear = document.createElement('canvas');
        smear.width = smearW; smear.height = smearH;
        const sctx = smear.getContext('2d', { willReadFrequently: true });
        const baseX = dx >= 0 ? 0 : Math.abs(dx);
        const baseY = dy >= 0 ? 0 : Math.abs(dy);
        const steps = 8;
        for (let s = 0; s < steps; s++) {
          const t = steps === 1 ? 0 : (s / (steps - 1));
          const ox = Math.round(dx * t);
          const oy = Math.round(dy * t);
          const alpha = Math.max(0.08, (1 - t) * 0.35);
          sctx.globalAlpha = alpha;
          const drawW = srcInfo.drawW || srcInfo.img.width;
          const drawH = srcInfo.drawH || srcInfo.img.height;
          sctx.drawImage(srcInfo.img, baseX + ox, baseY + oy, drawW, drawH);
        }
        const placeX = Math.round(dx < 0 ? axTL + dx : axTL);
        const placeY = Math.round(dy < 0 ? ayTL + dy : ayTL);
        const imgInfo = { img: smear, src: smear.toDataURL('image/png'), drawW: smearW, drawH: smearH, scale: 1, rotation: 0 };
        const newLayers = buildLayersForInbetween(i, a.layerIndex != null ? a.layerIndex : 0, imgInfo, placeX, placeY);
        newLayers.__generatedInbetween = true;
        newLayers.__genTool = 'smearFrames';
        inserts.push({ index: j, layers: newLayers });
      }
      for (let k = inserts.length - 1; k >= 0; k--) {
        const ins = inserts[k];
        insertFrameWithLayersAt(ins.index, ins.layers, 1);
      }
      rebuildCanvasGrid();
      updateTimelineDisplay();
      refreshAllFrameCanvases();
      if (typeof updateAllTimeScaleIndicators === 'function') updateAllTimeScaleIndicators();
    }

    function applyEchoTrail() {
      if (!Array.isArray(frameLayers) || frameLayers.length < 2) {
        if (typeof showCopyPasteFeedback === 'function') showCopyPasteFeedback('Need at least 2 frames');
        return;
      }
      saveState();
      // Ensure composed frames
      for (let i = 0; i < frameLayers.length; i++) {
        if (typeof composeLayers === 'function') composeLayers(i);
      }
      for (let i = 1; i < frameLayers.length; i++) {
        const currCentroid = computeFrameCentroid(i);
        const prevCentroid = computeFrameCentroid(i - 1);
        const dx = currCentroid.x - prevCentroid.x;
        const dy = currCentroid.y - prevCentroid.y;
        const maxTrails = Math.min(4, i);
        for (let n = 1; n <= maxTrails; n++) {
          const alpha = [0.55, 0.35, 0.22, 0.15][n - 1] || 0.12;
          const trail = renderFrameToCanvas(i - n, alpha);
          const layer = (frameLayers[i] && frameLayers[i][0]) ? frameLayers[i][0] : null;
          if (!layer) continue;
          if (!Array.isArray(layer.images)) layer.images = [];
          const offsetX = Math.round(-dx * n * 0.6);
          const offsetY = Math.round(-dy * n * 0.6);
          layer.images.push({ img: trail, src: '', x: offsetX, y: offsetY, scale: 1, rotation: 0 });
        }
        composeLayers(i);
        updateThumbnail(i);
      }
      if (typeof updateOnionSkin === 'function') updateOnionSkin();
      saveState();
    }

    function applyBounceEase() {
      if (!Array.isArray(frameLayers) || frameLayers.length < 2) {
        if (typeof showCopyPasteFeedback === 'function') showCopyPasteFeedback('Need at least 2 frames');
        return;
      }
      saveState();
      clearAllGeneratedInbetweens();
      // Ensure composed for bbox
      for (let i = 0; i < frameLayers.length; i++) {
        if (typeof composeLayers === 'function') composeLayers(i);
      }
      const inserts = [];
      const originalCount = frameLayers.length;
      for (let i = 0; i + 1 < originalCount; i += 2) {
        const j = i + 1;
        const a = getPrimaryDrawingInfo(i);
        const b = getPrimaryDrawingInfo(j);
        if (!a || !b) continue;
        const dx = b.centerX - a.centerX;
        const dy = b.centerY - a.centerY;
        const srcInfo = a.type === 'image'
          ? { img: a.obj.img, src: a.obj.src, drawW: a.width, drawH: a.height, scale: a.obj.scale || 1, rotation: a.obj.rotation || 0 }
          : createCroppedImageForFrame(i, a.bbox);
        if (!srcInfo || !srcInfo.img) continue;
        const w = srcInfo.drawW || (srcInfo.img.naturalWidth || srcInfo.img.width);
        const h = srcInfo.drawH || (srcInfo.img.naturalHeight || srcInfo.img.height);
        // Single eased midpoint (slight ease toward target)
        const midCx = a.centerX + dx * 0.6;
        const midCy = a.centerY + dy * 0.6;
        const px = Math.round(midCx - w / 2);
        const py = Math.round(midCy - h / 2);
        const layers = buildLayersForInbetween(i, a.layerIndex != null ? a.layerIndex : 0, srcInfo, px, py);
        layers.__generatedInbetween = true;
        layers.__genTool = 'bounceEase';
        inserts.push({ index: j, layers });
      }
      for (let k = inserts.length - 1; k >= 0; k--) {
        insertFrameWithLayersAt(inserts[k].index, inserts[k].layers, 1);
      }
      finalizeAfterGeneratedFramesChange();
    }

    function applySquashStretch() {
      if (!Array.isArray(frameLayers) || frameLayers.length < 2) {
        if (typeof showCopyPasteFeedback === 'function') showCopyPasteFeedback('Need at least 2 frames');
        return;
      }
      saveState();
      clearAllGeneratedInbetweens();
      // Ensure composed for bbox
      for (let i = 0; i < frameLayers.length; i++) {
        if (typeof composeLayers === 'function') composeLayers(i);
      }
      const inserts = [];
      const originalCount = frameLayers.length;
      const targetSize = getTargetCanvasSizeForViewport(currentViewport);
      const diag = Math.hypot(targetSize.width, targetSize.height);
      for (let i = 0; i + 1 < originalCount; i += 2) {
        const j = i + 1;
        const a = getPrimaryDrawingInfo(i);
        const b = getPrimaryDrawingInfo(j);
        if (!a || !b) continue;
        const dx = b.centerX - a.centerX;
        const dy = b.centerY - a.centerY;
        const speed = Math.hypot(dx, dy);
        // Squash-only: compress along motion axis, no expansion on the perpendicular axis
        const majorX = Math.abs(dx) >= Math.abs(dy);
        const amount = Math.min(0.6, Math.max(0.15, speed / (diag * 0.25))); // 0.15..0.6 squash amount
        const squashParallel = Math.max(0.35, 1 - amount); // prevent collapsing to zero
        const squashX = majorX ? squashParallel : 1.0;
        const squashY = majorX ? 1.0 : squashParallel;
        const srcInfo = a.type === 'image'
          ? { img: a.obj.img, src: a.obj.src, drawW: a.width, drawH: a.height, scale: a.obj.scale || 1, rotation: a.obj.rotation || 0 }
          : createCroppedImageForFrame(i, a.bbox);
        if (!srcInfo || !srcInfo.img) continue;
        const baseW = srcInfo.drawW || (srcInfo.img.naturalWidth || srcInfo.img.width);
        const baseH = srcInfo.drawH || (srcInfo.img.naturalHeight || srcInfo.img.height);
        const outW = Math.max(1, Math.round(baseW * squashX));
        const outH = Math.max(1, Math.round(baseH * squashY));
        const deform = document.createElement('canvas');
        deform.width = outW; deform.height = outH;
        const dctx = deform.getContext('2d', { willReadFrequently: true });
        dctx.save();
        dctx.scale(squashX, squashY);
        dctx.drawImage(srcInfo.img, 0, 0, baseW, baseH);
        dctx.restore();
        const midCx = (a.centerX + b.centerX) / 2;
        const midCy = (a.centerY + b.centerY) / 2;
        const px = Math.round(midCx - outW / 2);
        const py = Math.round(midCy - outH / 2);
        const imgInfo = { img: deform, src: deform.toDataURL('image/png'), drawW: outW, drawH: outH, scale: 1, rotation: 0 };
        const newLayers = buildLayersForInbetween(i, a.layerIndex != null ? a.layerIndex : 0, imgInfo, px, py);
        newLayers.__generatedInbetween = true;
        newLayers.__genTool = 'squashStretch';
        inserts.push({ index: j, layers: newLayers });
      }
      for (let k = inserts.length - 1; k >= 0; k--) {
        insertFrameWithLayersAt(inserts[k].index, inserts[k].layers, 1);
      }
      finalizeAfterGeneratedFramesChange();
    }

    function distortCanvasWithHeatHaze(srcCanvas, amplitudePx = 12, freq = 0.06, phase = 0) {
      const w = srcCanvas.width, h = srcCanvas.height;
      const out = document.createElement('canvas');
      out.width = w; out.height = h;
      const octx = out.getContext('2d', { willReadFrequently: true });
      octx.fillStyle = '#1a1a1a';
      octx.fillRect(0, 0, w, h);
      const sliceH = 2; // process in horizontal strips
      for (let y = 0; y < h; y += sliceH) {
        const offset = Math.sin((y * freq) + phase) * amplitudePx + Math.cos((y * freq * 0.7) - phase * 0.5) * (amplitudePx * 0.4);
        const sx = 0;
        const sy = y;
        const sw = w;
        const sh = Math.min(sliceH, h - y);
        const dx = Math.round(offset);
        const dy = y;
        // draw with wrap to avoid clipping on edges
        octx.drawImage(srcCanvas, sx, sy, sw, sh, dx, dy, sw, sh);
        if (dx > 0) {
          octx.drawImage(srcCanvas, sx + (sw - dx), sy, dx, sh, 0, dy, dx, sh);
        } else if (dx < 0) {
          const adx = -dx;
          octx.drawImage(srcCanvas, sx, sy, adx, sh, sw - adx, dy, adx, sh);
        }
      }
      return out;
    }

    function applyHeatHazeToFramesDramatic() {
      if (!Array.isArray(frameLayers) || frameLayers.length === 0) {
        if (typeof showCopyPasteFeedback === 'function') showCopyPasteFeedback('No frames to modify');
        return;
      }
      saveState();
      // Process each frame: composite, distort, then replace with a flattened layer
      for (let i = 0; i < frameLayers.length; i++) {
        const composite = renderFrameToCanvas(i, 1);
        const phase = (i * 1.133) % (Math.PI * 2);
        const amp = Math.max(6, Math.round(Math.min(composite.width, composite.height) * 0.02)) * 1.2; // dramatic
        const freq = 0.06 + (i % 3) * 0.01;
        const distorted = distortCanvasWithHeatHaze(composite, amp, freq, phase);
        const newCanvas = document.createElement('canvas');
        newCanvas.width = composite.width;
        newCanvas.height = composite.height;
        const newCtx = newCanvas.getContext('2d', { willReadFrequently: true });
        newCtx.fillStyle = '#1a1a1a';
        newCtx.fillRect(0, 0, newCanvas.width, newCanvas.height);
        newCtx.drawImage(distorted, 0, 0);
        // Replace frame with single flattened layer
        frameLayers[i] = [{
          canvas: newCanvas,
          ctx: newCtx,
          visible: true,
          name: 'Layer 1',
          opacity: 1,
          color: '#ffffff',
          images: []
        }];
        composeLayers(i);
        updateThumbnail(i);
      }
      if (typeof updateOnionSkin === 'function') updateOnionSkin();
      if (typeof updateAllTimeScaleIndicators === 'function') updateAllTimeScaleIndicators();
      saveState();
    }

    // Prefer first image object; fallback to raster bounding box of non-background pixels
    function getPrimaryDrawingInfo(frameIndex) {
      const layers = frameLayers[frameIndex] || [];
      for (let li = 0; li < layers.length; li++) {
        const layer = layers[li];
        if (layer && Array.isArray(layer.images) && layer.images.length > 0) {
          const obj = layer.images[0];
          const objScaleX = (obj && typeof obj.scaleX === 'number') ? obj.scaleX : 1;
          const objScaleY = (obj && typeof obj.scaleY === 'number') ? obj.scaleY : 1;
          const width = obj.img ? obj.img.naturalWidth * (obj.scale || 1) * objScaleX : 0;
          const height = obj.img ? obj.img.naturalHeight * (obj.scale || 1) * objScaleY : 0;
          return {
            type: 'image',
            obj,
            layerIndex: li,
            width,
            height,
            centerX: obj.x + width / 2,
            centerY: obj.y + height / 2
          };
        }
      }
      // Fallback to raster bbox on composed frame
      const bbox = computeFrameBoundingBoxNonBg(frameIndex);
      if (!bbox) return null;
      return {
        type: 'raster',
        layerIndex: 0,
        bbox,
        centerX: (bbox.minX + bbox.maxX) / 2,
        centerY: (bbox.minY + bbox.maxY) / 2,
        width: bbox.maxX - bbox.minX,
        height: bbox.maxY - bbox.minY
      };
    }

    function computeFrameBoundingBoxNonBg(frameIndex) {
      const baseCanvas = canvases[frameIndex];
      const ctx = contexts[frameIndex];
      const w = baseCanvas.width, h = baseCanvas.height;
      const img = ctx.getImageData(0, 0, w, h);
      const data = img.data;
      const bg = hexToRgb('#1a1a1a');
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          const idx = (y * w + x) * 4;
          const r = data[idx], g = data[idx + 1], b = data[idx + 2], a = data[idx + 3];
          const isBg = Math.abs(r - bg.r) < 10 && Math.abs(g - bg.g) < 10 && Math.abs(b - bg.b) < 10;
          if (!isBg && a > 0) {
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
          }
        }
      }
      if (!(isFinite(minX) && isFinite(minY) && isFinite(maxX) && isFinite(maxY))) return null;
      return { minX, minY, maxX: maxX + 1, maxY: maxY + 1 };
    }

    function createCroppedImageForFrame(frameIndex, bbox) {
      if (!bbox) return null;
      const baseCanvas = canvases[frameIndex];
      const w = bbox.maxX - bbox.minX;
      const h = bbox.maxY - bbox.minY;
      if (w <= 0 || h <= 0) return null;
      const crop = document.createElement('canvas');
      crop.width = w; crop.height = h;
      const cctx = crop.getContext('2d', { willReadFrequently: true });
      cctx.drawImage(baseCanvas, bbox.minX, bbox.minY, w, h, 0, 0, w, h);
      // Use the crop canvas directly as the image to avoid async loading
      const src = crop.toDataURL('image/png');
      return { img: crop, src, scale: 1, rotation: 0, drawW: w, drawH: h };
    }

    function buildLayersForInbetween(sourceFrameIndex, targetLayerIndex, imgInfo, x, y) {
      const target = getTargetCanvasSizeForViewport(currentViewport);
      const canvasWidth = target.width;
      const canvasHeight = target.height;
      const sourceLayers = frameLayers[sourceFrameIndex] || [];
      const newLayers = [];
      for (let li = 0; li < sourceLayers.length; li++) {
        const layer = sourceLayers[li];
        const newCanvas = document.createElement('canvas');
        newCanvas.width = canvasWidth;
        newCanvas.height = canvasHeight;
        const newCtx = newCanvas.getContext('2d', { willReadFrequently: true });
        newCtx.fillStyle = '#1a1a1a';
        newCtx.fillRect(0, 0, newCanvas.width, newCanvas.height);
        const images = [];
        if (li === targetLayerIndex) {
          images.push({
            img: imgInfo.img,
            src: imgInfo.src,
            x,
            y,
            scale: imgInfo.scale || 1,
            rotation: imgInfo.rotation || 0
          });
        }
        newLayers.push({
          canvas: newCanvas,
          ctx: newCtx,
          visible: layer ? layer.visible : true,
          name: layer ? layer.name : 'Layer 1',
          opacity: layer ? layer.opacity : 1,
          color: layer ? layer.color : '#ffffff',
          images
        });
      }
      if (newLayers.length === 0) {
        // Ensure at least one layer
        const nc = document.createElement('canvas');
        nc.width = canvasWidth; nc.height = canvasHeight;
        const nctx = nc.getContext('2d', { willReadFrequently: true });
        nctx.fillStyle = '#1a1a1a';
        nctx.fillRect(0, 0, nc.width, nc.height);
        newLayers.push({
          canvas: nc,
          ctx: nctx,
          visible: true,
          name: 'Layer 1',
          opacity: 1,
          color: '#ffffff',
          images: [{
            img: imgInfo.img, src: imgInfo.src, x, y, scale: imgInfo.scale || 1, rotation: imgInfo.rotation || 0
          }]
        });
      }
      return newLayers;
    }

    function insertFrameWithLayersAt(index, newLayers, duration = 1) {
      const dur = (typeof duration === 'number' && duration > 0) ? duration : 1;
      frameLayers.splice(index, 0, newLayers);
      frameDurations.splice(index, 0, dur);
      if (typeof updateTotalDuration === 'function') updateTotalDuration();
    }

    function finalizeAfterGeneratedFramesChange() {
      currentFrame = Math.max(0, Math.min(currentFrame, frameLayers.length - 1));
      rebuildCanvasGrid();
      updateTimelineDisplay();
      refreshAllFrameCanvases();
      if (typeof updateAllTimeScaleIndicators === 'function') updateAllTimeScaleIndicators();
      if (typeof selectFrame === 'function') selectFrame(currentFrame);
    }

    // Helpers for managing generated in-between frames
    function isGeneratedInbetweenFrame(layersArr) {
      return !!(layersArr && layersArr.__generatedInbetween === true);
    }
    function clearAllGeneratedInbetweens() {
      let removed = 0;
      for (let i = frameLayers.length - 1; i >= 0; i--) {
        const layersArr = frameLayers[i];
        if (isGeneratedInbetweenFrame(layersArr)) {
          frameLayers.splice(i, 1);
          frameDurations.splice(i, 1);
          removed++;
        }
      }
      if (removed > 0 && typeof updateTotalDuration === 'function') updateTotalDuration();
      return removed;
    }

    function computeFrameCentroid(frameIndex) {
      const baseCanvas = canvases[frameIndex];
      const ctx = contexts[frameIndex];
      const w = baseCanvas.width, h = baseCanvas.height;
      const img = ctx.getImageData(0, 0, w, h);
      const data = img.data;
      const bg = hexToRgb('#1a1a1a');
      let sumX = 0, sumY = 0, weight = 0;
      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          const idx = (y * w + x) * 4;
          const r = data[idx], g = data[idx + 1], b = data[idx + 2], a = data[idx + 3];
          const isBg = Math.abs(r - bg.r) < 10 && Math.abs(g - bg.g) < 10 && Math.abs(b - bg.b) < 10;
          if (!isBg && a > 0) {
            const wgt = a / 255;
            sumX += x * wgt;
            sumY += y * wgt;
            weight += wgt;
          }
        }
      }
      if (weight <= 0) return { x: w / 2, y: h / 2 };
      return { x: sumX / weight, y: sumY / weight };
    }

    function offsetCopyOfFrameLayers(sourceFrameIndex, dx, dy) {
      const target = getTargetCanvasSizeForViewport(currentViewport);
      const canvasWidth = target.width;
      const canvasHeight = target.height;
      const sourceLayers = frameLayers[sourceFrameIndex] || [];
      const newLayers = [];
      for (const layer of sourceLayers) {
        if (!layer) continue;
        const newCanvas = document.createElement('canvas');
        newCanvas.width = canvasWidth;
        newCanvas.height = canvasHeight;
        const newCtx = newCanvas.getContext('2d', { willReadFrequently: true });
        newCtx.fillStyle = '#1a1a1a';
        newCtx.fillRect(0, 0, newCanvas.width, newCanvas.height);
        if (layer.canvas) {
          newCtx.drawImage(layer.canvas, dx, dy);
        }
        let images = [];
        if (Array.isArray(layer.images)) {
          images = layer.images.map(obj => ({
            img: obj.img,
            src: obj.src,
            x: (obj.x || 0) + dx,
            y: (obj.y || 0) + dy,
            scale: obj.scale,
            rotation: obj.rotation || 0
          }));
        }
        newLayers.push({
          canvas: newCanvas,
          ctx: newCtx,
          visible: layer.visible,
          name: layer.name,
          opacity: layer.opacity,
          color: layer.color,
          images
        });
      }
      return newLayers;
    }

    function appendFrameWithLayers(newLayers, duration = 1) {
      const target = getTargetCanvasSizeForViewport(currentViewport);
      const canvasWidth = target.width;
      const canvasHeight = target.height;
      frameLayers.push([]);
      frameDurations.push(typeof duration === 'number' ? duration : 1);
      if (typeof updateTotalDuration === 'function') updateTotalDuration();
      const newFrameIndex = frameLayers.length - 1;
      frameLayers[newFrameIndex] = newLayers;

      const canvasGrid = document.querySelector('.canvas-grid');
      const addFrameContainer = canvasGrid.querySelector('.add-frame-container');
      const newFrameContainer = document.createElement('div');
      newFrameContainer.className = 'canvas-container';
      newFrameContainer.id = `frame-container-${newFrameIndex}`;
      const aspectRatio = currentViewport === 'phone' ? '9 / 16' : '16 / 9';
      newFrameContainer.style.setProperty('--canvas-aspect-ratio', aspectRatio);

      const frameLabel = document.createElement('div');
      frameLabel.className = 'frame-number';
      frameLabel.id = `frame-label-${newFrameIndex}`;
      frameLabel.textContent = `Frame ${newFrameIndex + 1} - ${newLayers[0] ? newLayers[0].name : 'Layer 1'}`;

      const canvas = document.createElement('canvas');
      canvas.id = `canvas-${newFrameIndex}`;
      canvas.width = canvasWidth;
      canvas.height = canvasHeight;
      canvas.style.width = '100%';
      canvas.style.height = '100%';
      canvas.style.display = 'block';
      canvas.style.objectFit = 'cover';

      const onionCanvas = document.createElement('canvas');
      onionCanvas.className = 'onion-skin';
      onionCanvas.id = `onion-${newFrameIndex}`;
      onionCanvas.width = canvasWidth;
      onionCanvas.height = canvasHeight;
      onionCanvas.style.width = '100%';
      onionCanvas.style.height = '100%';
      onionCanvas.style.display = 'block';
      onionCanvas.style.objectFit = 'cover';

      newFrameContainer.appendChild(frameLabel);
      newFrameContainer.appendChild(canvas);
      newFrameContainer.appendChild(onionCanvas);
      canvasGrid.insertBefore(newFrameContainer, addFrameContainer);

      const newCanvas = document.getElementById(`canvas-${newFrameIndex}`);
      const newCtx = newCanvas.getContext('2d', { willReadFrequently: true });
      newCtx.fillStyle = '#1a1a1a';
      newCtx.fillRect(0, 0, newCanvas.width, newCanvas.height);
      canvases.push(newCanvas);
      contexts.push(newCtx);
      newCanvas.addEventListener('mousedown', (e) => {
        const frameIndex = canvases.indexOf(e.target) !== -1 ? canvases.indexOf(e.target) : newFrameIndex;
        if (frameIndex !== currentFrame) {
          currentFrame = frameIndex;
          document.querySelectorAll('.canvas-container').forEach((el, i) => {
            el.classList.toggle('active', i === frameIndex);
          });
          document.querySelectorAll('.timeline-frame').forEach((el, i) => {
            el.classList.toggle('active', i === frameIndex);
          });
          document.getElementById('current-frame-info').textContent = frameIndex + 1;
          if (isDrawing) {
            const coords = getCanvasCoordinates(canvases[frameIndex], e.clientX, e.clientY);
            lastX = coords.x;
            lastY = coords.y;
            const layer = frameLayers[frameIndex][currentLayer];
            const ctx = layer.ctx;
            ctx.globalAlpha = brushOpacity;
            ctx.strokeStyle = currentColor;
            if (currentTool === 'pencil') {
              ctx.lineWidth = Math.max(1, brushSize / 2);
              ctx.lineCap = 'round';
              ctx.lineJoin = 'round';
              ctx.beginPath();
              ctx.arc(lastX, lastY, ctx.lineWidth / 2, 0, Math.PI * 2);
              ctx.fill();
            } else if (currentTool === 'brush') {
              drawWithBrushType(ctx, lastX, lastY, lastX, lastY);
            } else if (currentTool === 'eraser') {
              ctx.globalCompositeOperation = 'destination-out';
              ctx.lineWidth = brushSize;
              ctx.lineCap = 'round';
              ctx.lineJoin = 'round';
              ctx.beginPath();
              ctx.arc(lastX, lastY, brushSize / 2, 0, Math.PI * 2);
              ctx.fill();
              ctx.globalCompositeOperation = 'source-over';
            }
            ctx.globalAlpha = 1;
          } else {
            startDrawing(e);
          }
        } else {
          startDrawing(e);
        }
      });
      newCanvas.addEventListener('mouseup', stopDrawing);
      newCanvas.addEventListener('mouseleave', stopDrawing);
      newCanvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        const frameIndex = canvases.indexOf(e.target) !== -1 ? canvases.indexOf(e.target) : newFrameIndex;
        handleZoom(e, frameIndex);
      });
      newCanvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        const touch = e.touches[0];
        const mouseEvent = new MouseEvent('mousedown', {
          clientX: touch.clientX,
          clientY: touch.clientY
        });
        newCanvas.dispatchEvent(mouseEvent);
      });
      newCanvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        const touch = e.touches[0];
        const mouseEvent = new MouseEvent('mousemove', {
          clientX: touch.clientX,
          clientY: touch.clientY
        });
        document.dispatchEvent(mouseEvent);
      });
      newCanvas.addEventListener('touchend', (e) => {
        e.preventDefault();
        const mouseEvent = new MouseEvent('mouseup', {});
        newCanvas.dispatchEvent(mouseEvent);
      });
      newFrameContainer.addEventListener('dragover', (e) => { e.preventDefault(); });
      newFrameContainer.addEventListener('dragenter', (e) => { e.preventDefault(); });
      newFrameContainer.addEventListener('dragleave', (e) => { e.preventDefault(); });
      newFrameContainer.addEventListener('drop', (e) => {
        e.preventDefault();
        const files = e.dataTransfer && e.dataTransfer.files ? e.dataTransfer.files : null;
        if (files && files.length) handleDroppedFiles(files, newFrameIndex, e.clientX, e.clientY);
      });

      const newOnionCanvas = document.getElementById(`onion-${newFrameIndex}`);
      const newOnionCtx = newOnionCanvas.getContext('2d');
      onionCanvases.push(newOnionCanvas);
      onionContexts.push(newOnionCtx);

      updateTimelineDisplay();
      initializeCanvases();
      composeLayers(newFrameIndex);
      updateThumbnail(newFrameIndex);
      setupTimelineFrameEvents();
      if (typeof updateAllTimeScaleIndicators === 'function') {
        updateAllTimeScaleIndicators();
      }
    }

    function drawResizeHandles(ctx, obj) {
      const geometry = calculateSelectionHandleGeometry(obj);
      const { corners, center, pivot, rotationHandle } = geometry;
      const cornerRadius = Math.max(8, HANDLE_SIZE * 0.45);
      const centerRadius = Math.max(12, HANDLE_SIZE * 0.55);
      const rotationRadius = Math.max(8, HANDLE_SIZE * 0.45);
      const strokeColor = '#3b82f6';
      const defaultFill = '#ffffff';
      
      ctx.save();
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';

      // Draw white lines connecting corner nodes
      if (corners.length) {
        ctx.setLineDash([]);
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
        ctx.lineWidth = 3.5;
        ctx.beginPath();
        ctx.moveTo(corners[0].cx, corners[0].cy);
        for (let i = 1; i < corners.length; i++) {
          ctx.lineTo(corners[i].cx, corners[i].cy);
        }
        ctx.closePath();
        ctx.stroke();
      }

      // Draw solid white connector from center node to rotation node (like corner lines)
      ctx.setLineDash([]);
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
      ctx.lineWidth = 3.5;
      ctx.beginPath();
      ctx.moveTo(pivot.x, pivot.y);
      ctx.lineTo(rotationHandle.x, rotationHandle.y);
      ctx.stroke();

      // Draw a dotted circle at the radius from center to rotation node
      const circleRadius = Math.hypot(rotationHandle.x - pivot.x, rotationHandle.y - pivot.y);
      ctx.strokeStyle = '#9ca3af';
      ctx.lineWidth = 3.5;
      ctx.setLineDash([6, 6]);
      ctx.beginPath();
      ctx.arc(pivot.x, pivot.y, circleRadius, 0, Math.PI * 2);
      ctx.stroke();
      ctx.setLineDash([]);

      const drawCircleNode = (x, y, radius, isActive, fillColor = defaultFill) => {
        ctx.save();
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fillStyle = isActive ? '#3b82f6' : fillColor;
        ctx.fill();
        ctx.lineWidth = 3;
        ctx.strokeStyle = strokeColor;
        ctx.stroke();
        ctx.restore();
      };

      // Draw corner handles
      corners.forEach(c => {
        drawCircleNode(c.cx, c.cy, cornerRadius, activeTransformHandle === c.name);
      });

      // Draw center node
      drawCircleNode(pivot.x, pivot.y, centerRadius, activeTransformHandle === 'pivot', defaultFill);

      // Draw rotation node
      drawCircleNode(rotationHandle.x, rotationHandle.y, rotationRadius, activeTransformHandle === 'rotation');
      ctx.restore();
    }

    function beginImageDrag() {
      const canvas = canvases[currentFrame];
      const container = canvas.parentElement;
      // Overlay will render only the selected image and handles during interaction
      // Create overlay if needed
      if (moveOverlayCanvas) {
        moveOverlayCanvas.remove();
      }
      moveOverlayCanvas = document.createElement('canvas');
      moveOverlayCanvas.width = canvas.width;
      moveOverlayCanvas.height = canvas.height;
      moveOverlayCanvas.style.position = 'absolute';
      moveOverlayCanvas.style.top = '0';
      moveOverlayCanvas.style.left = '0';
      moveOverlayCanvas.style.width = '100%';
      moveOverlayCanvas.style.height = '100%';
      moveOverlayCanvas.style.objectFit = 'cover';
      moveOverlayCanvas.style.pointerEvents = 'none';
      moveOverlayCanvas.style.zIndex = '9';
      moveOverlayCtx = moveOverlayCanvas.getContext('2d');
      container.style.position = 'relative';
      container.appendChild(moveOverlayCanvas);
      // Ensure overlay exactly matches the base canvas transform at creation time
      try {
        const cs = window.getComputedStyle(canvas);
        moveOverlayCanvas.style.transformOrigin = cs.transformOrigin || 'top left';
        moveOverlayCanvas.style.transform = cs.transform || 'none';
      } catch (_e) {}
      // Immediately re-compose base canvas without the selected image so no shadow remains on first move
      try {
        composeLayers(currentFrame);
      } catch (_e) {}
      // Initial draw with current position
      renderImageDrag(selectedImageObject.x, selectedImageObject.y);
    }

    function renderImageDrag(x, y) {
      dragRafX = x; dragRafY = y;
      if (!dragRafScheduled) {
        dragRafScheduled = true;
        requestAnimationFrame(() => {
          dragRafScheduled = false;
          if (!moveOverlayCtx || !selectedImageObject) return;
          moveOverlayCtx.clearRect(0, 0, moveOverlayCanvas.width, moveOverlayCanvas.height);
          moveOverlayCtx.imageSmoothingEnabled = true;
          moveOverlayCtx.imageSmoothingQuality = 'high';
          drawRotatedImage(moveOverlayCtx, { ...selectedImageObject, x: dragRafX, y: dragRafY });
          // Draw resize handles only for Select tool
          if (currentTool === 'select') {
            drawResizeHandles(moveOverlayCtx, { ...selectedImageObject, x: dragRafX, y: dragRafY });
          }
        });
      }
    }

    function endImageDrag() {
      // If we still have a selected image, keep an overlay with handles visible
      if (selectedImageObject) {
        // Keep overlay visible with handles; draw only the selected image on overlay
        const canvas = canvases[currentFrame];
        const container = canvas.parentElement;
        
        // Ensure overlay canvas exists and is properly initialized
        if (!moveOverlayCanvas || !moveOverlayCanvas.parentElement) {
          if (moveOverlayCanvas) {
            moveOverlayCanvas.remove();
          }
          moveOverlayCanvas = document.createElement('canvas');
          moveOverlayCanvas.width = canvas.width;
          moveOverlayCanvas.height = canvas.height;
          moveOverlayCanvas.style.position = 'absolute';
          moveOverlayCanvas.style.top = '0';
          moveOverlayCanvas.style.left = '0';
          moveOverlayCanvas.style.width = '100%';
          moveOverlayCanvas.style.height = '100%';
          moveOverlayCanvas.style.objectFit = 'cover';
          moveOverlayCanvas.style.pointerEvents = 'none';
          moveOverlayCanvas.style.zIndex = '9';
          moveOverlayCtx = moveOverlayCanvas.getContext('2d');
          container.style.position = 'relative';
          container.appendChild(moveOverlayCanvas);
        }
        // Re-sync overlay transform with base canvas to prevent any perceived zoom change on selection
        try {
          const cs = window.getComputedStyle(canvas);
          moveOverlayCanvas.style.transformOrigin = cs.transformOrigin || 'top left';
          moveOverlayCanvas.style.transform = cs.transform || 'none';
        } catch (_e) {}
        
        // Force immediate render with current state
        refreshSelectionOverlay();
      } else {
        // Clear everything when no selection
        if (moveOverlayCanvas) {
          moveOverlayCanvas.remove();
          moveOverlayCanvas = null;
          moveOverlayCtx = null;
        }
        dragBaseCanvas = null;
        dragBaseCtx = null;
      }
    }

    function hexToRgb(hex) {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
      } : { r: 255, g: 255, b: 255 };
    }

    function updateThumbnail(index) {
      const thumbCtx = thumbContexts[index];
      thumbCtx.clearRect(0, 0, 60, 60);
      fillCheckerboard(thumbCtx, 60, 60);
      const tempCanvas = document.createElement('canvas');
      const baseCanvas = canvases[index];
      tempCanvas.width = baseCanvas.width;
      tempCanvas.height = baseCanvas.height;
      const tempCtx = tempCanvas.getContext('2d');
      
      frameLayers[index].forEach(layer => {
        if (layer.visible) {
          tempCtx.save();
          tempCtx.globalAlpha = layer.opacity;
          tempCtx.drawImage(layer.canvas, 0, 0);
          if (Array.isArray(layer.images)) {
            for (const obj of layer.images) {
              tempCtx.imageSmoothingEnabled = true;
              tempCtx.imageSmoothingQuality = 'high';
              drawRotatedImage(tempCtx, obj);
            }
          }
          tempCtx.restore();
        }
      });
      thumbCtx.drawImage(tempCanvas, 0, 0, tempCanvas.width, tempCanvas.height, 0, 0, 60, 60);
      
    }

    function clearCurrentFrame() {
      saveState();
      if (isCutOutMode) {
        // Clear active cutout clip or the cutout canvas
        const idx = getActiveCutoutClipIndexAt(cutoutCurrentTime);
        if (idx >= 0 && cutoutClips[idx] && cutoutClips[idx].ctx) {
          const clip = cutoutClips[idx];
          clip.ctx.clearRect(0, 0, clip.canvas.width, clip.canvas.height);
        } else if (cutoutCtx && cutoutCanvas) {
          cutoutCtx.clearRect(0, 0, cutoutCanvas.width, cutoutCanvas.height);
        }
        // Clear selection overlay if any
        if (typeof cutoutSelectedObject !== 'undefined' && cutoutSelectedObject) {
          try { cutoutCommitSelection(); } catch (_e) { /* ignore */ }
          cutoutSelectedObject = null;
        }
        renderCutoutPreviewForTime();
        drawCutoutTimeline();
      } else {
        const layer = frameLayers[currentFrame][currentLayer];
        layer.ctx.clearRect(0, 0, layer.canvas.width, layer.canvas.height);
        if (Array.isArray(layer.images)) layer.images = [];
        composeLayers();
        updateThumbnail(currentFrame);
        updateOnionSkin();
      }
    }

    function duplicateFrame() {
      if (currentFrame < frameLayers.length - 1) {
        saveState();
        const nextFrame = currentFrame + 1;
        
        frameLayers[nextFrame] = frameLayers[currentFrame].map(layer => {
          const newCanvas = document.createElement('canvas');
          newCanvas.width = layer.canvas.width; // Use current canvas dimensions
          newCanvas.height = layer.canvas.height; // Use current canvas dimensions
          const newCtx = newCanvas.getContext('2d', { willReadFrequently: true });
          newCtx.drawImage(layer.canvas, 0, 0);
          
          const copied = {
            canvas: newCanvas,
            ctx: newCtx,
            visible: layer.visible,
            name: layer.name,
            opacity: layer.opacity,
            color: layer.color,
            images: []
          };
          if (Array.isArray(layer.images)) {
            copied.images = layer.images.map(obj => {
              const img = new Image();
              img.src = obj.src;
              return { 
                img, 
                src: obj.src, 
                x: obj.x, 
                y: obj.y, 
                scale: obj.scale, 
                scaleX: (typeof obj.scaleX === 'number') ? obj.scaleX : 1,
                scaleY: (typeof obj.scaleY === 'number') ? obj.scaleY : 1,
                rotation: obj.rotation || 0,
                pivotLocalX: (typeof obj.pivotLocalX === 'number') ? obj.pivotLocalX : undefined,
                pivotLocalY: (typeof obj.pivotLocalY === 'number') ? obj.pivotLocalY : undefined,
                rotationHandleDistance: (typeof obj.rotationHandleDistance === 'number') ? obj.rotationHandleDistance : undefined
              };
            });
          }
          return copied;
        });
        
        composeLayers();
        updateThumbnail(nextFrame);
        selectFrame(nextFrame);
      }
    }

    function addNewFrame() {
      console.log('addNewFrame function called');
      saveState();
      
      // Get current viewport dimensions first
      const target = getTargetCanvasSizeForViewport(currentViewport);
      const canvasWidth = target.width;
      const canvasHeight = target.height;
      
      // Add new frame to arrays
      frameLayers.push([]);
      frameDurations.push(1);
      // Immediately update total duration display
      if (typeof updateTotalDuration === 'function') {
        updateTotalDuration();
      }
      
      const newFrameIndex = frameLayers.length - 1;
      
      // Create a new layer for the new frame (copy structure from current frame)
      if (frameLayers[currentFrame].length > 0) {
        // Copy layer structure from current frame
        frameLayers[newFrameIndex] = frameLayers[currentFrame].map(layer => {
          const newCanvas = document.createElement('canvas');
          newCanvas.width = canvasWidth;
          newCanvas.height = canvasHeight;
          const newCtx = newCanvas.getContext('2d', { willReadFrequently: true });
          // Start with empty canvas for new frame
          
          return {
            canvas: newCanvas,
            ctx: newCtx,
            visible: layer.visible,
            name: layer.name,
            opacity: layer.opacity,
            color: layer.color,
            images: []
          };
        });
      } else {
        // Create a default layer if no layers exist
        const newCanvas = document.createElement('canvas');
        newCanvas.width = canvasWidth;
        newCanvas.height = canvasHeight;
        const newCtx = newCanvas.getContext('2d', { willReadFrequently: true });
        
        frameLayers[newFrameIndex].push({
          canvas: newCanvas,
          ctx: newCtx,
          visible: true,
          name: 'Layer 1',
          opacity: 1,
          color: '#ffffff',
          images: []
        });
      }
      
      // Create the new frame container in the canvas grid
      const canvasGrid = document.querySelector('.canvas-grid');
      const addFrameContainer = canvasGrid.querySelector('.add-frame-container');
      
      // Create new frame container
      const newFrameContainer = document.createElement('div');
      newFrameContainer.className = 'canvas-container';
      newFrameContainer.id = `frame-container-${newFrameIndex}`;
      
      // Set the correct aspect ratio based on current viewport
      const aspectRatio = currentViewport === 'phone' ? '9 / 16' : '16 / 9';
      newFrameContainer.style.setProperty('--canvas-aspect-ratio', aspectRatio);
      
      const frameLabel = document.createElement('div');
      frameLabel.className = 'frame-number';
      frameLabel.id = `frame-label-${newFrameIndex}`;
      frameLabel.textContent = `Frame ${newFrameIndex + 1} - Layer 1`;
      
      const canvas = document.createElement('canvas');
      canvas.id = `canvas-${newFrameIndex}`;
      canvas.width = canvasWidth;
      canvas.height = canvasHeight;
      canvas.style.width = '100%';
      canvas.style.height = '100%';
      canvas.style.display = 'block';
      canvas.style.objectFit = 'cover';
      
      const onionCanvas = document.createElement('canvas');
      onionCanvas.className = 'onion-skin';
      onionCanvas.id = `onion-${newFrameIndex}`;
      onionCanvas.width = canvasWidth;
      onionCanvas.height = canvasHeight;
      onionCanvas.style.width = '100%';
      onionCanvas.style.height = '100%';
      onionCanvas.style.display = 'block';
      onionCanvas.style.objectFit = 'cover';
      
      newFrameContainer.appendChild(frameLabel);
      newFrameContainer.appendChild(canvas);
      newFrameContainer.appendChild(onionCanvas);
      
      // Insert the new frame before the add frame button
      canvasGrid.insertBefore(newFrameContainer, addFrameContainer);
      // Enable drag & drop on the new frame container
      newFrameContainer.addEventListener('dragover', (e) => { e.preventDefault(); });
      newFrameContainer.addEventListener('dragenter', (e) => { e.preventDefault(); });
      newFrameContainer.addEventListener('dragleave', (e) => { e.preventDefault(); });
      newFrameContainer.addEventListener('drop', (e) => {
        e.preventDefault();
        const files = e.dataTransfer && e.dataTransfer.files ? e.dataTransfer.files : null;
        if (files && files.length) {
          handleDroppedFiles(files, newFrameIndex, e.clientX, e.clientY);
        }
      });
      
      // Initialize the new canvas immediately
      const newCanvas = document.getElementById(`canvas-${newFrameIndex}`);
      const newCtx = newCanvas.getContext('2d', { willReadFrequently: true });
      newCtx.fillStyle = '#1a1a1a';
      newCtx.fillRect(0, 0, newCanvas.width, newCanvas.height);
      // Attach interaction handlers so the new frame is drawable/selectable like existing ones
      newCanvas.addEventListener('mousedown', (e) => {
        const frameIndex = canvases.indexOf(e.target) !== -1 ? canvases.indexOf(e.target) : newFrameIndex;
        if (frameIndex !== currentFrame) {
          // Switch frame instantly
          currentFrame = frameIndex;
          document.querySelectorAll('.canvas-container').forEach((el, i) => {
            el.classList.toggle('active', i === frameIndex);
          });
          document.querySelectorAll('.timeline-frame').forEach((el, i) => {
            el.classList.toggle('active', i === frameIndex);
          });
          document.getElementById('current-frame-info').textContent = frameIndex + 1;
          
          // Continue drawing seamlessly on the new frame
          if (isDrawing) {
            const coords = getCanvasCoordinates(canvases[frameIndex], e.clientX, e.clientY);
            lastX = coords.x;
            lastY = coords.y;
            const layer = frameLayers[frameIndex][currentLayer];
            const ctx = layer.ctx;
            ctx.globalAlpha = brushOpacity;
            ctx.strokeStyle = currentColor;
            if (currentTool === 'pencil') {
              ctx.lineWidth = Math.max(1, brushSize / 2);
              ctx.lineCap = 'round';
              ctx.lineJoin = 'round';
              ctx.beginPath();
              ctx.arc(lastX, lastY, ctx.lineWidth / 2, 0, Math.PI * 2);
              ctx.fill();
            } else if (currentTool === 'brush') {
              drawWithBrushType(ctx, lastX, lastY, lastX, lastY);
            } else if (currentTool === 'eraser') {
              ctx.globalCompositeOperation = 'destination-out';
              ctx.lineWidth = brushSize;
              ctx.lineCap = 'round';
              ctx.lineJoin = 'round';
              ctx.beginPath();
              ctx.arc(lastX, lastY, brushSize / 2, 0, Math.PI * 2);
              ctx.fill();
              ctx.globalCompositeOperation = 'source-over';
            }
            ctx.globalAlpha = 1;
          } else {
            startDrawing(e);
          }
        } else {
          startDrawing(e);
        }
      });
      newCanvas.addEventListener('mouseup', stopDrawing);
      newCanvas.addEventListener('mouseleave', stopDrawing);
      newCanvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        const frameIndex = canvases.indexOf(e.target) !== -1 ? canvases.indexOf(e.target) : newFrameIndex;
        handleZoom(e, frameIndex);
      });
      newCanvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        const touch = e.touches[0];
        const mouseEvent = new MouseEvent('mousedown', {
          clientX: touch.clientX,
          clientY: touch.clientY
        });
        newCanvas.dispatchEvent(mouseEvent);
      });
      newCanvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        const touch = e.touches[0];
        const mouseEvent = new MouseEvent('mousemove', {
          clientX: touch.clientX,
          clientY: touch.clientY
        });
        document.dispatchEvent(mouseEvent);
      });
      newCanvas.addEventListener('touchend', (e) => {
        e.preventDefault();
        const mouseEvent = new MouseEvent('mouseup', {});
        newCanvas.dispatchEvent(mouseEvent);
      });
      
      // Add to canvas arrays
      canvases.push(newCanvas);
      contexts.push(newCtx);
      
      // Initialize onion canvas
      const newOnionCanvas = document.getElementById(`onion-${newFrameIndex}`);
      const newOnionCtx = newOnionCanvas.getContext('2d');
      onionCanvases.push(newOnionCanvas);
      onionContexts.push(newOnionCtx);
      
      // Update timeline
      updateTimelineDisplay();
      // Rebuild canvas/thumb references to match new DOM so thumbnails and interactions work
      initializeCanvases();
      
      // Select the new frame
      selectFrame(newFrameIndex);
      
      // Reinitialize event system for new frames
      setupTimelineFrameEvents();
      
      // Recalculate timeline ruler and total duration (adds +0.1s per new frame at 10 FPS)
      if (typeof updateAllTimeScaleIndicators === 'function') {
        updateAllTimeScaleIndicators();
      }
    }

      function deleteCurrentFrame() {
        deleteFrameAt(currentFrame);
      }

      function deleteFrameAt(index) {
        if (frameLayers.length <= 1) {
          alert('You must have at least one frame.');
          return;
        }
        saveState();
        // Remove data
        frameLayers.splice(index, 1);
        frameDurations.splice(index, 1);
        // Adjust current frame
        const newIndex = Math.max(0, Math.min(index, frameLayers.length - 1));
        currentFrame = newIndex;
        currentLayer = Math.min(currentLayer, Math.max(0, (frameLayers[currentFrame]?.length || 1) - 1));
        // Rebuild UI
        rebuildCanvasGrid();
        updateTimelineDisplay();
        // Select new current frame and refresh
        selectFrame(currentFrame);
        setupTimelineFrameEvents();
        // Recalculate timeline ruler and total duration after deletion
        if (typeof updateAllTimeScaleIndicators === 'function') {
          updateAllTimeScaleIndicators();
        }
      }

      function rebuildCanvasGrid() {
        const canvasGrid = document.querySelector('.canvas-grid');
        if (!canvasGrid) return;
        const addFrameContainer = canvasGrid.querySelector('.add-frame-container');
        // Remove all existing frame containers (keep add-frame)
        canvasGrid.querySelectorAll('.canvas-container').forEach(el => {
          if (!el.classList.contains('add-frame-container')) el.remove();
        });
        // Create containers for each frame
        const target = getTargetCanvasSizeForViewport(currentViewport);
        const aspectRatio = currentViewport === 'phone' ? '9 / 16' : '16 / 9';
        for (let i = 0; i < frameLayers.length; i++) {
          const container = document.createElement('div');
          container.className = `canvas-container${i === currentFrame ? ' active' : ''}`;
          container.id = `frame-container-${i}`;
          container.style.setProperty('--canvas-aspect-ratio', aspectRatio);
          // Label
          const label = document.createElement('div');
          label.className = 'frame-number';
          label.id = `frame-label-${i}`;
          const firstLayer = frameLayers[i][0];
          label.textContent = `Frame ${i + 1} - ${firstLayer ? firstLayer.name : 'Layer 1'}`;
          // Canvas
          const canvas = document.createElement('canvas');
          canvas.id = `canvas-${i}`;
          canvas.width = target.width;
          canvas.height = target.height;
          canvas.style.width = '100%';
          canvas.style.height = '100%';
          canvas.style.display = 'block';
          canvas.style.objectFit = 'cover';
          // Onion skin overlay
          const onion = document.createElement('canvas');
          onion.className = 'onion-skin';
          onion.id = `onion-${i}`;
          onion.width = target.width;
          onion.height = target.height;
          onion.style.width = '100%';
          onion.style.height = '100%';
          onion.style.display = 'block';
          onion.style.objectFit = 'cover';
          // Assemble
          container.appendChild(label);
          container.appendChild(canvas);
          container.appendChild(onion);
          canvasGrid.insertBefore(container, addFrameContainer);
          // Attach canvas interaction listeners (match addNewFrame/appendFrameFromSourceFrame behavior)
          canvas.addEventListener('mousedown', (e) => {
            const frameIndex = canvases.indexOf(e.target) !== -1 ? canvases.indexOf(e.target) : i;
            if (frameIndex !== currentFrame) {
              currentFrame = frameIndex;
              document.querySelectorAll('.canvas-container').forEach((el, idx) => {
                el.classList.toggle('active', idx === frameIndex);
              });
              document.querySelectorAll('.timeline-frame').forEach((el, idx) => {
                el.classList.toggle('active', idx === frameIndex);
              });
              const infoEl = document.getElementById('current-frame-info');
              if (infoEl) infoEl.textContent = frameIndex + 1;
              if (isDrawing) {
                const coords = getCanvasCoordinates(canvases[frameIndex] || canvas, e.clientX, e.clientY);
                lastX = coords.x;
                lastY = coords.y;
                const layer = frameLayers[frameIndex][currentLayer];
                const ctx = layer.ctx;
                ctx.globalAlpha = brushOpacity;
                ctx.strokeStyle = currentColor;
                if (currentTool === 'pencil') {
                  ctx.lineWidth = Math.max(1, brushSize / 2);
                  ctx.lineCap = 'round';
                  ctx.lineJoin = 'round';
                  ctx.beginPath();
                  ctx.arc(lastX, lastY, ctx.lineWidth / 2, 0, Math.PI * 2);
                  ctx.fill();
                } else if (currentTool === 'brush') {
                  drawWithBrushType(ctx, lastX, lastY, lastX, lastY);
                } else if (currentTool === 'eraser') {
                  ctx.globalCompositeOperation = 'destination-out';
                  ctx.lineWidth = brushSize;
                  ctx.lineCap = 'round';
                  ctx.lineJoin = 'round';
                  ctx.beginPath();
                  ctx.arc(lastX, lastY, brushSize / 2, 0, Math.PI * 2);
                  ctx.fill();
                  ctx.globalCompositeOperation = 'source-over';
                }
                ctx.globalAlpha = 1;
              } else {
                startDrawing(e);
              }
            } else {
              startDrawing(e);
            }
          });
          canvas.addEventListener('mouseup', stopDrawing);
          canvas.addEventListener('mouseleave', stopDrawing);
          canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const frameIndex = canvases.indexOf(e.target) !== -1 ? canvases.indexOf(e.target) : i;
            handleZoom(e, frameIndex);
          });
          canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousedown', {
              clientX: touch.clientX,
              clientY: touch.clientY
            });
            canvas.dispatchEvent(mouseEvent);
          });
          canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousemove', {
              clientX: touch.clientX,
              clientY: touch.clientY
            });
            document.dispatchEvent(mouseEvent);
          });
          canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            const mouseEvent = new MouseEvent('mouseup', {});
            canvas.dispatchEvent(mouseEvent);
          });
          // DnD handlers
          container.addEventListener('dragover', (e) => { e.preventDefault(); });
          container.addEventListener('drop', (e) => {
            e.preventDefault();
            const files = e.dataTransfer && e.dataTransfer.files ? e.dataTransfer.files : null;
            if (files && files.length) handleDroppedFiles(files, i, e.clientX, e.clientY);
          });
        }
        // Re-init canvas references and redraw (async to ensure DOM is ready)
        refreshAllFrameCanvases();
        // refreshAllFrameCanvases already schedules redraw & label update
      }
    // Append a new frame at the end based on source frame layers and duration
    function appendFrameFromSourceFrame(sourceFrameLayers, sourceDuration) {
      // Determine canvas size by viewport
      const target = getTargetCanvasSizeForViewport(currentViewport);
      const canvasWidth = target.width;
      const canvasHeight = target.height;

      // Extend data arrays
      frameLayers.push([]);
      frameDurations.push(typeof sourceDuration === 'number' ? sourceDuration : 1);
      // Immediately update total duration
      if (typeof updateTotalDuration === 'function') {
        updateTotalDuration();
      }
      const newFrameIndex = frameLayers.length - 1;

      // Clone layers into new frame
      const newLayers = [];
      for (const layer of sourceFrameLayers) {
        const newCanvas = document.createElement('canvas');
        newCanvas.width = canvasWidth;
        newCanvas.height = canvasHeight;
        const newCtx = newCanvas.getContext('2d', { willReadFrequently: true });
        newCtx.imageSmoothingEnabled = true;
        newCtx.imageSmoothingQuality = 'high';
        // Draw source layer.canvas scaled to target size
        if (layer && layer.canvas) {
          newCtx.drawImage(layer.canvas, 0, 0, layer.canvas.width, layer.canvas.height, 0, 0, canvasWidth, canvasHeight);
        }
        newLayers.push({
          canvas: newCanvas,
          ctx: newCtx,
          visible: layer.visible,
          name: layer.name,
          opacity: layer.opacity,
          color: layer.color,
          images: Array.isArray(layer.images) ? layer.images.map(obj => ({ ...obj })) : []
        });
      }
      frameLayers[newFrameIndex] = newLayers;

      // Create DOM containers similar to addNewFrame
      const canvasGrid = document.querySelector('.canvas-grid');
      const addFrameContainer = canvasGrid.querySelector('.add-frame-container');
      const newFrameContainer = document.createElement('div');
      newFrameContainer.className = 'canvas-container';
      newFrameContainer.id = `frame-container-${newFrameIndex}`;
      const aspectRatio = currentViewport === 'phone' ? '9 / 16' : '16 / 9';
      newFrameContainer.style.setProperty('--canvas-aspect-ratio', aspectRatio);

      const frameLabel = document.createElement('div');
      frameLabel.className = 'frame-number';
      frameLabel.id = `frame-label-${newFrameIndex}`;
      frameLabel.textContent = `Frame ${newFrameIndex + 1} - ${newLayers[0] ? newLayers[0].name : 'Layer 1'}`;

      const canvas = document.createElement('canvas');
      canvas.id = `canvas-${newFrameIndex}`;
      canvas.width = canvasWidth;
      canvas.height = canvasHeight;
      canvas.style.width = '100%';
      canvas.style.height = '100%';
      canvas.style.display = 'block';
      canvas.style.objectFit = 'cover';

      const onionCanvas = document.createElement('canvas');
      onionCanvas.className = 'onion-skin';
      onionCanvas.id = `onion-${newFrameIndex}`;
      onionCanvas.width = canvasWidth;
      onionCanvas.height = canvasHeight;
      onionCanvas.style.width = '100%';
      onionCanvas.style.height = '100%';
      onionCanvas.style.display = 'block';
      onionCanvas.style.objectFit = 'cover';

      newFrameContainer.appendChild(frameLabel);
      newFrameContainer.appendChild(canvas);
      newFrameContainer.appendChild(onionCanvas);
      canvasGrid.insertBefore(newFrameContainer, addFrameContainer);

      // Initialize canvas contexts arrays
      const newCanvas = document.getElementById(`canvas-${newFrameIndex}`);
      const newCtx = newCanvas.getContext('2d', { willReadFrequently: true });
      newCtx.fillStyle = '#1a1a1a';
      newCtx.fillRect(0, 0, newCanvas.width, newCanvas.height);
      canvases.push(newCanvas);
      contexts.push(newCtx);
      // Interaction parity with existing frames
      newCanvas.addEventListener('mousedown', (e) => {
        const frameIndex = canvases.indexOf(e.target) !== -1 ? canvases.indexOf(e.target) : newFrameIndex;
        if (frameIndex !== currentFrame) {
          currentFrame = frameIndex;
          document.querySelectorAll('.canvas-container').forEach((el, i) => {
            el.classList.toggle('active', i === frameIndex);
          });
          document.querySelectorAll('.timeline-frame').forEach((el, i) => {
            el.classList.toggle('active', i === frameIndex);
          });
          document.getElementById('current-frame-info').textContent = frameIndex + 1;
          if (isDrawing) {
            const coords = getCanvasCoordinates(canvases[frameIndex], e.clientX, e.clientY);
            lastX = coords.x;
            lastY = coords.y;
            const layer = frameLayers[frameIndex][currentLayer];
            const ctx = layer.ctx;
            ctx.globalAlpha = brushOpacity;
            ctx.strokeStyle = currentColor;
            if (currentTool === 'pencil') {
              ctx.lineWidth = Math.max(1, brushSize / 2);
              ctx.lineCap = 'round';
              ctx.lineJoin = 'round';
              ctx.beginPath();
              ctx.arc(lastX, lastY, ctx.lineWidth / 2, 0, Math.PI * 2);
              ctx.fill();
            } else if (currentTool === 'brush') {
              drawWithBrushType(ctx, lastX, lastY, lastX, lastY);
            } else if (currentTool === 'eraser') {
              ctx.globalCompositeOperation = 'destination-out';
              ctx.lineWidth = brushSize;
              ctx.lineCap = 'round';
              ctx.lineJoin = 'round';
              ctx.beginPath();
              ctx.arc(lastX, lastY, brushSize / 2, 0, Math.PI * 2);
              ctx.fill();
              ctx.globalCompositeOperation = 'source-over';
            }
            ctx.globalAlpha = 1;
          } else {
            startDrawing(e);
          }
        } else {
          startDrawing(e);
        }
      });
      newCanvas.addEventListener('mouseup', stopDrawing);
      newCanvas.addEventListener('mouseleave', stopDrawing);
      newCanvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        const frameIndex = canvases.indexOf(e.target) !== -1 ? canvases.indexOf(e.target) : newFrameIndex;
        handleZoom(e, frameIndex);
      });
      newCanvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        const touch = e.touches[0];
        const mouseEvent = new MouseEvent('mousedown', {
          clientX: touch.clientX,
          clientY: touch.clientY
        });
        newCanvas.dispatchEvent(mouseEvent);
      });
      newCanvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        const touch = e.touches[0];
        const mouseEvent = new MouseEvent('mousemove', {
          clientX: touch.clientX,
          clientY: touch.clientY
        });
        document.dispatchEvent(mouseEvent);
      });
      newCanvas.addEventListener('touchend', (e) => {
        e.preventDefault();
        const mouseEvent = new MouseEvent('mouseup', {});
        newCanvas.dispatchEvent(mouseEvent);
      });
      // DnD on container
      newFrameContainer.addEventListener('dragover', (e) => { e.preventDefault(); });
      newFrameContainer.addEventListener('dragenter', (e) => { e.preventDefault(); });
      newFrameContainer.addEventListener('dragleave', (e) => { e.preventDefault(); });
      newFrameContainer.addEventListener('drop', (e) => {
        e.preventDefault();
        const files = e.dataTransfer && e.dataTransfer.files ? e.dataTransfer.files : null;
        if (files && files.length) handleDroppedFiles(files, newFrameIndex, e.clientX, e.clientY);
      });

      const newOnionCanvas = document.getElementById(`onion-${newFrameIndex}`);
      const newOnionCtx = newOnionCanvas.getContext('2d');
      onionCanvases.push(newOnionCanvas);
      onionContexts.push(newOnionCtx);

      // Update timeline and thumbnail
      updateTimelineDisplay();
      initializeCanvases();
      composeLayers(newFrameIndex);
      updateThumbnail(newFrameIndex);
      setupTimelineFrameEvents();
      // Recalculate timeline ruler and total duration (accounts for appended frame)
      if (typeof updateAllTimeScaleIndicators === 'function') {
        updateAllTimeScaleIndicators();
      }
    }

    function scrollToTimeline() {
      const timelineSection = document.querySelector('.bg-\\[\\#0a0a0a\\].border-t');
      if (timelineSection) {
        timelineSection.scrollIntoView({ 
          behavior: 'smooth',
          block: 'start'
        });
      } else {
        // Fallback: scroll to bottom of page
        window.scrollTo({
          top: document.body.scrollHeight,
          behavior: 'smooth'
        });
      }
    }

    function updateTimelineDisplay() {
      const timelineContainer = document.getElementById('timeline-container');
      const frameCount = frameLayers.length;
      
      // Clear existing timeline content
      timelineContainer.innerHTML = '';
      
      // Create timeline frames for all frames
      for (let i = 0; i < frameCount; i++) {
        const frameContainer = document.createElement('div');
        frameContainer.className = 'timeline-frame-container';
        
        // Frame index label above the frame
        const idLabel = document.createElement('div');
        idLabel.className = 'timeline-frame-id';
        idLabel.textContent = String(i + 1);
        
        const frameDiv = document.createElement('div');
        frameDiv.className = `timeline-frame ${i === currentFrame ? 'active' : ''}`;
        frameDiv.id = `timeline-${i}`;
        frameDiv.onclick = () => selectFrame(i);
        // Event listeners are handled globally
        
        const canvas = document.createElement('canvas');
        canvas.width = 60;
        canvas.height = 60;
        canvas.id = `thumb-${i}`;
        canvas.style.width = '100%';
        canvas.style.height = '100%';
        canvas.style.objectFit = 'cover';
        canvas.style.pointerEvents = 'none';
        
        const durationDiv = document.createElement('div');
        durationDiv.className = 'frame-duration-indicator';
        durationDiv.id = `duration-${i}`;
        durationDiv.textContent = `${frameDurations[i]}x`;
        
        frameDiv.appendChild(canvas);
        frameDiv.appendChild(durationDiv);
        
        const leftRib = document.createElement('div');
        leftRib.className = 'timeline-rib timeline-rib-left';
        leftRib.id = `rib-left-${i}`;
        leftRib.onmousedown = (e) => startRibDrag(e, i, 'left');
        
        const rightRib = document.createElement('div');
        rightRib.className = 'timeline-rib timeline-rib-right';
        rightRib.id = `rib-right-${i}`;
        rightRib.onmousedown = (e) => startRibDrag(e, i, 'right');
        
        frameContainer.appendChild(idLabel);
        frameContainer.appendChild(frameDiv);
        frameContainer.appendChild(leftRib);
        frameContainer.appendChild(rightRib);
        
        timelineContainer.appendChild(frameContainer);
        
        // Ensure container width reflects duration immediately
        if (typeof updateFrameDurationIndicator === 'function') {
          updateFrameDurationIndicator(i);
        }
      }
      
      
      // Update thumbnails for all frames
      for (let i = 0; i < frameCount; i++) {
        updateThumbnail(i);
      }
      
      // Ensure timeline ruler and duration label reflect latest frames/durations
      if (typeof updateAllTimeScaleIndicators === 'function') {
        updateAllTimeScaleIndicators();
      }
    }


    function initializeCanvases() {
      // Clear existing arrays
      canvases.length = 0;
      contexts.length = 0;
      onionCanvases.length = 0;
      onionContexts.length = 0;
      thumbCanvases.length = 0;
      thumbContexts.length = 0;
      
      const frameCount = frameLayers.length;
      
      // Initialize canvases for all frames
      const target = getTargetCanvasSizeForViewport(currentViewport);
      for (let i = 0; i < frameCount; i++) {
        const canvas = document.getElementById(`canvas-${i}`);
        if (canvas) {
          canvas.width = target.width;
          canvas.height = target.height;
          const ctx = canvas.getContext('2d', { willReadFrequently: true });
          ctx.fillStyle = '#1a1a1a';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          canvases.push(canvas);
          contexts.push(ctx);

          const onionCanvas = document.getElementById(`onion-${i}`);
          if (onionCanvas) {
            onionCanvas.width = target.width;
            onionCanvas.height = target.height;
            const onionCtx = onionCanvas.getContext('2d');
            onionCanvases.push(onionCanvas);
            onionContexts.push(onionCtx);
          }

          const thumbCanvas = document.getElementById(`thumb-${i}`);
          if (thumbCanvas) {
            const thumbCtx = thumbCanvas.getContext('2d');
            thumbCtx.fillStyle = '#1a1a1a';
            thumbCtx.fillRect(0, 0, thumbCanvas.width, thumbCanvas.height);
            thumbCanvases.push(thumbCanvas);
            thumbContexts.push(thumbCtx);
          }
        }
      }
      
      // Update all thumbnails
      for (let i = 0; i < frameCount; i++) {
        updateThumbnail(i);
      }
    }

    function clearAllFrames() {
      if (confirm('Clear all frames? This cannot be undone.')) {
        saveState();
        frameLayers.forEach((layers, frameIndex) => {
          layers.forEach(layer => {
            layer.ctx.clearRect(0, 0, layer.canvas.width, layer.canvas.height);
          });
          composeLayers(frameIndex);
          updateThumbnail(frameIndex);
        });
        updateOnionSkin();
      }
    }

    function toggleOnionSkin() {
      onionSkinEnabled = document.getElementById('onion-skin-prev').checked;
      const controls = document.getElementById('onion-controls');
      controls.style.display = onionSkinEnabled ? 'block' : 'none';
      updateOnionSkin();
    }

    function updateOnionSkin() {
      onionContexts.forEach((ctx, i) => {
        ctx.clearRect(0, 0, onionCanvases[i].width, onionCanvases[i].height);
      });

      /* Show onion skin on next frame automatically */
      if (onionSkinEnabled) {
        for (let i = 1; i < 6; i++) {
          const prevFrameIndex = i - 1;
          const onionCtx = onionContexts[i];
          
          const tempCanvas = document.createElement('canvas');
          tempCanvas.width = canvases[i].width;
          tempCanvas.height = canvases[i].height;
          const tempCtx = tempCanvas.getContext('2d');
          tempCtx.fillStyle = '#1a1a1a';
          tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

          frameLayers[prevFrameIndex].forEach(layer => {
            if (layer.visible) {
              tempCtx.save();
              tempCtx.globalAlpha = layer.opacity;
              tempCtx.drawImage(layer.canvas, 0, 0);
              if (Array.isArray(layer.images)) {
                for (const obj of layer.images) {
                  tempCtx.imageSmoothingEnabled = true;
                  tempCtx.imageSmoothingQuality = 'high';
                  drawRotatedImage(tempCtx, obj);
                }
              }
              tempCtx.restore();
            }
          });
          
          const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
          const pixels = imageData.data;
          
          const bgColor = hexToRgb('#1a1a1a');
          for (let j = 0; j < pixels.length; j += 4) {
            const r = pixels[j];
            const g = pixels[j + 1];
            const b = pixels[j + 2];
            const a = pixels[j + 3];
            
            const isBg = Math.abs(r - bgColor.r) < 10 && 
                         Math.abs(g - bgColor.g) < 10 && 
                         Math.abs(b - bgColor.b) < 10;
            
            if (!isBg && a > 0) {
              pixels[j] = Math.min(255, r * 0.7 + 255 * 0.3);
              pixels[j + 1] = Math.min(255, g * 0.7 + 105 * 0.3);
              pixels[j + 2] = Math.min(255, b * 0.7 + 180 * 0.3);
              pixels[j + 3] = a * onionOpacity;
            } else {
              pixels[j + 3] = 0;
            }
          }
          
          tempCtx.putImageData(imageData, 0, 0);
          onionCtx.drawImage(tempCanvas, 0, 0);
        }
      }
    }

    function previousFrame() {
      if (currentFrame > 0) {
        selectFrame(currentFrame - 1);
      }
    }

    function nextFrame() {
      if (currentFrame < frameLayers.length - 1) {
        selectFrame(currentFrame + 1);
      }
    }

    function previewCurrentLayer() {
      if (animationInterval) {
        clearInterval(animationInterval);
        animationInterval = null;
        isPreviewingLayer = false;
        previewLayerIndex = -1;
        document.getElementById('play-btn').innerHTML = `
          <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
            <polygon points="5 3 19 12 5 21 5 3"/>
          </svg>
          Play
        `;
        return;
      }

      isPreviewingLayer = true;
      previewLayerIndex = currentLayer;
      animationFrame = 0;
      currentFrameTime = 0;
      currentFrameDuration = frameDurations[0];
      
      animationInterval = setInterval(() => {
        // Background on base preview
        previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
        previewCtx.fillStyle = '#1a1a1a';
        previewCtx.fillRect(0, 0, previewCanvas.width, previewCanvas.height);

        // Content on transparent overlay
        if (!contentCtx) ensurePreviewContentOverlay();
        contentCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
        const layer = frameLayers[animationFrame][previewLayerIndex];
        if (layer && layer.visible) {
          contentCtx.save();
          contentCtx.globalAlpha = layer.opacity;
          contentCtx.drawImage(layer.canvas, 0, 0, previewCanvas.width, previewCanvas.height);
          const baseCanvas = canvases[animationFrame];
          const sx = previewCanvas.width / baseCanvas.width;
          const sy = previewCanvas.height / baseCanvas.height;
          if (Array.isArray(layer.images)) {
            for (const obj of layer.images) {
              contentCtx.imageSmoothingEnabled = true;
              contentCtx.imageSmoothingQuality = 'high';
              drawRotatedImage(contentCtx, obj, sx, sy);
            }
          }
          contentCtx.restore();
        }

        // Update animation timing based on frame durations
        currentFrameTime++;
        if (currentFrameTime >= currentFrameDuration) {
          animationFrame = (animationFrame + 1) % frameLayers.length;
          currentFrameTime = 0;
          currentFrameDuration = frameDurations[animationFrame];
        }
      }, 1000 / fps);
      
      document.getElementById('play-btn').innerHTML = `
        <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
          <rect x="6" y="4" width="4" height="16"/>
          <rect x="14" y="4" width="4" height="16"/>
        </svg>
        Pause
      `;
    }

    function duplicateLayerToAllFrames() {
      if (!confirm('Copy the current layer from this frame to all other frames? This will overwrite existing content on this layer in other frames.')) {
        return;
      }
      
      saveState();
      const sourceLayer = frameLayers[currentFrame][currentLayer];
      
      for (let frameIndex = 0; frameIndex < 6; frameIndex++) {
        if (frameIndex === currentFrame) continue;
        
        while (frameLayers[frameIndex].length <= currentLayer) {
          const layerCanvas = document.createElement('canvas');
          layerCanvas.width = canvases[frameIndex].width;
          layerCanvas.height = canvases[frameIndex].height;
          const layerCtx = layerCanvas.getContext('2d', { willReadFrequently: true });
          
          const layerIndex = frameLayers[frameIndex].length;
          frameLayers[frameIndex].push({
            canvas: layerCanvas,
            ctx: layerCtx,
            visible: true,
            name: `Layer ${layerIndex + 1}`,
            opacity: 1,
            color: layerColors[layerIndex % layerColors.length]
          });
        }
        
        const targetLayer = frameLayers[frameIndex][currentLayer];
        targetLayer.ctx.clearRect(0, 0, targetLayer.canvas.width, targetLayer.canvas.height);
        targetLayer.ctx.drawImage(sourceLayer.canvas, 0, 0);
        targetLayer.visible = sourceLayer.visible;
        targetLayer.opacity = sourceLayer.opacity;
        
        composeLayers(frameIndex);
        updateThumbnail(frameIndex);
      }
      
      alert('Layer copied to all frames! Now you can add another animation on a new layer.');
    }

    function toggleAnimation() {
      if (animationInterval) {
        clearInterval(animationInterval);
        animationInterval = null;
        isPreviewingLayer = false;
        previewLayerIndex = -1;
        document.getElementById('play-btn').innerHTML = `
          <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
            <polygon points="5 3 19 12 5 21 5 3"/>
          </svg>
          Play
        `;
      } else {
        isPreviewingLayer = false;
        previewLayerIndex = -1;
        animationFrame = 0;
        currentFrameTime = 0;
        currentFrameDuration = frameDurations[0];
        animationInterval = setInterval(updateAnimation, 1000 / fps);
        document.getElementById('play-btn').innerHTML = `
          <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
            <rect x="6" y="4" width="4" height="16"/>
            <rect x="14" y="4" width="4" height="16"/>
          </svg>
          Pause
        `;
      }
    }

    // Animation timing system
    let animationTimeUnit = 0;
    let currentFrameTime = 0;
    let currentFrameDuration = 1;

    function updateAnimation() {
      // Background on base preview
      previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
      previewCtx.fillStyle = '#1a1a1a';
      previewCtx.fillRect(0, 0, previewCanvas.width, previewCanvas.height);

      // Content on transparent overlay
      if (!contentCtx) ensurePreviewContentOverlay();
      contentCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
      const layersArr = getLayersArrayForIndex(animationFrame);
      layersArr.forEach(layer => {
        if (layer.visible) {
          contentCtx.save();
          contentCtx.globalAlpha = layer.opacity;
          contentCtx.drawImage(layer.canvas, 0, 0, previewCanvas.width, previewCanvas.height);
          const baseCanvas = canvases[animationFrame];
          const sx = previewCanvas.width / baseCanvas.width;
          const sy = previewCanvas.height / baseCanvas.height;
          if (Array.isArray(layer.images)) {
            for (const obj of layer.images) {
              contentCtx.imageSmoothingEnabled = true;
              contentCtx.imageSmoothingQuality = 'high';
              drawRotatedImage(contentCtx, obj, sx, sy);
            }
          }
          contentCtx.restore();
        }
      });

      // Update animation timing based on frame durations
      currentFrameTime++;
      if (currentFrameTime >= currentFrameDuration) {
        const totalFrames = getActiveClipTotalFrames();
        animationFrame = (animationFrame + 1) % totalFrames;
        currentFrameTime = 0;
        currentFrameDuration = getDurationForIndex(animationFrame);
      }
    }

    // Render a single static frame to the preview (no timers updated)
    function renderStaticFrame(frameIndex) {
      const totalFrames = getActiveClipTotalFrames();
      const idxVirtual = Math.max(0, Math.min(totalFrames - 1, frameIndex|0));
      previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
      previewCtx.fillStyle = '#1a1a1a';
      previewCtx.fillRect(0, 0, previewCanvas.width, previewCanvas.height);
      if (!contentCtx) ensurePreviewContentOverlay();
      contentCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
      const layersArr = getLayersArrayForIndex(idxVirtual);
      layersArr.forEach(layer => {
        if (layer.visible) {
          contentCtx.save();
          contentCtx.globalAlpha = layer.opacity;
          contentCtx.drawImage(layer.canvas, 0, 0, previewCanvas.width, previewCanvas.height);
          const baseCanvas = canvases[idxVirtual];
          const sx = previewCanvas.width / baseCanvas.width;
          const sy = previewCanvas.height / baseCanvas.height;
          if (Array.isArray(layer.images)) {
            for (const obj of layer.images) {
              contentCtx.imageSmoothingEnabled = true;
              contentCtx.imageSmoothingQuality = 'high';
              drawRotatedImage(contentCtx, obj, sx, sy);
            }
          }
          contentCtx.restore();
        }
      });
    }

    // Global helper: render a Cut Out frame at time t to a context, with green-screen background (no checkerboard)
    // This is used by both FFmpeg export and MediaRecorder export
    function renderCutoutFrameTo(ctx, w, h, tSec) {
      try {
        // Find the active clip at the requested time
        const idx = (typeof getActiveCutoutClipIndexAt === 'function')
          ? getActiveCutoutClipIndexAt(tSec)
          : (Array.isArray(cutoutClips) ? cutoutClips.findIndex((c) => c && typeof c.start === 'number' && typeof c.end === 'number' && tSec >= c.start && tSec < c.end) : -1);
        let c = cutoutClips[idx];
        if (!c && Array.isArray(cutoutClips) && cutoutClips.length) c = cutoutClips[0];
        
        // Fill background with black
        ctx.fillStyle = '#000000';
        ctx.fillRect(0, 0, w, h);
        
        if (!c) return;
        
        try { ctx.imageSmoothingEnabled = true; ctx.imageSmoothingQuality = 'high'; } catch (_e) {}
        
        // Determine the source canvas dimensions (clip canvas or cutoutCanvas as reference)
        const srcW = (c.canvas && c.canvas.width > 0) ? c.canvas.width : (cutoutCanvas && cutoutCanvas.width > 0 ? cutoutCanvas.width : w);
        const srcH = (c.canvas && c.canvas.height > 0) ? c.canvas.height : (cutoutCanvas && cutoutCanvas.height > 0 ? cutoutCanvas.height : h);
        
        // Calculate scale factors to map source coordinates to destination
        const scaleX = w / srcW;
        const scaleY = h / srcH;
        
        // Draw the base clip fill layer (if any) so fills sit underneath everything
        if (c && c.fillCanvas && c.fillCanvas.width > 0 && c.fillCanvas.height > 0) {
          try {
            ctx.drawImage(c.fillCanvas, 0, 0, c.fillCanvas.width, c.fillCanvas.height, 0, 0, w, h);
          } catch (_e) {}
        }
        
        // Draw the base clip canvas (brush drawings) so fills remain below brush strokes
        if (c && c.canvas && c.canvas.width > 0 && c.canvas.height > 0) {
          try { 
            ctx.drawImage(c.canvas, 0, 0, c.canvas.width, c.canvas.height, 0, 0, w, h); 
          } catch (_e) {}
        }
        
        // Draw animated objects above the canvas with correct layering and scaling
        let objects = Array.isArray(c.objects) ? c.objects.slice() : (c.object ? [c.object] : []);
        objects.sort((a, b) => {
          const ai = Number.isFinite(a && a.layerIndex) ? a.layerIndex : 0;
          const bi = Number.isFinite(b && b.layerIndex) ? b.layerIndex : 0;
          if (ai !== bi) return bi - ai;
          const aid = (a && a.id != null) ? a.id : 0;
          const bid = (b && b.id != null) ? b.id : 0;
          return aid - bid;
        });
        
        const t = Math.max(0, Math.min(Number.isFinite(cutoutDuration) ? cutoutDuration : 0, tSec || 0));
        
        for (const obj of objects) {
          if (!obj || !obj.img) continue;
          const drawObj = {
            img: obj.img, src: obj.src,
            x: (Number.isFinite(obj.x) ? obj.x : 0) * scaleX,
            y: (Number.isFinite(obj.y) ? obj.y : 0) * scaleY,
            scale: Number.isFinite(obj.scale) ? obj.scale : 1,
            scaleX: (Number.isFinite(obj.scaleX) ? obj.scaleX : 1) * scaleX,
            scaleY: (Number.isFinite(obj.scaleY) ? obj.scaleY : 1) * scaleY,
            rotation: Number.isFinite(obj.rotation) ? obj.rotation : 0,
            opacity: Number.isFinite(obj.opacity) ? obj.opacity : 1,
            drawW: obj.drawW ? obj.drawW * scaleX : undefined,
            drawH: obj.drawH ? obj.drawH * scaleY : undefined
          };
          const keys = (obj.keys && typeof obj.keys === 'object') ? obj.keys : { position: [], zoom: [], rotation: [], opacity: [] };
          try { 
            const pos = sampleKeyframes(keys.position, t, (a,b,aL)=>({ x: lerp(a.x,b.x,aL), y: lerp(a.y,b.y,aL) })); 
            if (pos) { drawObj.x = pos.x * scaleX; drawObj.y = pos.y * scaleY; } 
          } catch (_e) {}
          try { 
            const zm = sampleKeyframes(keys.zoom, t, (a,b,aL)=>({ sx: lerp(a.sx,b.sx,aL), sy: lerp(a.sy,b.sy,aL) })); 
            if (zm) { drawObj.scaleX = zm.sx * scaleX; drawObj.scaleY = zm.sy * scaleY; } 
          } catch (_e) {}
          try { 
            const rot = sampleKeyframes(keys.rotation, t, (a,b,aL)=>({ deg: lerp(a.deg, shortestAngleDeg(a.deg,b.deg), aL) })); 
            if (rot) { drawObj.rotation = (rot.deg * Math.PI) / 180; } 
          } catch (_e) {}
          try { 
            const op = sampleKeyframes(keys.opacity, t, (a,b,aL)=>({ value: lerp(a.value,b.value,aL) })); 
            if (op) { drawObj.opacity = Math.max(0, Math.min(1, op.value)); } 
          } catch (_e) {}
          try { drawRotatedImage(ctx, drawObj); } catch (_e) {}
        }
        
        // Also try compositing from cutout-content-canvas overlay if present
        try {
          const cutoutOverlay = document.getElementById('cutout-content-canvas');
          if (cutoutOverlay && cutoutOverlay.width > 0 && cutoutOverlay.height > 0) {
            ctx.drawImage(cutoutOverlay, 0, 0, cutoutOverlay.width, cutoutOverlay.height, 0, 0, w, h);
          }
        } catch (_e) {}
      } catch (_e) {}
    }
    
    async function exportAnimation() {
      try {
        // Show loading state
        document.getElementById('status-text').textContent = 'Preparing video export...';
        // Ensure canvases are correctly sized before any capture
        try {
          if (isCutOutMode && typeof syncCutoutSizing === 'function') {
            syncCutoutSizing();
          }
        } catch (_e) {}
        // Ensure all clip canvases have proper dimensions before export
        try {
          if (isCutOutMode && typeof syncAllClipCanvasDimensions === 'function') {
            syncAllClipCanvasDimensions();
          }
        } catch (_e) {}
        
        // Prefer FFmpeg. If not yet initialized, wait briefly; only then fall back.
        let FFmpegLib = (typeof window !== 'undefined' && window.FFmpeg) ? window.FFmpeg : (typeof FFmpeg !== 'undefined' ? FFmpeg : undefined);
        if (!FFmpegLib) {
          // Small grace period for CDN script to attach the global
          await new Promise((r) => setTimeout(r, 300));
          FFmpegLib = (typeof window !== 'undefined' && window.FFmpeg) ? window.FFmpeg : (typeof FFmpeg !== 'undefined' ? FFmpeg : undefined);
        }
        if (!FFmpegLib) {
          try {
            await exportWithMediaRecorder(); // keep MP4 mime if available
            return;
          } catch (_e) {
            await exportFramesAsImages();
            return;
          }
        }
        
        // Create frames array with proper timing and loop count
        const frames = [];
        // For Cut Out mode, use 60fps to match the smooth preview playback
        // For regular mode, use the user-configured fps
        const exportFps = isCutOutMode ? 60 : (typeof fps === 'number' && fps > 0 ? fps : 12);
        if (isCutOutMode) {
          // Cut Out export: sample the cutout timeline at 60fps for smooth animation
          // This matches the preview playback which uses requestAnimationFrame (typically 60fps)
          const clips = Array.isArray(cutoutClips) ? cutoutClips.slice().filter(c => c && typeof c.start === 'number' && typeof c.end === 'number' && c.end > c.start) : [];
          clips.sort((a, b) => a.start - b.start);
          // If no clips exist, fall back to ruler-based single still
          const hasClips = clips.length > 0;
          // Determine consistent export dimensions - prefer cutoutCanvas, then first clip, then viewport default
          let exportW = 1920, exportH = 1080;
          if (cutoutCanvas && cutoutCanvas.width > 0 && cutoutCanvas.height > 0) {
            exportW = cutoutCanvas.width;
            exportH = cutoutCanvas.height;
          } else if (hasClips && clips[0].canvas && clips[0].canvas.width > 0 && clips[0].canvas.height > 0) {
            exportW = clips[0].canvas.width;
            exportH = clips[0].canvas.height;
          } else if (typeof getTargetCanvasSizeForViewport === 'function' && typeof currentViewport !== 'undefined') {
            const target = getTargetCanvasSizeForViewport(currentViewport);
            exportW = target.width || 1920;
            exportH = target.height || 1080;
          } else if (canvases && canvases[0] && canvases[0].width > 0) {
            exportW = canvases[0].width;
            exportH = canvases[0].height;
          }
      // Calculate total duration from clips
      const totalDuration = hasClips ? Math.max(...clips.map(c => c.end)) : (cutoutDuration || 3.0);
          for (let loop = 0; loop < loopCount; loop++) {
            if (hasClips) {
              // Sample the entire timeline at 60fps intervals for smooth playback
              const totalFrames = Math.ceil(totalDuration * exportFps);
              for (let frame = 0; frame < totalFrames; frame++) {
                const t = (frame / exportFps);
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = exportW;
                tempCanvas.height = exportH;
                const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });
                renderCutoutFrameTo(tempCtx, tempCanvas.width, tempCanvas.height, t);
                const frameData = tempCanvas.toDataURL('image/png');
                frames.push(frameData);
              }
            } else {
              // No clips: render a single still based on current time and canvas size
              const w = (cutoutCanvas && cutoutCanvas.width) ? cutoutCanvas.width : (canvases[0] ? canvases[0].width : 512);
              const h = (cutoutCanvas && cutoutCanvas.height) ? cutoutCanvas.height : (canvases[0] ? canvases[0].height : 512);
              const tempCanvas = document.createElement('canvas');
              tempCanvas.width = w;
              tempCanvas.height = h;
              const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });
              renderCutoutFrameTo(tempCtx, w, h, Math.max(0, Math.min(cutoutDuration || 0, cutoutCurrentTime || 0)));
              const frameData = tempCanvas.toDataURL('image/png');
              frames.push(frameData);
            }
          }
        } else {
          // Regular export: composite each frame including image objects based on frameDurations
          const totalFrames = (typeof getActiveClipTotalFrames === 'function') ? getActiveClipTotalFrames() : (Array.isArray(frameLayers) ? frameLayers.length : 0);
          for (let loop = 0; loop < loopCount; loop++) {
            for (let i = 0; i < totalFrames; i++) {
              const baseCanvas = canvases[i];
              if (!baseCanvas) continue;
              const tempCanvas = document.createElement('canvas');
              tempCanvas.width = baseCanvas.width;
              tempCanvas.height = baseCanvas.height;
              const tempCtx = tempCanvas.getContext('2d');
              // Fill background
              tempCtx.fillStyle = '#000000';
              tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
              // Draw all layers for this frame
              const layersForFrame = frameLayers[i] || [];
              layersForFrame.forEach(layer => {
                if (layer && layer.visible) {
                  tempCtx.save();
                  tempCtx.globalAlpha = (layer.opacity != null ? layer.opacity : 1);
                  tempCtx.drawImage(layer.canvas, 0, 0);
                  if (Array.isArray(layer.images)) {
                    for (const obj of layer.images) {
                      try {
                        tempCtx.imageSmoothingEnabled = true;
                        tempCtx.imageSmoothingQuality = 'high';
                      } catch (_e) {}
                      drawRotatedImage(tempCtx, obj);
                    }
                  }
                  tempCtx.restore();
                }
              });
              // Repeat frames according to duration and current fps
              const dur = Math.max(0.01, (frameDurations && frameDurations[i]) ? frameDurations[i] : 1);
              const repeats = Math.max(1, Math.round(dur * (typeof fps === 'number' && fps > 0 ? fps : 12)));
              const frameData = tempCanvas.toDataURL('image/png');
              for (let j = 0; j < repeats; j++) frames.push(frameData);
            }
          }
        }
        
        if (!frames.length) {
          throw new Error('No frames generated for export');
        }
        
        // Convert frames to video using FFmpeg
        const { createFFmpeg, fetchFile } = FFmpegLib;
        const ffmpeg = createFFmpeg({ 
          log: true,
          corePath: 'https://unpkg.com/@ffmpeg/core@0.12.6/dist/ffmpeg-core.js',
          wasmPath: 'https://unpkg.com/@ffmpeg/core@0.12.6/dist/ffmpeg-core.wasm'
        });
        
        document.getElementById('status-text').textContent = 'Loading FFmpeg...';
        
        // Add timeout for FFmpeg loading
        const loadPromise = ffmpeg.load();
        const timeoutPromise = new Promise((_, reject) => 
          setTimeout(() => reject(new Error('FFmpeg loading timeout')), 30000)
        );
        
        await Promise.race([loadPromise, timeoutPromise]);
        
        document.getElementById('status-text').textContent = 'Processing frames...';
        
        // Determine padding size based on frame count (use at least 5 digits for 60fps exports)
        const padSize = Math.max(5, String(frames.length).length);
        const framePattern = `frame%0${padSize}d.png`;
        
        // Write frame files
        for (let i = 0; i < frames.length; i++) {
          const frameData = await fetchFile(frames[i]);
          ffmpeg.FS('writeFile', `frame${i.toString().padStart(padSize, '0')}.png`, frameData);
        }
        
        document.getElementById('status-text').textContent = 'Creating MP4 video...';
        
        // Run FFmpeg command to create video at the correct frame rate
        await ffmpeg.run(
          '-framerate', exportFps.toString(),
          '-i', framePattern,
          '-c:v', 'libx264',
          '-pix_fmt', 'yuv420p',
          '-y',
          'output.mp4'
        );
        
        // Get the output video
        const videoData = ffmpeg.FS('readFile', 'output.mp4');
        const videoBlob = new Blob([videoData.buffer], { type: 'video/mp4' });
        const videoUrl = URL.createObjectURL(videoBlob);
        
        // Download the video
        const link = document.createElement('a');
        link.download = `animation-${Date.now()}.mp4`;
        link.href = videoUrl;
        link.click();
        
        // Cleanup
        URL.revokeObjectURL(videoUrl);
        ffmpeg.exit();
        
        document.getElementById('status-text').textContent = 'MP4 video exported successfully!';
        setTimeout(() => {
          document.getElementById('status-text').textContent = 'Ready';
        }, 2000);
        
      } catch (error) {
        console.error('Export failed:', error);
        let errorMessage = 'Export failed. Please try again.';
        
        if (error.message.includes('FFmpeg library not loaded')) {
          errorMessage = 'FFmpeg library not loaded. Please refresh the page and try again.';
        } else if (error.message.includes('loading timeout')) {
          errorMessage = 'FFmpeg loading timeout. Please check your internet connection and try again.';
        } else if (error.message.includes('load')) {
          errorMessage = 'Failed to load FFmpeg. Please check your internet connection and try again.';
        } else if (error.message.includes('run')) {
          errorMessage = 'Failed to process video. Please try again.';
        }
        
        document.getElementById('status-text').textContent = errorMessage;
        setTimeout(() => {
          document.getElementById('status-text').textContent = 'Ready';
        }, 5000);
      }
    }

    // Export using MediaRecorder API (WebM format)
    async function exportWithMediaRecorder() {
      return new Promise((resolve, reject) => {
        try {
          // Create a canvas for recording
          const recordCanvas = document.createElement('canvas');
          if (isCutOutMode) {
            // Use consistent export dimensions - prefer cutoutCanvas, then viewport target, then fallback
            let w = 1920, h = 1080;
            if (cutoutCanvas && cutoutCanvas.width > 0 && cutoutCanvas.height > 0) {
              w = cutoutCanvas.width;
              h = cutoutCanvas.height;
            } else if (typeof getTargetCanvasSizeForViewport === 'function' && typeof currentViewport !== 'undefined') {
              const target = getTargetCanvasSizeForViewport(currentViewport);
              w = target.width || 1920;
              h = target.height || 1080;
            } else if (canvases && canvases[0] && canvases[0].width > 0) {
              w = canvases[0].width;
              h = canvases[0].height;
            }
            recordCanvas.width = w;
            recordCanvas.height = h;
          } else {
            recordCanvas.width = canvases[0].width;
            recordCanvas.height = canvases[0].height;
          }
          const recordCtx = recordCanvas.getContext('2d');
          
          // Create a stream from the canvas
          const stream = recordCanvas.captureStream(60); // 60 FPS
          
          // Create MediaRecorder
          const mediaRecorder = new MediaRecorder(stream, {
            mimeType: 'video/mp4'
          });
          
          const chunks = [];
          mediaRecorder.ondataavailable = (event) => {
            if (event.data.size > 0) {
              chunks.push(event.data);
            }
          };
          
          mediaRecorder.onstop = () => {
            const blob = new Blob(chunks, { type: 'video/mp4' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `animation-${Date.now()}.mp4`;
            link.click();
            URL.revokeObjectURL(url);
            document.getElementById('status-text').textContent = 'MP4 video exported successfully!';
            setTimeout(() => {
              document.getElementById('status-text').textContent = 'Ready';
            }, 2000);
            resolve();
          };
          
          mediaRecorder.onerror = (error) => {
            reject(error);
          };
          
          // Start recording
          mediaRecorder.start();
          
          // Animate frames with proper timing and loop count
          // Use 60fps for Cut Out mode to match the smooth preview playback
          const recorderFps = isCutOutMode ? 60 : (typeof fps === 'number' && fps > 0 ? fps : 12);
          if (isCutOutMode) {
            // Cut Out: sample the entire timeline at 60fps for smooth animation
            const clips = Array.isArray(cutoutClips) ? cutoutClips.slice().filter(c => c && typeof c.start === 'number' && typeof c.end === 'number' && c.end > c.start) : [];
            clips.sort((a, b) => a.start - b.start);
            const hasClips = clips.length > 0;
            // Calculate total duration from clips
            const totalDuration = hasClips ? Math.max(...clips.map(c => c.end)) : (cutoutDuration || 3.0);
            const totalFrames = Math.ceil(totalDuration * recorderFps);
            let currentFrame = 0;
            let currentLoop = 0;
            const tick = () => {
              recordCtx.fillStyle = '#000';
              recordCtx.fillRect(0, 0, recordCanvas.width, recordCanvas.height);
              if (hasClips) {
                // Calculate time from frame number
                const t = currentFrame / recorderFps;
                try { renderCutoutFrameTo(recordCtx, recordCanvas.width, recordCanvas.height, t); } catch (_e) {}
                currentFrame++;
                if (currentFrame < totalFrames) {
                  setTimeout(tick, 1000 / recorderFps);
                } else {
                  currentFrame = 0;
                  currentLoop++;
                  if (currentLoop < loopCount) {
                    setTimeout(tick, 1000 / recorderFps);
                  } else {
                    mediaRecorder.stop();
                  }
                }
              } else {
                // No clips: render a single still
                try { renderCutoutFrameTo(recordCtx, recordCanvas.width, recordCanvas.height, Math.max(0, Math.min(cutoutDuration || 0, cutoutCurrentTime || 0))); } catch (_e) {}
                mediaRecorder.stop();
              }
            };
            tick();
          } else {
            let frameIndex = 0;
            let currentLoop = 0;
            const animate = () => {
              // Clear canvas
              recordCtx.fillStyle = '#000000';
              recordCtx.fillRect(0, 0, recordCanvas.width, recordCanvas.height);
              
              // Draw current frame (regular mode)
              frameLayers[frameIndex].forEach(layer => {
                if (!layer || !layer.visible) return;
                recordCtx.save();
                recordCtx.globalAlpha = layer.opacity;
                try { recordCtx.drawImage(layer.canvas, 0, 0); } catch (_e) {}
                if (Array.isArray(layer.images)) {
                  for (const obj of layer.images) {
                    recordCtx.imageSmoothingEnabled = true;
                    recordCtx.imageSmoothingQuality = 'high';
                    try { drawRotatedImage(recordCtx, obj); } catch (_e) {}
                  }
                }
                recordCtx.restore();
              });
              
              frameIndex++;
              if (frameIndex < 6) {
                const frameDuration = frameDurations[frameIndex - 1];
                const delay = (frameDuration / fps) * 1000;
                setTimeout(animate, delay);
              } else {
                currentLoop++;
                if (currentLoop < loopCount) {
                  frameIndex = 0;
                  const lastFrameDuration = frameDurations[5];
                  const delay = (lastFrameDuration / fps) * 1000;
                  setTimeout(animate, delay);
                } else {
                  const lastFrameDuration = frameDurations[5];
                  const delay = (lastFrameDuration / fps) * 1000;
                  setTimeout(() => { mediaRecorder.stop(); }, delay);
                }
              }
            };
            animate();
          }
          
        } catch (error) {
          reject(error);
        }
      });
    }

    // Fallback function to export frames as individual images
    async function exportFramesAsImages() {
      try {
        const zip = new JSZip();
        
        let frameCounter = 1;
        
        // Repeat frames based on loop count
        for (let loop = 0; loop < loopCount; loop++) {
          for (let i = 0; i < 6; i++) {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvases[i].width;
            tempCanvas.height = canvases[i].height;
            const tempCtx = tempCanvas.getContext('2d');
            
            // Fill background
            tempCtx.fillStyle = '#000000';
            tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
            
            // Draw all layers for this frame
            frameLayers[i].forEach(layer => {
              if (layer.visible) {
                tempCtx.save();
                tempCtx.globalAlpha = layer.opacity;
                tempCtx.drawImage(layer.canvas, 0, 0);
                tempCtx.restore();
              }
            });
            
            // Convert to blob and add to zip
            const blob = await new Promise(resolve => tempCanvas.toBlob(resolve, 'image/png'));
            const frameName = loopCount > 1 ? `frame_${frameCounter}_loop_${loop + 1}.png` : `frame_${frameCounter}.png`;
            zip.file(frameName, blob);
            frameCounter++;
          }
        }
        
        // Generate and download zip
        const zipBlob = await zip.generateAsync({ type: 'blob' });
        const url = URL.createObjectURL(zipBlob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `animation-frames-${Date.now()}.zip`;
        link.click();
        URL.revokeObjectURL(url);
        
        document.getElementById('status-text').textContent = 'Frames exported as images!';
        setTimeout(() => {
          document.getElementById('status-text').textContent = 'Ready';
        }, 2000);
        
      } catch (error) {
        console.error('Frame export failed:', error);
        document.getElementById('status-text').textContent = 'Export failed. Please try again.';
        setTimeout(() => {
          document.getElementById('status-text').textContent = 'Ready';
        }, 3000);
      }
    }

    function clearCurrentFrameContents() {
      saveState();
      if (isCutOutMode) {
        // Clear all cutout clips content for current time range
        for (const clip of cutoutClips) {
          if (!clip || !clip.canvas || !clip.ctx) continue;
          clip.ctx.clearRect(0, 0, clip.canvas.width, clip.canvas.height);
        }
        if (typeof cutoutSelectedObject !== 'undefined' && cutoutSelectedObject) {
          try { cutoutCommitSelection(); } catch (_e) { /* ignore */ }
          cutoutSelectedObject = null;
        }
        renderCutoutPreviewForTime();
        drawCutoutTimeline();
      } else {
        const layers = frameLayers[currentFrame] || [];
        layers.forEach(layer => {
          if (!layer || !layer.canvas || !layer.ctx) return;
          layer.ctx.clearRect(0, 0, layer.canvas.width, layer.canvas.height);
          if (Array.isArray(layer.images)) layer.images.length = 0;
        });
        composeLayers(currentFrame);
        updateThumbnail(currentFrame);
        if (typeof showCopyPasteFeedback === 'function') {
          showCopyPasteFeedback(`Cleared frame ${currentFrame + 1}`);
        }
      }
    }

    document.addEventListener('keydown', (e) => {
      // Debug logging (remove in production)
      if (e.ctrlKey || e.metaKey) {
        console.log('Key pressed:', e.key, 'Shift:', e.shiftKey, 'Ctrl:', e.ctrlKey, 'Meta:', e.metaKey);
      }
      
      if (e.ctrlKey || e.metaKey) {
        // Handle copy (Cmd+C or Ctrl+C)
        if (e.key === 'c' || e.key === 'C') {
          e.preventDefault();
          copyFrame(currentFrame);
          showCopyPasteFeedback(`Copied frame ${currentFrame + 1}`);
        }
        // Handle paste (Cmd+V or Ctrl+V)
        else if (e.key === 'v' || e.key === 'V') {
          e.preventDefault();
          if (copiedFrameData && copiedFrameIndex !== -1) {
            pasteFrame(currentFrame);
            showCopyPasteFeedback(`Pasted frame ${copiedFrameIndex + 1} to frame ${currentFrame + 1}`);
          } else {
            showCopyPasteFeedback('No frame copied. Right-click and select "Copy Frame" first.');
          }
        }
        // Handle undo (Cmd+Z or Ctrl+Z)
        else if ((e.key === 'z' || e.key === 'Z') && !e.shiftKey) {
          e.preventDefault();
          undo();
        } 
        // Handle redo (Cmd+Shift+Z, Ctrl+Shift+Z, Cmd+Y, or Ctrl+Y)
        else if (e.key === 'y' || e.key === 'Y' || ((e.key === 'z' || e.key === 'Z') && e.shiftKey)) {
          e.preventDefault();
          redo();
        }
      } else {
        // Bones tool: delete only the selected bone (not attached object)
        if (!isCutOutMode && (e.key === 'Delete' || e.key === 'Backspace') && currentTool === 'bones' && typeof selectedBoneIndex === 'number' && selectedBoneIndex >= 0) {
          e.preventDefault();
          deleteBoneAtIndex(selectedBoneIndex);
          return;
        }
        // Delete selection when using Select tool (disabled in Cut Out Mode)
        if (!isCutOutMode && (e.key === 'Delete' || e.key === 'Backspace') && currentTool === 'select' && selectedImageObject) {
          e.preventDefault();
          saveState();
          const layer = frameLayers[currentFrame][currentLayer];
          const idx = Array.isArray(layer.images) ? layer.images.indexOf(selectedImageObject) : -1;
          if (idx > -1) {
            layer.images.splice(idx, 1);
          }
          selectedImageObject = null;
          endImageDrag();
          isDraggingImage = false;
          isResizingImage = false;
          isRotatingImage = false;
          composeLayers(currentFrame);
          updateThumbnail(currentFrame);
          return;
        }
        // Clear current frame contents if Delete/Backspace pressed and not typing in input fields
        if (!isCutOutMode && (e.key === 'Delete' || e.key === 'Backspace')) {
          const ae = document.activeElement;
          const typing = ae && (ae.tagName === 'INPUT' || ae.tagName === 'TEXTAREA' || ae.isContentEditable);
          if (!typing) {
            e.preventDefault();
            clearCurrentFrameContents();
            return;
          }
        }
        switch(e.key.toLowerCase()) {
          case 'b': setTool('brush'); break;
          case 'p': setTool('pencil'); break;
          case 'e': setTool('eraser'); break;
          case 'f': setTool('fill'); break;
          case 'l': setTool('lasso'); break;
          case 'c': setTool('color-picker'); break;
          case 'v': setTool('select'); break;
          case 'o': setTool('inner-fill'); break;
          case 'arrowright': nextFrame(); break;
          case 'arrowleft': previousFrame(); break;
          case ' ': e.preventDefault(); toggleAnimation(); break;
        }
      }
    });

    function addLayer() {
      saveState();
      
      // Determine the next logical layer number based on existing layer names (e.g., Layer 7 -> next is 8)
      let maxLayerNum = 0;
      try {
        const baseLayers = frameLayers[0] || [];
        for (let i = 0; i < baseLayers.length; i++) {
          const nm = (baseLayers[i] && baseLayers[i].name) ? String(baseLayers[i].name) : '';
          const m = nm.match(/Layer\s+(\d+)/i);
          if (m && m[1]) {
            const n = parseInt(m[1], 10);
            if (Number.isFinite(n) && n > maxLayerNum) maxLayerNum = n;
          }
        }
      } catch (_e) {}
      const nextLayerNum = maxLayerNum + 1;
      const layerIndex = nextLayerNum - 1;
      
      for (let frameIndex = 0; frameIndex < 6; frameIndex++) {
        const layerCanvas = document.createElement('canvas');
        layerCanvas.width = canvases[0].width;
        layerCanvas.height = canvases[0].height;
        const layerCtx = layerCanvas.getContext('2d', { willReadFrequently: true });
        
        // Enable high-quality image smoothing for new layers
        layerCtx.imageSmoothingEnabled = true;
        layerCtx.imageSmoothingQuality = 'high';
        
        const newLayer = {
          canvas: layerCanvas,
          ctx: layerCtx,
          visible: true,
          name: `Layer ${nextLayerNum}`,
          opacity: 1,
          color: layerColors[layerIndex % layerColors.length],
          images: []
        };
        
        frameLayers[frameIndex].push(newLayer);
        
        composeLayers(frameIndex);
        updateThumbnail(frameIndex);
      }
      
      currentLayer = frameLayers[currentFrame].length - 1;
      updateLayersList();
      updateFrameLabel();
      
      for (let i = 0; i < 6; i++) {
        const layer = frameLayers[i][currentLayer];
        const label = document.getElementById(`frame-label-${i}`);
        if (label) {
          label.textContent = `Frame ${i + 1} - ${layer.name}`;
          label.style.color = layer.color;
        }
      }
    }

    function deleteLayer(index) {
      if (frameLayers[currentFrame].length <= 1) {
        alert('Cannot delete the last layer');
        return;
      }
      
      frameLayers[currentFrame].splice(index, 1);
      if (currentLayer >= frameLayers[currentFrame].length) {
        currentLayer = frameLayers[currentFrame].length - 1;
      }
      updateLayersList();
      updateFrameLabel();
      composeLayers();
    }

    function toggleLayerVisibility(index) {
      frameLayers[currentFrame][index].visible = !frameLayers[currentFrame][index].visible;
      updateLayersList();
      composeLayers();
    }

    function selectLayer(index) {
      currentLayer = index;
      updateLayersList();
      updateFrameLabel();
    }

    function updateFrameLabel() {
      const layer = frameLayers[currentFrame][currentLayer];
      const label = document.getElementById(`frame-label-${currentFrame}`);
      if (label) {
        label.textContent = `Frame ${currentFrame + 1} - ${layer.name}`;
        label.style.color = layer.color;
      }
    }

    function updateLayersList() {
      const layersList = document.getElementById('layers-list');
      layersList.innerHTML = '';
      
      // Render layers in ascending order so Layer 1 appears at the top, Layer 2 below it, etc.
      for (let i = 0; i < frameLayers[currentFrame].length; i++) {
        const layer = frameLayers[currentFrame][i];
        const layerItem = document.createElement('div');
        layerItem.className = `layer-item ${i === currentLayer ? 'active' : ''}`;
        layerItem.onclick = () => selectLayer(i);
        // Ensure proper layout so delete 'X' is far right
        try {
          layerItem.style.display = 'flex';
          layerItem.style.alignItems = 'center';
          layerItem.style.position = 'relative';
          layerItem.style.gap = '6px';
          // leave space for the left color bar
          layerItem.style.paddingLeft = '6px';
        } catch (_e) {}
        
        layerItem.innerHTML = `
          <div style="width: 4px; height: 100%; background: ${layer.color}; border-radius: 2px; position: absolute; left: 0; top: 0;"></div>
          <div class="layer-visibility" onclick="event.stopPropagation(); toggleLayerVisibility(${i})">
            ${layer.visible ? 
              '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>' :
              '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"/><line x1="1" y1="1" x2="23" y2="23"/></svg>'
            }
          </div>
          <div class="layer-name" style="color: ${layer.color}">${layer.name}</div>
          <div class="layer-delete" onclick="event.stopPropagation(); deleteLayer(${i})">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <line x1="18" y1="6" x2="6" y2="18"/>
              <line x1="6" y1="6" x2="18" y2="18"/>
            </svg>
          </div>
        `;
        // Allow dropping object thumbnails onto this layer to move objects between layers
        try {
          layerItem.addEventListener('dragover', (ev) => {
            if (!ev.dataTransfer) return;
            const txt = ev.dataTransfer.getData('application/x-regular-obj') || ev.dataTransfer.getData('text/plain');
            if (!txt) return;
            try {
              const data = JSON.parse(txt);
              if (data && data.type === 'regular-obj') {
                ev.preventDefault();
                ev.dataTransfer.dropEffect = 'move';
              }
            } catch (_e) {}
          });
          layerItem.addEventListener('drop', (ev) => {
            if (!ev.dataTransfer) return;
            const txt = ev.dataTransfer.getData('application/x-regular-obj') || ev.dataTransfer.getData('text/plain');
            if (!txt) return;
            ev.preventDefault();
            ev.stopPropagation();
            try {
              const data = JSON.parse(txt);
              if (!data || data.type !== 'regular-obj') return;
              const fromLayer = data.layerIndex;
              const objIndex = data.objectIndex;
              if (!Number.isFinite(fromLayer) || !Number.isFinite(objIndex)) return;
              if (!frameLayers[currentFrame] || !frameLayers[currentFrame][fromLayer]) return;
              const srcLayer = frameLayers[currentFrame][fromLayer];
              if (!Array.isArray(srcLayer.images) || objIndex < 0 || objIndex >= srcLayer.images.length) return;
              const obj = srcLayer.images.splice(objIndex, 1)[0];
              if (!obj) return;
              // Insert into target layer i
              if (!Array.isArray(layer.images)) layer.images = [];
              layer.images.push(obj);
              // If we moved selection, keep it selected
              if (window.selectedImageObject === obj) {
                window.currentLayer = i;
              }
              // Refresh visuals
              try { composeLayers(); } catch (_e) {}
              try { updateThumbnail(currentFrame); } catch (_e) {}
              try { updateLayersList(); } catch (_e) {}
            } catch (_e) {}
          });
        } catch (_e) {}
        // Insert object thumbnails container to the right of the layer name, before the delete button
        try {
          const nameEl = layerItem.querySelector('.layer-name');
          const deleteEl = layerItem.querySelector('.layer-delete');
          if (deleteEl) {
            deleteEl.style.marginLeft = 'auto';
            deleteEl.style.display = 'inline-flex';
            deleteEl.style.alignItems = 'center';
          }
          const thumbs = document.createElement('div');
          // Horizontal, scrollable thumbnails; keep the button size unchanged
          thumbs.style.display = 'inline-flex';
          thumbs.style.alignItems = 'center';
          thumbs.style.gap = '4px';
          thumbs.style.maxWidth = '96px';
          thumbs.style.overflowX = 'auto';
          thumbs.style.marginLeft = '8px';
          thumbs.style.paddingBottom = '2px'; // keep scrollbar off the baseline
          thumbs.title = 'Layer objects';
          // Keep thumbnails tight to the layer name (avoid pushing far right)
          if (nameEl) {
            nameEl.style.flex = '0 0 auto';
            nameEl.style.display = 'inline-flex';
            nameEl.style.alignItems = 'center';
          }
          // Build thumbnails from layer.images
          if (Array.isArray(layer.images)) {
            for (let oi = 0; oi < layer.images.length; oi++) {
              const obj = layer.images[oi];
              if (!obj || !obj.img) continue;
              const t = document.createElement('canvas');
              t.width = 16; t.height = 16;
              t.style.flex = '0 0 auto';
              t.style.width = '16px'; t.style.height = '16px';
              const clr = (obj && obj.color) ? obj.color : '#6366f1';
              t.style.border = `1px solid ${clr}`;
              t.style.borderRadius = '3px';
              t.style.background = '#0b0b0b';
              t.style.cursor = 'pointer';
              t.draggable = true;
              const tctx = t.getContext('2d', { willReadFrequently: true });
              // Draw checkerboard background for clarity (2px tiles)
              try {
                const tile = 2;
                for (let yy = 0; yy < 16; yy += tile) {
                  for (let xx = 0; xx < 16; xx += tile) {
                    const dark = (((xx / tile) | 0) + ((yy / tile) | 0)) % 2 === 0;
                    tctx.fillStyle = dark ? '#0e0e0e' : '#151515';
                    tctx.fillRect(xx, yy, tile, tile);
                  }
                }
              } catch (_e) {}
              // Render object with its current transform to an offscreen, then fit that into 16x16
              const baseW = (obj && obj.drawW != null)
                ? obj.drawW
                : ((obj && obj.img && (obj.img.naturalWidth || obj.img.width || obj.img.videoWidth)) || 1);
              const baseH = (obj && obj.drawH != null)
                ? obj.drawH
                : ((obj && obj.img && (obj.img.naturalHeight || obj.img.height || obj.img.videoHeight)) || 1);
              const effSX = (typeof obj.scaleX === 'number' ? obj.scaleX : 1) * (obj.scale || 1);
              const effSY = (typeof obj.scaleY === 'number' ? obj.scaleY : 1) * (obj.scale || 1);
              const drawW = Math.max(1, Math.round(baseW * effSX));
              const drawH = Math.max(1, Math.round(baseH * effSY));
              const rot = obj.rotation || 0;
              const cosA = Math.abs(Math.cos(rot));
              const sinA = Math.abs(Math.sin(rot));
              const rotW = Math.max(1, Math.round(drawW * cosA + drawH * sinA));
              const rotH = Math.max(1, Math.round(drawW * sinA + drawH * cosA));
              let pv = null, pvCtx = null;
              try {
                pv = document.createElement('canvas');
                pv.width = rotW; pv.height = rotH;
                pvCtx = pv.getContext('2d', { willReadFrequently: true });
                pvCtx.save();
                pvCtx.translate(rotW / 2, rotH / 2);
                if (rot) pvCtx.rotate(rot);
                pvCtx.imageSmoothingEnabled = true;
                pvCtx.imageSmoothingQuality = 'high';
                pvCtx.drawImage(obj.img, -drawW / 2, -drawH / 2, drawW, drawH);
                pvCtx.restore();
              } catch (_e) {}
              // Fit the rotated bounds into 16x16 with small padding (shows full selection area)
              const pad = 1;
              const avail = 16 - pad * 2;
              // Apply additional zoom-out so the snapshot shows more context than a tight fit
              const zoomOut = 0.6; // 60% of the tight fit to reduce perceived zoom
              const r = Math.max(1, Math.min(avail / rotW, avail / rotH) * zoomOut);
              const dw = Math.max(1, Math.round(rotW * r));
              const dh = Math.max(1, Math.round(rotH * r));
              const dx = Math.floor((16 - dw) / 2);
              const dy = Math.floor((16 - dh) / 2);
              try {
                if (pv) tctx.drawImage(pv, dx, dy, dw, dh);
                else tctx.drawImage(obj.img, dx, dy, dw, dh);
              } catch (_e) {}
              // Colored inner border for clarity
              try {
                tctx.strokeStyle = clr;
                tctx.lineWidth = 1;
                tctx.strokeRect(0.5, 0.5, 15, 15);
              } catch (_e) {}
              // Drag start to move object across layers
              t.addEventListener('dragstart', (ev) => {
                try {
                  const payload = JSON.stringify({ type: 'regular-obj', layerIndex: i, objectIndex: oi });
                  ev.dataTransfer.setData('application/x-regular-obj', payload);
                  ev.dataTransfer.setData('text/plain', payload);
                  ev.dataTransfer.effectAllowed = 'move';
                } catch (_e) {}
              });
              // Click: select layer and object, switch to select
              t.addEventListener('click', (ev) => {
                ev.stopPropagation();
                try { selectLayer(i); } catch (_e) {}
                try { setTool('select'); } catch (_e) {}
                window.selectedImageObject = obj;
                try { beginImageDrag(); } catch (_e) {}
              });
              thumbs.appendChild(t);
            }
          }
          if (nameEl && deleteEl) {
            layerItem.insertBefore(thumbs, deleteEl);
          }
        } catch (_e) {}
        
        layersList.appendChild(layerItem);
      }
    }

    // -------- Simplified frame access (clips removed) --------
    function getActiveClipTotalFrames() {
      return 6;
    }
    function getLayersArrayForIndex(virtualIndex) {
      const idx = Math.max(0, Math.min(5, virtualIndex|0));
      return frameLayers[idx] || [];
    }
    function getDurationForIndex(virtualIndex) {
      const idx = Math.max(0, Math.min(5, virtualIndex|0));
      return frameDurations[idx] || 1;
    }

    function isPhoneViewport() {
      return cutoutPhoneMediaQuery ? cutoutPhoneMediaQuery.matches : (typeof window !== 'undefined' ? window.innerWidth <= 768 : false);
    }

    function closeCutoutMobilePanels(skipOverlay) {
      const leftPanel = document.getElementById('cutout-mobile-left-panel');
      const rightPanel = document.getElementById('cutout-mobile-right-panel');
      if (leftPanel) leftPanel.classList.remove('open');
      if (rightPanel) rightPanel.classList.remove('open');
      if (!skipOverlay) {
        const overlay = document.getElementById('sidebar-overlay');
        if (overlay) overlay.classList.remove('active');
      }
    }

    function toggleCutoutMobilePanel(side) {
      if (!isCutOutMode || !isPhoneViewport()) return;
      const target = side === 'right'
        ? document.getElementById('cutout-mobile-right-panel')
        : document.getElementById('cutout-mobile-left-panel');
      if (!target) return;
      const overlay = document.getElementById('sidebar-overlay');
      const isOpen = target.classList.contains('open');
      closeSidebars();
      closeCutoutMobilePanels(true);
      if (!isOpen) {
        target.classList.add('open');
        if (overlay) overlay.classList.add('active');
      } else if (overlay) {
        overlay.classList.remove('active');
      }
    }

    /* Added sidebar toggle functions for mobile */
    function toggleLeftSidebar() {
      const sidebar = document.getElementById('left-sidebar');
      const overlay = document.getElementById('sidebar-overlay');
      const isOpen = sidebar.classList.contains('open');
      
      closeSidebars();
      
      if (!isOpen) {
        sidebar.classList.add('open');
        overlay.classList.add('active');
      }
    }

    function toggleRightSidebar() {
      const sidebar = document.getElementById('right-sidebar');
      const overlay = document.getElementById('sidebar-overlay');
      const isOpen = sidebar.classList.contains('open');
      
      closeSidebars();
      
      if (!isOpen) {
        sidebar.classList.add('open');
        overlay.classList.add('active');
      }
    }

    function closeSidebars() {
      document.getElementById('left-sidebar').classList.remove('open');
      document.getElementById('right-sidebar').classList.remove('open');
      closeCutoutMobilePanels(true);
      document.getElementById('sidebar-overlay').classList.remove('active');
    }

    // Timeline rib drag functionality
    function startRibDrag(event, frameIndex, side) {
      event.preventDefault();
      event.stopPropagation();
      
      isDraggingRib = true;
      dragFrameIndex = frameIndex;
      dragSide = side;
      dragStartX = event.clientX;
      dragStartDuration = frameDurations[frameIndex];
      
      // Add visual feedback
      const rib = document.getElementById(`rib-${side}-${frameIndex}`);
      rib.classList.add('dragging');
      
      const container = rib.closest('.timeline-frame-container');
      container.classList.add('dragging');
      
      // Add global event listeners
      document.addEventListener('mousemove', handleRibDrag);
      document.addEventListener('mouseup', stopRibDrag);
    }

    function handleRibDrag(event) {
      if (!isDraggingRib) return;
      
      const deltaX = event.clientX - dragStartX;
      const pixelsPerDuration = 20; // 20 pixels per duration unit
      const durationChange = deltaX / pixelsPerDuration;
      
      let newDuration = dragStartDuration + durationChange;
      // Round to nearest 0.1 increment
      newDuration = Math.round(newDuration * 10) / 10;
      newDuration = Math.max(0.1, Math.min(10, newDuration)); // Limit between 0.1 and 10
      
      frameDurations[dragFrameIndex] = newDuration;
      updateFrameDurationIndicator(dragFrameIndex);
      
      // Update container width in real-time during drag
      const container = document.querySelector(`#timeline-${dragFrameIndex}`).closest('.timeline-frame-container');
      if (container) {
        const baseWidth = 50; // Base width for 1x duration
        const newWidth = baseWidth * newDuration;
        container.style.width = `${newWidth}px`;
      }
    }

    function stopRibDrag(event) {
      if (!isDraggingRib) return;
      
      isDraggingRib = false;
      
      // Remove visual feedback
      const rib = document.getElementById(`rib-${dragSide}-${dragFrameIndex}`);
      rib.classList.remove('dragging');
      
      const container = rib.closest('.timeline-frame-container');
      container.classList.remove('dragging');
      
      // Remove global event listeners
      document.removeEventListener('mousemove', handleRibDrag);
      document.removeEventListener('mouseup', stopRibDrag);
      
      dragFrameIndex = -1;
      dragSide = '';
    }

    function updateFrameDurationIndicator(frameIndex) {
      const indicator = document.getElementById(`duration-${frameIndex}`);
      if (indicator) {
        const duration = frameDurations[frameIndex];
        // Display with one decimal place for precision
        const displayText = `${duration.toFixed(1)}x`;
        indicator.textContent = displayText;
      }
      
      // Update the timeline frame container width based on duration
      const container = document.querySelector(`#timeline-${frameIndex}`).closest('.timeline-frame-container');
      if (container) {
        const baseWidth = 50; // Base width for 1x duration
        const newWidth = baseWidth * frameDurations[frameIndex];
        container.style.width = `${newWidth}px`;
      }
      
      // Update timeline ruler and total duration
      updateAllTimeScaleIndicators();
    }



    function updateAllTimeScaleIndicators() {
      // Schedule ruler update after layout to ensure new frames are measured correctly
      if (typeof requestAnimationFrame === 'function') {
        requestAnimationFrame(() => {
          updateTimelineRuler();
          updateTotalDuration();
        });
      } else {
        setTimeout(() => {
          updateTimelineRuler();
          updateTotalDuration();
        }, 0);
      }
    }

    function updateTimelineRuler() {
      const rulerElement = document.getElementById('timeline-ruler');
      if (!rulerElement) return;
      
      // Clear existing ruler
      rulerElement.innerHTML = '';
      
      // Get the actual timeline frame containers to match their exact positions
      const timelineContainers = document.querySelectorAll('.timeline-frame-container');
      if (timelineContainers.length === 0) return;
      
      // Get the timeline container's position and dimensions
      const timelineContainer = timelineContainers[0].parentElement;
      const timelineRect = timelineContainer.getBoundingClientRect();
      const rulerRect = rulerElement.getBoundingClientRect();
      
      // Calculate offset to align ruler with timeline
      const offsetX = timelineRect.left - rulerRect.left;
      
      // Set ruler width to match the timeline container width
      rulerElement.style.width = `${timelineRect.width}px`;
      
      // Calculate total duration for time calculations
      const totalDuration = frameDurations.reduce((sum, duration) => sum + duration, 0);
      const totalTimeInSeconds = (totalDuration / fps) * loopCount;
      const pixelsPerSecond = timelineRect.width / Math.max(totalTimeInSeconds, 0.1);
      
      // Add frame markers using exact positions from timeline frames
      const frames = [];
      let cumulativeTime = 0; // Track accurate time based on frame durations
      for (let i = 0; i < timelineContainers.length; i++) {
        const container = timelineContainers[i];
        const containerRect = container.getBoundingClientRect();
        
        // Calculate position relative to ruler
        const frameStartX = containerRect.left - rulerRect.left;
        const frameWidth = containerRect.width;
        const frameEndX = frameStartX + frameWidth;
        
        // Frame marker
        const frameMarker = document.createElement('div');
        frameMarker.setAttribute('data-frame-index', i);
        frameMarker.style.position = 'absolute';
        frameMarker.style.left = `${frameStartX}px`;
        frameMarker.style.top = '10px';
        frameMarker.style.width = `${frameWidth}px`;
        frameMarker.style.height = '20px';
        frameMarker.style.backgroundColor = '#4a4a4a';
        frameMarker.style.border = '1px solid #2a2a2a';
        frameMarker.style.borderRadius = '2px';
        frameMarker.style.zIndex = '5';
        frameMarker.style.color = '#ffffff';
        frameMarker.style.fontSize = '10px';
        frameMarker.style.lineHeight = '20px';
        frameMarker.style.textAlign = 'center';
        frameMarker.style.cursor = 'text';
        
        // Calculate time for tooltip using actual frame durations for accuracy
        const frameStartTime = cumulativeTime;
        const frameDuration = frameDurations[i] || 1;
        const frameTimeInSeconds = frameDuration / fps;
        const frameEndTime = cumulativeTime + frameTimeInSeconds;
        cumulativeTime = frameEndTime;
        
        frameMarker.title = `Frame ${i + 1}: ${frameStartTime.toFixed(2)}s - ${frameEndTime.toFixed(2)}s`;
        const label = document.createElement('span');
        label.className = 'ruler-frame-label';
        label.textContent = `${frameTimeInSeconds.toFixed(2)}s`;
        label.contentEditable = 'false';
        label.style.display = 'inline-block';
        label.style.padding = '0 4px';
        label.style.outline = 'none';
        frameMarker.appendChild(label);
        frameMarker.addEventListener('click', (e) => {
          e.stopPropagation();
          beginRulerInlineEdit(i, frameMarker, label);
        });
        
        rulerElement.appendChild(frameMarker);

        // Store frame mapping for accurate scrub-to-time conversion
        frames.push({ startX: frameStartX, endX: frameEndX, width: frameWidth, startTime: frameStartTime, endTime: frameEndTime });
      }
      
      // Store ruler data for scrubbing
      window.timelineRulerData = {
        totalTimeInSeconds,
        pixelsPerSecond,
        rulerWidth: timelineRect.width,
        offsetX,
        frames
      };
    }

    // Inline edit for ruler frame durations (seconds)
    function beginRulerInlineEdit(frameIndex, markerEl, labelEl) {
      // If already editing something else, commit it first
      if (window.currentRulerEdit && window.currentRulerEdit.labelEl !== labelEl) {
        commitRulerInlineEdit(true);
      }
      const currentUnits = frameDurations[frameIndex] || 1;
      const currentSeconds = currentUnits / fps;
      window.currentRulerEdit = {
        frameIndex,
        markerEl,
        labelEl,
        prevSeconds: currentSeconds,
        prevText: labelEl.textContent
      };
      // Visual activation: highlight border and enable caret
      markerEl.style.borderColor = '#8b5cf6';
      markerEl.style.boxShadow = '0 0 0 1px rgba(139,92,246,0.6) inset';
      labelEl.contentEditable = 'true';
      labelEl.textContent = currentSeconds.toFixed(2) + 's';
      // Place caret at end
      const range = document.createRange();
      range.selectNodeContents(labelEl);
      range.collapse(false);
      const sel = window.getSelection();
      if (sel) {
        sel.removeAllRanges();
        sel.addRange(range);
      }
      // Handlers
      const onKeyDown = (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          commitRulerInlineEdit(true);
        } else if (e.key === 'Escape') {
          e.preventDefault();
          commitRulerInlineEdit(false);
        }
      };
      const onClickOutside = (e) => {
        if (!markerEl.contains(e.target)) {
          commitRulerInlineEdit(true);
        }
      };
      // Live update while typing seconds (without rebuilding the whole ruler)
      const onInput = (e) => {
        const raw = (labelEl.textContent || '').trim().toLowerCase().replace(/s$/, '');
        const value = parseFloat(raw);
        if (!isFinite(value) || value <= 0) return;
        const seconds = value;
        const previewUnits = Math.max(0.1, roundToTenth(seconds * fps));
        // Resize the actual timeline frame container immediately
        const container = document.querySelector(`#timeline-${frameIndex}`)?.closest('.timeline-frame-container');
        if (container) {
          const baseWidth = 50;
          container.style.width = `${baseWidth * previewUnits}px`;
        }
        // Adjust this marker position/width to match container
        const rulerElement = document.getElementById('timeline-ruler');
        if (container && rulerElement) {
          const containerRect = container.getBoundingClientRect();
          const rulerRect = rulerElement.getBoundingClientRect();
          markerEl.style.left = `${containerRect.left - rulerRect.left}px`;
          markerEl.style.width = `${containerRect.width}px`;
        }
        // Update total duration preview
        const totalDurationElement = document.getElementById('total-duration');
        if (totalDurationElement) {
          let sumUnits = 0;
          for (let i = 0; i < frameDurations.length; i++) {
            sumUnits += (i === frameIndex) ? previewUnits : frameDurations[i];
          }
          const totalTimeInSeconds = (sumUnits / fps) * loopCount;
          totalDurationElement.textContent = `${totalTimeInSeconds.toFixed(2)}s`;
        }
      };
      window.currentRulerEdit.onKeyDown = onKeyDown;
      window.currentRulerEdit.onClickOutside = onClickOutside;
      window.currentRulerEdit.onInput = onInput;
      document.addEventListener('keydown', onKeyDown, true);
      document.addEventListener('mousedown', onClickOutside, true);
      labelEl.addEventListener('input', onInput, true);
    }
    function commitRulerInlineEdit(apply) {
      const edit = window.currentRulerEdit;
      if (!edit) return;
      const { frameIndex, markerEl, labelEl, prevSeconds, prevText, onKeyDown, onClickOutside, onInput } = edit;
      document.removeEventListener('keydown', onKeyDown, true);
      document.removeEventListener('mousedown', onClickOutside, true);
      if (onInput) labelEl.removeEventListener('input', onInput, true);
      // Parse typed value
      if (apply) {
        const raw = (labelEl.textContent || '').trim().toLowerCase().replace(/s$/, '');
        const value = parseFloat(raw);
        const seconds = isFinite(value) && value > 0 ? value : prevSeconds;
        if (typeof saveState === 'function') saveState();
        const newUnits = Math.max(0.1, roundToTenth(seconds * fps));
        frameDurations[frameIndex] = newUnits;
      }
      // Cleanup visual and refresh UI
      markerEl.style.borderColor = '#2a2a2a';
      markerEl.style.boxShadow = '';
      labelEl.contentEditable = 'false';
      // Recompute display via normal pipeline
      if (typeof updateAllTimeScaleIndicators === 'function') updateAllTimeScaleIndicators();
      window.currentRulerEdit = null;
    }

    function updateTotalDuration() {
      const totalDurationElement = document.getElementById('total-duration');
      if (totalDurationElement) {
        const totalDuration = frameDurations.reduce((sum, duration) => sum + duration, 0);
        const totalTimeInSeconds = (totalDuration / fps) * loopCount;
        totalDurationElement.textContent = `${totalTimeInSeconds.toFixed(2)}s`;
      }
    }

    // Magic Timeline effect helpers
    function roundToTenth(value) {
      return Math.round(value * 10) / 10;
    }
    function refreshTimelineDurationsUI() {
      // Rebuild the timeline so DOM reflects new widths before ruler recompute
      if (typeof updateTimelineDisplay === 'function') {
        updateTimelineDisplay();
      } else {
        // Fallback to per-frame indicators if needed
        for (let i = 0; i < frameDurations.length; i++) {
          if (typeof updateFrameDurationIndicator === 'function') {
            updateFrameDurationIndicator(i);
          }
        }
        if (typeof updateAllTimeScaleIndicators === 'function') {
          updateAllTimeScaleIndicators();
        }
      }
    }
    function applyTimelineEaseIn() {
      if (!Array.isArray(frameDurations) || frameDurations.length === 0) return;
      if (typeof saveState === 'function') saveState();
      const n = frameDurations.length;
      for (let i = 0; i < n; i++) {
        const t = n > 1 ? (i / (n - 1)) : 0;
        const d = 0.5 + 1.5 * (t * t); // small early, larger later
        frameDurations[i] = Math.max(0.1, Math.min(10, roundToTenth(d)));
      }
      refreshTimelineDurationsUI();
      if (typeof showCopyPasteFeedback === 'function') showCopyPasteFeedback('Applied Ease In timing');
    }
    function applyTimelineEaseOut() {
      if (!Array.isArray(frameDurations) || frameDurations.length === 0) return;
      if (typeof saveState === 'function') saveState();
      const n = frameDurations.length;
      for (let i = 0; i < n; i++) {
        const t = n > 1 ? (i / (n - 1)) : 0;
        const d = 0.5 + 1.5 * ((1 - t) * (1 - t)); // larger early, small later
        frameDurations[i] = Math.max(0.1, Math.min(10, roundToTenth(d)));
      }
      refreshTimelineDurationsUI();
      if (typeof showCopyPasteFeedback === 'function') showCopyPasteFeedback('Applied Ease Out timing');
    }
    function applyTimelineEaseInOut() {
      if (!Array.isArray(frameDurations) || frameDurations.length === 0) return;
      if (typeof saveState === 'function') saveState();
      const n = frameDurations.length;
      for (let i = 0; i < n; i++) {
        const t = n > 1 ? (i / (n - 1)) : 0;
        const d = 0.5 + 1.5 * Math.abs(Math.cos(Math.PI * t)); // longer at ends, shorter in the middle
        frameDurations[i] = Math.max(0.1, Math.min(10, roundToTenth(d)));
      }
      refreshTimelineDurationsUI();
      if (typeof showCopyPasteFeedback === 'function') showCopyPasteFeedback('Applied Ease In-Out timing');
    }
    function applyTimelineLinear() {
      if (!Array.isArray(frameDurations) || frameDurations.length === 0) return;
      if (typeof saveState === 'function') saveState();
      for (let i = 0; i < frameDurations.length; i++) {
        frameDurations[i] = 1;
      }
      refreshTimelineDurationsUI();
      if (typeof showCopyPasteFeedback === 'function') showCopyPasteFeedback('Reset timing to Linear');
    }
    function applyTimelineSpeedUp() {
      if (!Array.isArray(frameDurations) || frameDurations.length === 0) return;
      if (typeof saveState === 'function') saveState();
      for (let i = 0; i < frameDurations.length; i++) {
        frameDurations[i] = Math.max(0.1, roundToTenth(frameDurations[i] * 0.8));
      }
      refreshTimelineDurationsUI();
      if (typeof showCopyPasteFeedback === 'function') showCopyPasteFeedback('Sped up timing');
    }
    function applyTimelineAcceleration() {
      if (!Array.isArray(frameDurations) || frameDurations.length === 0) return;
      if (typeof saveState === 'function') saveState();
      const n = frameDurations.length;
      const oldTotal = frameDurations.reduce((a, b) => a + b, 0) || n;
      const raw = new Array(n);
      // Multipliers decrease across the timeline to speed up later frames
      for (let i = 0; i < n; i++) {
        const t = n > 1 ? (i / (n - 1)) : 0;
        const m = 1.3 - 0.7 * t; // from ~1.3 at start to ~0.6 at end
        raw[i] = Math.max(0.1, frameDurations[i] * m);
      }
      const rawTotal = raw.reduce((a, b) => a + b, 0) || oldTotal;
      const scale = rawTotal > 0 ? (oldTotal / rawTotal) : 1;
      for (let i = 0; i < n; i++) {
        frameDurations[i] = roundToTenth(Math.max(0.1, Math.min(10, raw[i] * scale)));
      }
      refreshTimelineDurationsUI();
      if (typeof showCopyPasteFeedback === 'function') showCopyPasteFeedback('Applied acceleration timing');
    }

    function applyTimelineAutoPaceByMotion() {
      if (!Array.isArray(frameDurations) || frameDurations.length === 0) return;
      if (typeof saveState === 'function') saveState();
      const n = frameDurations.length;
      // Compute centroid-based speeds between frames
      const speeds = new Array(n).fill(0);
      let maxSpeed = 0.0001;
      for (let i = 1; i < n; i++) {
        const a = typeof computeFrameCentroid === 'function' ? computeFrameCentroid(i - 1) : { x: 0, y: 0 };
        const b = typeof computeFrameCentroid === 'function' ? computeFrameCentroid(i) : { x: 0, y: 0 };
        const dx = (b.x || 0) - (a.x || 0);
        const dy = (b.y || 0) - (a.y || 0);
        const s = Math.sqrt(dx * dx + dy * dy);
        speeds[i] = s;
        if (s > maxSpeed) maxSpeed = s;
      }
      // Map inverse speed to duration: bigger holds where motion is low
      const minDur = 0.5, maxDur = 2.5;
      const newDur = new Array(n);
      for (let i = 0; i < n; i++) {
        const sNorm = Math.min(1, speeds[i] / maxSpeed);
        const d = minDur + (1 - sNorm) * (maxDur - minDur);
        newDur[i] = Math.max(0.1, Math.min(10, d));
      }
      // Preserve total time approximately
      const oldTotal = frameDurations.reduce((a, b) => a + b, 0) || n;
      const newTotal = newDur.reduce((a, b) => a + b, 0) || n;
      const scale = oldTotal > 0 ? (oldTotal / newTotal) : 1;
      for (let i = 0; i < n; i++) frameDurations[i] = roundToTenth(Math.max(0.1, Math.min(10, newDur[i] * scale)));
      refreshTimelineDurationsUI();
      if (typeof showCopyPasteFeedback === 'function') showCopyPasteFeedback('Auto-paced timing by motion');
    }

    function applyTimelineKeyposeHolds() {
      if (!Array.isArray(frameDurations) || frameDurations.length === 0) return;
      if (typeof saveState === 'function') saveState();
      const n = frameDurations.length;
      // Compute speeds
      const speeds = new Array(n).fill(0);
      let maxSpeed = 0.0001;
      for (let i = 1; i < n; i++) {
        const a = typeof computeFrameCentroid === 'function' ? computeFrameCentroid(i - 1) : { x: 0, y: 0 };
        const b = typeof computeFrameCentroid === 'function' ? computeFrameCentroid(i) : { x: 0, y: 0 };
        const dx = (b.x || 0) - (a.x || 0);
        const dy = (b.y || 0) - (a.y || 0);
        const s = Math.sqrt(dx * dx + dy * dy);
        speeds[i] = s;
        if (s > maxSpeed) maxSpeed = s;
      }
      // Identify keyposes: local minima in speed or near zero speed
      const keypose = new Array(n).fill(false);
      const threshold = (maxSpeed * 0.25);
      for (let i = 1; i < n - 1; i++) {
        const isLocalMin = speeds[i] <= speeds[i - 1] && speeds[i] <= speeds[i + 1];
        if (isLocalMin || speeds[i] < threshold) keypose[i] = true;
      }
      // Assign durations: long holds for keyposes, shorter for transitions
      const holdDur = 2.2, transitDur = 0.7;
      for (let i = 0; i < n; i++) {
        frameDurations[i] = roundToTenth(keypose[i] ? holdDur : transitDur);
      }
      // Keep first/last slightly longer for pleasant cadence
      frameDurations[0] = roundToTenth(Math.max(frameDurations[0], 1.6));
      frameDurations[n - 1] = roundToTenth(Math.max(frameDurations[n - 1], 1.6));
      refreshTimelineDurationsUI();
      if (typeof showCopyPasteFeedback === 'function') showCopyPasteFeedback('Added keypose holds');
    }
    // Timeline scrubbing variables
    let isScrubbing = false;
    let scrubberStartX = 0;
    // Ruler selection (drag highlight over seconds labels)
    let isRulerSelecting = false;
    let rulerSelectStartX = 0;
    let rulerSelectionHasMoved = false;

    function startTimelineScrub(event) {
      // If starting on a seconds label, support drag highlight and avoid interfering with editing/double-click
      const isOnSecondsLabel = !!(event.target && ((event.target.classList && event.target.classList.contains('ruler-frame-label')) || (event.target.closest && event.target.closest('.ruler-frame-label'))));
      if (isOnSecondsLabel) {
        // If currently editing this label, allow native selection/clicks
        if (window.currentRulerEdit && window.currentRulerEdit.labelEl && (window.currentRulerEdit.labelEl === event.target || (event.target.closest && event.target.closest('.ruler-frame-label') === window.currentRulerEdit.labelEl))) {
          return;
        }
        const rulerElement = document.getElementById('timeline-ruler');
        if (!rulerElement || !window.timelineRulerData) return;
        isRulerSelecting = true;
        rulerSelectionHasMoved = false;
        const rect = rulerElement.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const clampedX = Math.max(0, Math.min(x, window.timelineRulerData.rulerWidth));
        rulerSelectStartX = clampedX;
        let selEl = window.rulerSelectionEl;
        if (!selEl) {
          selEl = document.createElement('div');
          selEl.id = 'timeline-ruler-selection';
          selEl.style.position = 'absolute';
          selEl.style.top = '10px';
          selEl.style.height = '20px';
          selEl.style.background = 'rgba(255, 235, 59, 0.35)';
          selEl.style.border = '1px solid rgba(255, 235, 59, 0.5)';
          selEl.style.borderRadius = '2px';
          selEl.style.zIndex = '4';
          selEl.style.pointerEvents = 'none';
          selEl.style.display = 'none';
          rulerElement.appendChild(selEl);
          window.rulerSelectionEl = selEl;
        }
        // Initialize invisible selection box; will appear on drag
        selEl.style.display = 'none';
        selEl.style.left = `${clampedX}px`;
        selEl.style.width = '0px';
        document.addEventListener('mousemove', handleRulerSelectionDrag);
        document.addEventListener('mouseup', stopRulerSelection);
        return;
      }
      event.preventDefault();
      isScrubbing = true;
      scrubberStartX = event.clientX;
      document.addEventListener('mousemove', handleTimelineScrub);
      document.addEventListener('mouseup', stopTimelineScrub);
      updateScrubberPosition(event);
    }

    function handleRulerSelectionDrag(event) {
      if (!isRulerSelecting) return;
      const rulerElement = document.getElementById('timeline-ruler');
      const data = window.timelineRulerData;
      const selEl = window.rulerSelectionEl;
      if (!rulerElement || !data || !selEl) return;
      const rect = rulerElement.getBoundingClientRect();
      const x = Math.max(0, Math.min(event.clientX - rect.left, data.rulerWidth));
      if (Math.abs(x - rulerSelectStartX) > 2) rulerSelectionHasMoved = true;
      const left = Math.min(rulerSelectStartX, x);
      const width = Math.abs(x - rulerSelectStartX);
      selEl.style.display = width > 2 ? 'block' : 'none';
      selEl.style.left = `${left}px`;
      selEl.style.width = `${width}px`;
    }

    function stopRulerSelection() {
      if (!isRulerSelecting) return;
      isRulerSelecting = false;
      document.removeEventListener('mousemove', handleRulerSelectionDrag);
      document.removeEventListener('mouseup', stopRulerSelection);
      if (window.rulerSelectionEl) {
        window.rulerSelectionEl.style.display = 'none';
      }
    }
    function handleTimelineScrub(event) {
      if (!isScrubbing) return;
      updateScrubberPosition(event);
    }

    function stopTimelineScrub(event) {
      if (!isScrubbing) return;
      isScrubbing = false;
      
      // Remove global event listeners
      document.removeEventListener('mousemove', handleTimelineScrub);
      document.removeEventListener('mouseup', stopTimelineScrub);
    }

    function updateScrubberPosition(event) {
      const rulerElement = document.getElementById('timeline-ruler');
      const scrubberElement = document.getElementById('timeline-scrubber');
      const timeDisplayElement = document.getElementById('timeline-time-display');
      
      if (!rulerElement || !scrubberElement || !window.timelineRulerData) return;
      
      const rect = rulerElement.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const clampedX = Math.max(0, Math.min(x, window.timelineRulerData.rulerWidth));
      
      // Update scrubber position
      scrubberElement.style.left = `${clampedX}px`;
      
      // Calculate time at this position using per-frame mapping for accuracy
      let timeInSeconds = 0;
      const data = window.timelineRulerData;
      if (data.frames && data.frames.length) {
        let found = false;
        for (let i = 0; i < data.frames.length; i++) {
          const f = data.frames[i];
          // Inside a frame: interpolate time within that frame
          if (clampedX >= f.startX && clampedX <= f.endX) {
            const width = Math.max(1, f.width);
            const ratio = (clampedX - f.startX) / width;
            timeInSeconds = f.startTime + ratio * (f.endTime - f.startTime);
            found = true;
            break;
          }
          // In the gap after this frame and before the next: snap to this frame's end
          if (i < data.frames.length - 1) {
            const next = data.frames[i + 1];
            if (clampedX > f.endX && clampedX < next.startX) {
              timeInSeconds = f.endTime;
              found = true;
              break;
            }
          }
        }
        if (!found) {
          if (clampedX <= data.frames[0].startX) timeInSeconds = data.frames[0].startTime; // usually 0
          else timeInSeconds = data.frames[data.frames.length - 1].endTime; // end of last frame
        }
      } else {
        timeInSeconds = clampedX / data.pixelsPerSecond;
      }
      
      // Update time display
      if (timeDisplayElement) {
        timeDisplayElement.textContent = `${timeInSeconds.toFixed(2)}s`;
        timeDisplayElement.style.display = 'block';
      }
      
      // Find which frame this position corresponds to using actual timeline frame positions
      const timelineContainers = document.querySelectorAll('.timeline-frame-container');
      let currentFrameAtTime = -1; // -1 means no frame (between frames)
      
      for (let i = 0; i < timelineContainers.length; i++) {
        const container = timelineContainers[i];
        const containerRect = container.getBoundingClientRect();
        const rulerRect = rulerElement.getBoundingClientRect();
        
        const frameStartX = containerRect.left - rulerRect.left;
        const frameEndX = frameStartX + containerRect.width;
        
        // Only highlight if scrubber is clearly within a frame (not at boundaries)
        if (clampedX > frameStartX && clampedX < frameEndX) {
          currentFrameAtTime = i;
          break;
        }
      }
      
      // Highlight the frame at this time (or clear if between frames)
      updateFrameHighlight(currentFrameAtTime);
    }

    function updateTimelineHover(event) {
      if (isScrubbing) return;
      updateScrubberPosition(event);
    }

    function hideTimelineHover() {
      const timeDisplayElement = document.getElementById('timeline-time-display');
      if (timeDisplayElement) {
        timeDisplayElement.style.display = 'none';
      }
    }

    function updateFrameHighlight(frameIndex) {
      // Update frame markers to show which frame is at the current time
      const rulerElement = document.getElementById('timeline-ruler');
      if (!rulerElement) return;
      
      const frameMarkers = rulerElement.querySelectorAll('[data-frame-index]');
      frameMarkers.forEach((marker, index) => {
        if (frameIndex >= 0 && index === frameIndex) {
          marker.style.backgroundColor = '#6366f1';
          marker.style.borderColor = '#6366f1';
        } else {
          marker.style.backgroundColor = '#4a4a4a';
          marker.style.borderColor = '#2a2a2a';
        }
      });
      
      // Also update the actual timeline frames to show which one is active
      const timelineFrames = document.querySelectorAll('.timeline-frame');
      timelineFrames.forEach((frame, index) => {
        if (frameIndex >= 0 && index === frameIndex) {
          frame.classList.add('active');
        } else {
          frame.classList.remove('active');
        }
      });
    }

    updateLayersList();
    updateFrameLabel();
    composeLayers();
    saveState();
    
    // Initialize frame duration indicators and timeline ruler
    for (let i = 0; i < 6; i++) {
      updateFrameDurationIndicator(i);
    }
    
    // Sync ruler with timeline scroll position
    function syncRulerWithTimeline() {
      const rulerElement = document.getElementById('timeline-ruler');
      const timelineContainer = document.querySelector('.flex.gap-2.pb-6');
      
      if (rulerElement && timelineContainer) {
        // Update ruler position when timeline scrolls
        timelineContainer.addEventListener('scroll', () => {
          rulerElement.style.transform = `translateX(-${timelineContainer.scrollLeft}px)`;
        });
      }
    }
    
    // Initialize ruler sync
    syncRulerWithTimeline();
    
    // Safari scrollbar styling enforcement
    function enforceScrollbarStyling() {
      // Force scrollbar styles to be applied in Safari
      const style = document.createElement('style');
      style.id = 'safari-scrollbar-enforcement';
      style.textContent = `
        /* Safari scrollbar enforcement */
         ::-webkit-scrollbar {
           width: 8px !important;
           height: 8px !important;
           background: #28282e !important;
         }
         ::-webkit-scrollbar-track {
           background: #28282e !important;
         }
         ::-webkit-scrollbar-thumb {
           background: #5a5f65 !important;
           border-radius: 4px !important;
           border: none !important;
         }
        ::-webkit-scrollbar-corner {
          background: transparent !important;
        }
      `;
      
      // Remove existing enforcement if it exists
      const existing = document.getElementById('safari-scrollbar-enforcement');
      if (existing) {
        existing.remove();
      }
      
      // Add the enforcement
      document.head.appendChild(style);
      
      // Force a reflow to ensure styles are applied
      document.body.style.display = 'none';
      document.body.offsetHeight; // Trigger reflow
      document.body.style.display = '';
    }
    
    // Apply scrollbar styling immediately and on load
    enforceScrollbarStyling();
    window.addEventListener('load', enforceScrollbarStyling);
    setTimeout(enforceScrollbarStyling, 100);
    setTimeout(enforceScrollbarStyling, 500);
    
    
    
    function toggleContactPopup(event) {
      event.preventDefault();
      const popup = document.getElementById('contact-popup');
      const link = document.getElementById('contact-link');
      if (!popup || !link) return;
      
      const container = link.closest('.panel') || document.body;
      const containerRect = container.getBoundingClientRect();
      const linkRect = link.getBoundingClientRect();
      
      popup.style.top = `${linkRect.bottom - containerRect.top + 8}px`;
      popup.style.left = `${linkRect.left - containerRect.left}px`;
      popup.classList.toggle('hidden');
    }
    
    /* Set initial viewport to phone on page load */
    setViewport('phone');
    
    function startAutoAnimation() {
      if (!animationInterval) {
        isPreviewingLayer = false;
        previewLayerIndex = -1;
        animationFrame = 0;
        currentFrameTime = 0;
        currentFrameDuration = frameDurations[0];
        animationInterval = setInterval(updateAnimation, 1000 / fps);
        document.getElementById('play-btn').innerHTML = `
          <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
            <rect x="6" y="4" width="4" height="16"/>
            <rect x="14" y="4" width="4" height="16"/>
          </svg>
          Pause
        `;
      }
    }

    // Close brush menu when clicking outside
    document.addEventListener('click', function(e) {
      const brushMenu = document.getElementById('brush-menu');
      const brushBtn = document.getElementById('brush-btn');
      
      if (!brushBtn.contains(e.target) && !brushMenu.contains(e.target)) {
        brushMenu.classList.add('hidden');
      }
      const detailMenu = document.getElementById('detail-menu');
      const detailBtn = document.getElementById('detail-btn');
      if (detailMenu && detailBtn && !detailBtn.contains(e.target) && !detailMenu.contains(e.target)) {
        detailMenu.classList.add('hidden');
      }
      const contactPopup = document.getElementById('contact-popup');
      const contactLink = document.getElementById('contact-link');
      if (contactPopup && !contactPopup.classList.contains('hidden')) {
        const clickedContact = contactLink && contactLink.contains(e.target);
        const clickedPopup = contactPopup.contains(e.target);
        if (!clickedContact && !clickedPopup) {
          contactPopup.classList.add('hidden');
        }
      }
    });
    
    // Removed select lasso toggle; now a standalone Magic Tool

    // Initialize brush menu with default selection
    selectBrushType('basic');
    // Ensure detail menu reflects default selected style
    updateDetailMenuActive();
    
    startAutoAnimation();
    
    // Make context menu function globally accessible
    window.showFrameContextMenu = showFrameContextMenu;
    
    // Prevent default browser behavior when dropping files outside frames
    window.addEventListener('dragover', (e) => e.preventDefault());
    window.addEventListener('drop', (e) => e.preventDefault());
  </script>
</body>
</html>
</html>
